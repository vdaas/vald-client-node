/* eslint-disable */
// @generated by protobuf-ts 2.9.4 with parameter add_pb_suffix,client_grpc1,generate_dependencies,keep_enum_prefix,ts_nocheck,use_proto_field_name,output_javascript,output_legacy_commonjs,eslint_disable
// @generated from protobuf file "buf/validate/validate.proto" (package "buf.validate", syntax proto3)
// tslint:disable
// @ts-nocheck
//
// Copyright 2023 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimestampRules = exports.DurationRules = exports.AnyRules = exports.MapRules = exports.RepeatedRules = exports.EnumRules = exports.BytesRules = exports.StringRules = exports.BoolRules = exports.SFixed64Rules = exports.SFixed32Rules = exports.Fixed64Rules = exports.Fixed32Rules = exports.SInt64Rules = exports.SInt32Rules = exports.UInt64Rules = exports.UInt32Rules = exports.Int64Rules = exports.Int32Rules = exports.DoubleRules = exports.FloatRules = exports.FieldConstraints = exports.OneofConstraints = exports.MessageConstraints = exports.KnownRegex = void 0;
const runtime_1 = require("@protobuf-ts/runtime");
const runtime_2 = require("@protobuf-ts/runtime");
const runtime_3 = require("@protobuf-ts/runtime");
const runtime_4 = require("@protobuf-ts/runtime");
const timestamp_pb_1 = require("../../google/protobuf/timestamp_pb");
const duration_pb_1 = require("../../google/protobuf/duration_pb");
const expression_pb_1 = require("./expression_pb");
/**
 * WellKnownRegex contain some well-known patterns.
 *
 * @generated from protobuf enum buf.validate.KnownRegex
 */
var KnownRegex;
(function (KnownRegex) {
    /**
     * @generated from protobuf enum value: KNOWN_REGEX_UNSPECIFIED = 0;
     */
    KnownRegex[KnownRegex["KNOWN_REGEX_UNSPECIFIED"] = 0] = "KNOWN_REGEX_UNSPECIFIED";
    /**
     * HTTP header name as defined by [RFC 7230](https://tools.ietf.org/html/rfc7230#section-3.2).
     *
     * @generated from protobuf enum value: KNOWN_REGEX_HTTP_HEADER_NAME = 1;
     */
    KnownRegex[KnownRegex["KNOWN_REGEX_HTTP_HEADER_NAME"] = 1] = "KNOWN_REGEX_HTTP_HEADER_NAME";
    /**
     * HTTP header value as defined by [RFC 7230](https://tools.ietf.org/html/rfc7230#section-3.2.4).
     *
     * @generated from protobuf enum value: KNOWN_REGEX_HTTP_HEADER_VALUE = 2;
     */
    KnownRegex[KnownRegex["KNOWN_REGEX_HTTP_HEADER_VALUE"] = 2] = "KNOWN_REGEX_HTTP_HEADER_VALUE";
})(KnownRegex = exports.KnownRegex || (exports.KnownRegex = {}));
// @generated message type with reflection information, may provide speed optimized methods
class MessageConstraints$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.MessageConstraints", [
            { no: 1, name: "disabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "cel", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => expression_pb_1.Constraint }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.cel = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool disabled */ 1:
                    message.disabled = reader.bool();
                    break;
                case /* repeated buf.validate.Constraint cel */ 3:
                    message.cel.push(expression_pb_1.Constraint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional bool disabled = 1; */
        if (message.disabled !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.disabled);
        /* repeated buf.validate.Constraint cel = 3; */
        for (let i = 0; i < message.cel.length; i++)
            expression_pb_1.Constraint.internalBinaryWrite(message.cel[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.MessageConstraints
 */
exports.MessageConstraints = new MessageConstraints$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OneofConstraints$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.OneofConstraints", [
            { no: 1, name: "required", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool required */ 1:
                    message.required = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional bool required = 1; */
        if (message.required !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.required);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.OneofConstraints
 */
exports.OneofConstraints = new OneofConstraints$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FieldConstraints$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.FieldConstraints", [
            { no: 23, name: "cel", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => expression_pb_1.Constraint },
            { no: 24, name: "skipped", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 25, name: "required", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 26, name: "ignore_empty", kind: "scalar", localName: "ignore_empty", T: 8 /*ScalarType.BOOL*/ },
            { no: 1, name: "float", kind: "message", oneof: "type", T: () => exports.FloatRules },
            { no: 2, name: "double", kind: "message", oneof: "type", T: () => exports.DoubleRules },
            { no: 3, name: "int32", kind: "message", oneof: "type", T: () => exports.Int32Rules },
            { no: 4, name: "int64", kind: "message", oneof: "type", T: () => exports.Int64Rules },
            { no: 5, name: "uint32", kind: "message", oneof: "type", T: () => exports.UInt32Rules },
            { no: 6, name: "uint64", kind: "message", oneof: "type", T: () => exports.UInt64Rules },
            { no: 7, name: "sint32", kind: "message", oneof: "type", T: () => exports.SInt32Rules },
            { no: 8, name: "sint64", kind: "message", oneof: "type", T: () => exports.SInt64Rules },
            { no: 9, name: "fixed32", kind: "message", oneof: "type", T: () => exports.Fixed32Rules },
            { no: 10, name: "fixed64", kind: "message", oneof: "type", T: () => exports.Fixed64Rules },
            { no: 11, name: "sfixed32", kind: "message", oneof: "type", T: () => exports.SFixed32Rules },
            { no: 12, name: "sfixed64", kind: "message", oneof: "type", T: () => exports.SFixed64Rules },
            { no: 13, name: "bool", kind: "message", oneof: "type", T: () => exports.BoolRules },
            { no: 14, name: "string", kind: "message", oneof: "type", T: () => exports.StringRules },
            { no: 15, name: "bytes", kind: "message", oneof: "type", T: () => exports.BytesRules },
            { no: 16, name: "enum", kind: "message", oneof: "type", T: () => exports.EnumRules },
            { no: 18, name: "repeated", kind: "message", oneof: "type", T: () => exports.RepeatedRules },
            { no: 19, name: "map", kind: "message", oneof: "type", T: () => exports.MapRules },
            { no: 20, name: "any", kind: "message", oneof: "type", T: () => exports.AnyRules },
            { no: 21, name: "duration", kind: "message", oneof: "type", T: () => exports.DurationRules },
            { no: 22, name: "timestamp", kind: "message", oneof: "type", T: () => exports.TimestampRules }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.cel = [];
        message.skipped = false;
        message.required = false;
        message.ignore_empty = false;
        message.type = { oneofKind: undefined };
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated buf.validate.Constraint cel */ 23:
                    message.cel.push(expression_pb_1.Constraint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool skipped */ 24:
                    message.skipped = reader.bool();
                    break;
                case /* bool required */ 25:
                    message.required = reader.bool();
                    break;
                case /* bool ignore_empty */ 26:
                    message.ignore_empty = reader.bool();
                    break;
                case /* buf.validate.FloatRules float */ 1:
                    message.type = {
                        oneofKind: "float",
                        float: exports.FloatRules.internalBinaryRead(reader, reader.uint32(), options, message.type.float)
                    };
                    break;
                case /* buf.validate.DoubleRules double */ 2:
                    message.type = {
                        oneofKind: "double",
                        double: exports.DoubleRules.internalBinaryRead(reader, reader.uint32(), options, message.type.double)
                    };
                    break;
                case /* buf.validate.Int32Rules int32 */ 3:
                    message.type = {
                        oneofKind: "int32",
                        int32: exports.Int32Rules.internalBinaryRead(reader, reader.uint32(), options, message.type.int32)
                    };
                    break;
                case /* buf.validate.Int64Rules int64 */ 4:
                    message.type = {
                        oneofKind: "int64",
                        int64: exports.Int64Rules.internalBinaryRead(reader, reader.uint32(), options, message.type.int64)
                    };
                    break;
                case /* buf.validate.UInt32Rules uint32 */ 5:
                    message.type = {
                        oneofKind: "uint32",
                        uint32: exports.UInt32Rules.internalBinaryRead(reader, reader.uint32(), options, message.type.uint32)
                    };
                    break;
                case /* buf.validate.UInt64Rules uint64 */ 6:
                    message.type = {
                        oneofKind: "uint64",
                        uint64: exports.UInt64Rules.internalBinaryRead(reader, reader.uint32(), options, message.type.uint64)
                    };
                    break;
                case /* buf.validate.SInt32Rules sint32 */ 7:
                    message.type = {
                        oneofKind: "sint32",
                        sint32: exports.SInt32Rules.internalBinaryRead(reader, reader.uint32(), options, message.type.sint32)
                    };
                    break;
                case /* buf.validate.SInt64Rules sint64 */ 8:
                    message.type = {
                        oneofKind: "sint64",
                        sint64: exports.SInt64Rules.internalBinaryRead(reader, reader.uint32(), options, message.type.sint64)
                    };
                    break;
                case /* buf.validate.Fixed32Rules fixed32 */ 9:
                    message.type = {
                        oneofKind: "fixed32",
                        fixed32: exports.Fixed32Rules.internalBinaryRead(reader, reader.uint32(), options, message.type.fixed32)
                    };
                    break;
                case /* buf.validate.Fixed64Rules fixed64 */ 10:
                    message.type = {
                        oneofKind: "fixed64",
                        fixed64: exports.Fixed64Rules.internalBinaryRead(reader, reader.uint32(), options, message.type.fixed64)
                    };
                    break;
                case /* buf.validate.SFixed32Rules sfixed32 */ 11:
                    message.type = {
                        oneofKind: "sfixed32",
                        sfixed32: exports.SFixed32Rules.internalBinaryRead(reader, reader.uint32(), options, message.type.sfixed32)
                    };
                    break;
                case /* buf.validate.SFixed64Rules sfixed64 */ 12:
                    message.type = {
                        oneofKind: "sfixed64",
                        sfixed64: exports.SFixed64Rules.internalBinaryRead(reader, reader.uint32(), options, message.type.sfixed64)
                    };
                    break;
                case /* buf.validate.BoolRules bool */ 13:
                    message.type = {
                        oneofKind: "bool",
                        bool: exports.BoolRules.internalBinaryRead(reader, reader.uint32(), options, message.type.bool)
                    };
                    break;
                case /* buf.validate.StringRules string */ 14:
                    message.type = {
                        oneofKind: "string",
                        string: exports.StringRules.internalBinaryRead(reader, reader.uint32(), options, message.type.string)
                    };
                    break;
                case /* buf.validate.BytesRules bytes */ 15:
                    message.type = {
                        oneofKind: "bytes",
                        bytes: exports.BytesRules.internalBinaryRead(reader, reader.uint32(), options, message.type.bytes)
                    };
                    break;
                case /* buf.validate.EnumRules enum */ 16:
                    message.type = {
                        oneofKind: "enum",
                        enum: exports.EnumRules.internalBinaryRead(reader, reader.uint32(), options, message.type.enum)
                    };
                    break;
                case /* buf.validate.RepeatedRules repeated */ 18:
                    message.type = {
                        oneofKind: "repeated",
                        repeated: exports.RepeatedRules.internalBinaryRead(reader, reader.uint32(), options, message.type.repeated)
                    };
                    break;
                case /* buf.validate.MapRules map */ 19:
                    message.type = {
                        oneofKind: "map",
                        map: exports.MapRules.internalBinaryRead(reader, reader.uint32(), options, message.type.map)
                    };
                    break;
                case /* buf.validate.AnyRules any */ 20:
                    message.type = {
                        oneofKind: "any",
                        any: exports.AnyRules.internalBinaryRead(reader, reader.uint32(), options, message.type.any)
                    };
                    break;
                case /* buf.validate.DurationRules duration */ 21:
                    message.type = {
                        oneofKind: "duration",
                        duration: exports.DurationRules.internalBinaryRead(reader, reader.uint32(), options, message.type.duration)
                    };
                    break;
                case /* buf.validate.TimestampRules timestamp */ 22:
                    message.type = {
                        oneofKind: "timestamp",
                        timestamp: exports.TimestampRules.internalBinaryRead(reader, reader.uint32(), options, message.type.timestamp)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated buf.validate.Constraint cel = 23; */
        for (let i = 0; i < message.cel.length; i++)
            expression_pb_1.Constraint.internalBinaryWrite(message.cel[i], writer.tag(23, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool skipped = 24; */
        if (message.skipped !== false)
            writer.tag(24, runtime_1.WireType.Varint).bool(message.skipped);
        /* bool required = 25; */
        if (message.required !== false)
            writer.tag(25, runtime_1.WireType.Varint).bool(message.required);
        /* bool ignore_empty = 26; */
        if (message.ignore_empty !== false)
            writer.tag(26, runtime_1.WireType.Varint).bool(message.ignore_empty);
        /* buf.validate.FloatRules float = 1; */
        if (message.type.oneofKind === "float")
            exports.FloatRules.internalBinaryWrite(message.type.float, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.DoubleRules double = 2; */
        if (message.type.oneofKind === "double")
            exports.DoubleRules.internalBinaryWrite(message.type.double, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.Int32Rules int32 = 3; */
        if (message.type.oneofKind === "int32")
            exports.Int32Rules.internalBinaryWrite(message.type.int32, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.Int64Rules int64 = 4; */
        if (message.type.oneofKind === "int64")
            exports.Int64Rules.internalBinaryWrite(message.type.int64, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.UInt32Rules uint32 = 5; */
        if (message.type.oneofKind === "uint32")
            exports.UInt32Rules.internalBinaryWrite(message.type.uint32, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.UInt64Rules uint64 = 6; */
        if (message.type.oneofKind === "uint64")
            exports.UInt64Rules.internalBinaryWrite(message.type.uint64, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.SInt32Rules sint32 = 7; */
        if (message.type.oneofKind === "sint32")
            exports.SInt32Rules.internalBinaryWrite(message.type.sint32, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.SInt64Rules sint64 = 8; */
        if (message.type.oneofKind === "sint64")
            exports.SInt64Rules.internalBinaryWrite(message.type.sint64, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.Fixed32Rules fixed32 = 9; */
        if (message.type.oneofKind === "fixed32")
            exports.Fixed32Rules.internalBinaryWrite(message.type.fixed32, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.Fixed64Rules fixed64 = 10; */
        if (message.type.oneofKind === "fixed64")
            exports.Fixed64Rules.internalBinaryWrite(message.type.fixed64, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.SFixed32Rules sfixed32 = 11; */
        if (message.type.oneofKind === "sfixed32")
            exports.SFixed32Rules.internalBinaryWrite(message.type.sfixed32, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.SFixed64Rules sfixed64 = 12; */
        if (message.type.oneofKind === "sfixed64")
            exports.SFixed64Rules.internalBinaryWrite(message.type.sfixed64, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.BoolRules bool = 13; */
        if (message.type.oneofKind === "bool")
            exports.BoolRules.internalBinaryWrite(message.type.bool, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.StringRules string = 14; */
        if (message.type.oneofKind === "string")
            exports.StringRules.internalBinaryWrite(message.type.string, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.BytesRules bytes = 15; */
        if (message.type.oneofKind === "bytes")
            exports.BytesRules.internalBinaryWrite(message.type.bytes, writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.EnumRules enum = 16; */
        if (message.type.oneofKind === "enum")
            exports.EnumRules.internalBinaryWrite(message.type.enum, writer.tag(16, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.RepeatedRules repeated = 18; */
        if (message.type.oneofKind === "repeated")
            exports.RepeatedRules.internalBinaryWrite(message.type.repeated, writer.tag(18, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.MapRules map = 19; */
        if (message.type.oneofKind === "map")
            exports.MapRules.internalBinaryWrite(message.type.map, writer.tag(19, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.AnyRules any = 20; */
        if (message.type.oneofKind === "any")
            exports.AnyRules.internalBinaryWrite(message.type.any, writer.tag(20, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.DurationRules duration = 21; */
        if (message.type.oneofKind === "duration")
            exports.DurationRules.internalBinaryWrite(message.type.duration, writer.tag(21, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* buf.validate.TimestampRules timestamp = 22; */
        if (message.type.oneofKind === "timestamp")
            exports.TimestampRules.internalBinaryWrite(message.type.timestamp, writer.tag(22, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.FieldConstraints
 */
exports.FieldConstraints = new FieldConstraints$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FloatRules$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.FloatRules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/, options: { "buf.validate.priv.field": { cel: [{ id: "float.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "less_than", T: 2 /*ScalarType.FLOAT*/, options: { "buf.validate.priv.field": { cel: [{ id: "float.lt", expression: "!has(rules.gte) && !has(rules.gt) && (this.isNan() || this >= rules.lt)? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "less_than", T: 2 /*ScalarType.FLOAT*/, options: { "buf.validate.priv.field": { cel: [{ id: "float.lte", expression: "!has(rules.gte) && !has(rules.gt) && (this.isNan() || this > rules.lte)? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greater_than", T: 2 /*ScalarType.FLOAT*/, options: { "buf.validate.priv.field": { cel: [{ id: "float.gt", expression: "!has(rules.lt) && !has(rules.lte) && (this.isNan() || this <= rules.gt)? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "float.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this.isNan() || this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "float.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (this.isNan() || (rules.lt <= this && this <= rules.gt))? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "float.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this.isNan() || this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "float.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (this.isNan() || (rules.lte < this && this <= rules.gt))? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greater_than", T: 2 /*ScalarType.FLOAT*/, options: { "buf.validate.priv.field": { cel: [{ id: "float.gte", expression: "!has(rules.lt) && !has(rules.lte) && (this.isNan() || this < rules.gte)? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "float.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this.isNan() || this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "float.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (this.isNan() || (rules.lt <= this && this < rules.gte))? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "float.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this.isNan() || this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "float.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (this.isNan() || (rules.lte < this && this < rules.gte))? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/, options: { "buf.validate.priv.field": { cel: [{ id: "float.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/, options: { "buf.validate.priv.field": { cel: [{ id: "float.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } },
            { no: 8, name: "finite", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "float.finite", expression: "this.isNan() || this.isInf() ? 'value must be finite' : ''" }] } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.less_than = { oneofKind: undefined };
        message.greater_than = { oneofKind: undefined };
        message.in = [];
        message.not_in = [];
        message.finite = false;
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float const */ 1:
                    message.const = reader.float();
                    break;
                case /* float lt */ 2:
                    message.less_than = {
                        oneofKind: "lt",
                        lt: reader.float()
                    };
                    break;
                case /* float lte */ 3:
                    message.less_than = {
                        oneofKind: "lte",
                        lte: reader.float()
                    };
                    break;
                case /* float gt */ 4:
                    message.greater_than = {
                        oneofKind: "gt",
                        gt: reader.float()
                    };
                    break;
                case /* float gte */ 5:
                    message.greater_than = {
                        oneofKind: "gte",
                        gte: reader.float()
                    };
                    break;
                case /* repeated float in */ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.float());
                    else
                        message.in.push(reader.float());
                    break;
                case /* repeated float not_in */ 7:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.float());
                    else
                        message.not_in.push(reader.float());
                    break;
                case /* bool finite */ 8:
                    message.finite = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional float const = 1; */
        if (message.const !== undefined)
            writer.tag(1, runtime_1.WireType.Bit32).float(message.const);
        /* float lt = 2; */
        if (message.less_than.oneofKind === "lt")
            writer.tag(2, runtime_1.WireType.Bit32).float(message.less_than.lt);
        /* float lte = 3; */
        if (message.less_than.oneofKind === "lte")
            writer.tag(3, runtime_1.WireType.Bit32).float(message.less_than.lte);
        /* float gt = 4; */
        if (message.greater_than.oneofKind === "gt")
            writer.tag(4, runtime_1.WireType.Bit32).float(message.greater_than.gt);
        /* float gte = 5; */
        if (message.greater_than.oneofKind === "gte")
            writer.tag(5, runtime_1.WireType.Bit32).float(message.greater_than.gte);
        /* repeated float in = 6; */
        if (message.in.length) {
            writer.tag(6, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.float(message.in[i]);
            writer.join();
        }
        /* repeated float not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.float(message.not_in[i]);
            writer.join();
        }
        /* bool finite = 8; */
        if (message.finite !== false)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.finite);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.FloatRules
 */
exports.FloatRules = new FloatRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DoubleRules$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.DoubleRules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.priv.field": { cel: [{ id: "double.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "less_than", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.priv.field": { cel: [{ id: "double.lt", expression: "!has(rules.gte) && !has(rules.gt) && (this.isNan() || this >= rules.lt)? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "less_than", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.priv.field": { cel: [{ id: "double.lte", expression: "!has(rules.gte) && !has(rules.gt) && (this.isNan() || this > rules.lte)? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greater_than", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.priv.field": { cel: [{ id: "double.gt", expression: "!has(rules.lt) && !has(rules.lte) && (this.isNan() || this <= rules.gt)? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "double.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this.isNan() || this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "double.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (this.isNan() || (rules.lt <= this && this <= rules.gt))? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "double.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this.isNan() || this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "double.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (this.isNan() || (rules.lte < this && this <= rules.gt))? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greater_than", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.priv.field": { cel: [{ id: "double.gte", expression: "!has(rules.lt) && !has(rules.lte) && (this.isNan() || this < rules.gte)? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "double.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this.isNan() || this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "double.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (this.isNan() || (rules.lt <= this && this < rules.gte))? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "double.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this.isNan() || this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "double.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (this.isNan() || (rules.lte < this && this < rules.gte))? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.priv.field": { cel: [{ id: "double.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.priv.field": { cel: [{ id: "double.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } },
            { no: 8, name: "finite", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "double.finite", expression: "this.isNan() || this.isInf() ? 'value must be finite' : ''" }] } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.less_than = { oneofKind: undefined };
        message.greater_than = { oneofKind: undefined };
        message.in = [];
        message.not_in = [];
        message.finite = false;
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double const */ 1:
                    message.const = reader.double();
                    break;
                case /* double lt */ 2:
                    message.less_than = {
                        oneofKind: "lt",
                        lt: reader.double()
                    };
                    break;
                case /* double lte */ 3:
                    message.less_than = {
                        oneofKind: "lte",
                        lte: reader.double()
                    };
                    break;
                case /* double gt */ 4:
                    message.greater_than = {
                        oneofKind: "gt",
                        gt: reader.double()
                    };
                    break;
                case /* double gte */ 5:
                    message.greater_than = {
                        oneofKind: "gte",
                        gte: reader.double()
                    };
                    break;
                case /* repeated double in */ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.double());
                    else
                        message.in.push(reader.double());
                    break;
                case /* repeated double not_in */ 7:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.double());
                    else
                        message.not_in.push(reader.double());
                    break;
                case /* bool finite */ 8:
                    message.finite = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional double const = 1; */
        if (message.const !== undefined)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.const);
        /* double lt = 2; */
        if (message.less_than.oneofKind === "lt")
            writer.tag(2, runtime_1.WireType.Bit64).double(message.less_than.lt);
        /* double lte = 3; */
        if (message.less_than.oneofKind === "lte")
            writer.tag(3, runtime_1.WireType.Bit64).double(message.less_than.lte);
        /* double gt = 4; */
        if (message.greater_than.oneofKind === "gt")
            writer.tag(4, runtime_1.WireType.Bit64).double(message.greater_than.gt);
        /* double gte = 5; */
        if (message.greater_than.oneofKind === "gte")
            writer.tag(5, runtime_1.WireType.Bit64).double(message.greater_than.gte);
        /* repeated double in = 6; */
        if (message.in.length) {
            writer.tag(6, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.double(message.in[i]);
            writer.join();
        }
        /* repeated double not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.double(message.not_in[i]);
            writer.join();
        }
        /* bool finite = 8; */
        if (message.finite !== false)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.finite);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.DoubleRules
 */
exports.DoubleRules = new DoubleRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Int32Rules$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.Int32Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "int32.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "less_than", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "int32.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "less_than", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "int32.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greater_than", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "int32.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "int32.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "int32.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "int32.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "int32.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greater_than", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "int32.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "int32.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "int32.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "int32.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "int32.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "int32.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "int32.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.less_than = { oneofKind: undefined };
        message.greater_than = { oneofKind: undefined };
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 const */ 1:
                    message.const = reader.int32();
                    break;
                case /* int32 lt */ 2:
                    message.less_than = {
                        oneofKind: "lt",
                        lt: reader.int32()
                    };
                    break;
                case /* int32 lte */ 3:
                    message.less_than = {
                        oneofKind: "lte",
                        lte: reader.int32()
                    };
                    break;
                case /* int32 gt */ 4:
                    message.greater_than = {
                        oneofKind: "gt",
                        gt: reader.int32()
                    };
                    break;
                case /* int32 gte */ 5:
                    message.greater_than = {
                        oneofKind: "gte",
                        gte: reader.int32()
                    };
                    break;
                case /* repeated int32 in */ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.int32());
                    else
                        message.in.push(reader.int32());
                    break;
                case /* repeated int32 not_in */ 7:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.int32());
                    else
                        message.not_in.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional int32 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.const);
        /* int32 lt = 2; */
        if (message.less_than.oneofKind === "lt")
            writer.tag(2, runtime_1.WireType.Varint).int32(message.less_than.lt);
        /* int32 lte = 3; */
        if (message.less_than.oneofKind === "lte")
            writer.tag(3, runtime_1.WireType.Varint).int32(message.less_than.lte);
        /* int32 gt = 4; */
        if (message.greater_than.oneofKind === "gt")
            writer.tag(4, runtime_1.WireType.Varint).int32(message.greater_than.gt);
        /* int32 gte = 5; */
        if (message.greater_than.oneofKind === "gte")
            writer.tag(5, runtime_1.WireType.Varint).int32(message.greater_than.gte);
        /* repeated int32 in = 6; */
        if (message.in.length) {
            writer.tag(6, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.int32(message.in[i]);
            writer.join();
        }
        /* repeated int32 not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.int32(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.Int32Rules
 */
exports.Int32Rules = new Int32Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Int64Rules$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.Int64Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "int64.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "less_than", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "int64.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "less_than", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "int64.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greater_than", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "int64.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "int64.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "int64.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "int64.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "int64.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greater_than", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "int64.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "int64.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "int64.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "int64.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "int64.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "int64.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "int64.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.less_than = { oneofKind: undefined };
        message.greater_than = { oneofKind: undefined };
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 const */ 1:
                    message.const = reader.int64().toBigInt();
                    break;
                case /* int64 lt */ 2:
                    message.less_than = {
                        oneofKind: "lt",
                        lt: reader.int64().toBigInt()
                    };
                    break;
                case /* int64 lte */ 3:
                    message.less_than = {
                        oneofKind: "lte",
                        lte: reader.int64().toBigInt()
                    };
                    break;
                case /* int64 gt */ 4:
                    message.greater_than = {
                        oneofKind: "gt",
                        gt: reader.int64().toBigInt()
                    };
                    break;
                case /* int64 gte */ 5:
                    message.greater_than = {
                        oneofKind: "gte",
                        gte: reader.int64().toBigInt()
                    };
                    break;
                case /* repeated int64 in */ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.int64().toBigInt());
                    else
                        message.in.push(reader.int64().toBigInt());
                    break;
                case /* repeated int64 not_in */ 7:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.int64().toBigInt());
                    else
                        message.not_in.push(reader.int64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional int64 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int64(message.const);
        /* int64 lt = 2; */
        if (message.less_than.oneofKind === "lt")
            writer.tag(2, runtime_1.WireType.Varint).int64(message.less_than.lt);
        /* int64 lte = 3; */
        if (message.less_than.oneofKind === "lte")
            writer.tag(3, runtime_1.WireType.Varint).int64(message.less_than.lte);
        /* int64 gt = 4; */
        if (message.greater_than.oneofKind === "gt")
            writer.tag(4, runtime_1.WireType.Varint).int64(message.greater_than.gt);
        /* int64 gte = 5; */
        if (message.greater_than.oneofKind === "gte")
            writer.tag(5, runtime_1.WireType.Varint).int64(message.greater_than.gte);
        /* repeated int64 in = 6; */
        if (message.in.length) {
            writer.tag(6, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.int64(message.in[i]);
            writer.join();
        }
        /* repeated int64 not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.int64(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.Int64Rules
 */
exports.Int64Rules = new Int64Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UInt32Rules$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.UInt32Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "uint32.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "less_than", T: 13 /*ScalarType.UINT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "uint32.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "less_than", T: 13 /*ScalarType.UINT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "uint32.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greater_than", T: 13 /*ScalarType.UINT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "uint32.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "uint32.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "uint32.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "uint32.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "uint32.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greater_than", T: 13 /*ScalarType.UINT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "uint32.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "uint32.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "uint32.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "uint32.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "uint32.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "uint32.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "uint32.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.less_than = { oneofKind: undefined };
        message.greater_than = { oneofKind: undefined };
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 const */ 1:
                    message.const = reader.uint32();
                    break;
                case /* uint32 lt */ 2:
                    message.less_than = {
                        oneofKind: "lt",
                        lt: reader.uint32()
                    };
                    break;
                case /* uint32 lte */ 3:
                    message.less_than = {
                        oneofKind: "lte",
                        lte: reader.uint32()
                    };
                    break;
                case /* uint32 gt */ 4:
                    message.greater_than = {
                        oneofKind: "gt",
                        gt: reader.uint32()
                    };
                    break;
                case /* uint32 gte */ 5:
                    message.greater_than = {
                        oneofKind: "gte",
                        gte: reader.uint32()
                    };
                    break;
                case /* repeated uint32 in */ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.uint32());
                    else
                        message.in.push(reader.uint32());
                    break;
                case /* repeated uint32 not_in */ 7:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.uint32());
                    else
                        message.not_in.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional uint32 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.const);
        /* uint32 lt = 2; */
        if (message.less_than.oneofKind === "lt")
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.less_than.lt);
        /* uint32 lte = 3; */
        if (message.less_than.oneofKind === "lte")
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.less_than.lte);
        /* uint32 gt = 4; */
        if (message.greater_than.oneofKind === "gt")
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.greater_than.gt);
        /* uint32 gte = 5; */
        if (message.greater_than.oneofKind === "gte")
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.greater_than.gte);
        /* repeated uint32 in = 6; */
        if (message.in.length) {
            writer.tag(6, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.uint32(message.in[i]);
            writer.join();
        }
        /* repeated uint32 not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.uint32(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.UInt32Rules
 */
exports.UInt32Rules = new UInt32Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UInt64Rules$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.UInt64Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "uint64.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "less_than", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "uint64.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "less_than", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "uint64.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greater_than", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "uint64.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "uint64.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "uint64.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "uint64.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "uint64.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greater_than", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "uint64.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "uint64.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "uint64.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "uint64.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "uint64.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "uint64.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "uint64.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.less_than = { oneofKind: undefined };
        message.greater_than = { oneofKind: undefined };
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 const */ 1:
                    message.const = reader.uint64().toBigInt();
                    break;
                case /* uint64 lt */ 2:
                    message.less_than = {
                        oneofKind: "lt",
                        lt: reader.uint64().toBigInt()
                    };
                    break;
                case /* uint64 lte */ 3:
                    message.less_than = {
                        oneofKind: "lte",
                        lte: reader.uint64().toBigInt()
                    };
                    break;
                case /* uint64 gt */ 4:
                    message.greater_than = {
                        oneofKind: "gt",
                        gt: reader.uint64().toBigInt()
                    };
                    break;
                case /* uint64 gte */ 5:
                    message.greater_than = {
                        oneofKind: "gte",
                        gte: reader.uint64().toBigInt()
                    };
                    break;
                case /* repeated uint64 in */ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.uint64().toBigInt());
                    else
                        message.in.push(reader.uint64().toBigInt());
                    break;
                case /* repeated uint64 not_in */ 7:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.uint64().toBigInt());
                    else
                        message.not_in.push(reader.uint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional uint64 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.const);
        /* uint64 lt = 2; */
        if (message.less_than.oneofKind === "lt")
            writer.tag(2, runtime_1.WireType.Varint).uint64(message.less_than.lt);
        /* uint64 lte = 3; */
        if (message.less_than.oneofKind === "lte")
            writer.tag(3, runtime_1.WireType.Varint).uint64(message.less_than.lte);
        /* uint64 gt = 4; */
        if (message.greater_than.oneofKind === "gt")
            writer.tag(4, runtime_1.WireType.Varint).uint64(message.greater_than.gt);
        /* uint64 gte = 5; */
        if (message.greater_than.oneofKind === "gte")
            writer.tag(5, runtime_1.WireType.Varint).uint64(message.greater_than.gte);
        /* repeated uint64 in = 6; */
        if (message.in.length) {
            writer.tag(6, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.uint64(message.in[i]);
            writer.join();
        }
        /* repeated uint64 not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.uint64(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.UInt64Rules
 */
exports.UInt64Rules = new UInt64Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SInt32Rules$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.SInt32Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "sint32.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "less_than", T: 17 /*ScalarType.SINT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "sint32.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "less_than", T: 17 /*ScalarType.SINT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "sint32.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greater_than", T: 17 /*ScalarType.SINT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "sint32.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "sint32.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "sint32.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "sint32.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "sint32.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greater_than", T: 17 /*ScalarType.SINT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "sint32.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "sint32.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "sint32.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "sint32.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "sint32.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 17 /*ScalarType.SINT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "sint32.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 17 /*ScalarType.SINT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "sint32.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.less_than = { oneofKind: undefined };
        message.greater_than = { oneofKind: undefined };
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional sint32 const */ 1:
                    message.const = reader.sint32();
                    break;
                case /* sint32 lt */ 2:
                    message.less_than = {
                        oneofKind: "lt",
                        lt: reader.sint32()
                    };
                    break;
                case /* sint32 lte */ 3:
                    message.less_than = {
                        oneofKind: "lte",
                        lte: reader.sint32()
                    };
                    break;
                case /* sint32 gt */ 4:
                    message.greater_than = {
                        oneofKind: "gt",
                        gt: reader.sint32()
                    };
                    break;
                case /* sint32 gte */ 5:
                    message.greater_than = {
                        oneofKind: "gte",
                        gte: reader.sint32()
                    };
                    break;
                case /* repeated sint32 in */ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.sint32());
                    else
                        message.in.push(reader.sint32());
                    break;
                case /* repeated sint32 not_in */ 7:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.sint32());
                    else
                        message.not_in.push(reader.sint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional sint32 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).sint32(message.const);
        /* sint32 lt = 2; */
        if (message.less_than.oneofKind === "lt")
            writer.tag(2, runtime_1.WireType.Varint).sint32(message.less_than.lt);
        /* sint32 lte = 3; */
        if (message.less_than.oneofKind === "lte")
            writer.tag(3, runtime_1.WireType.Varint).sint32(message.less_than.lte);
        /* sint32 gt = 4; */
        if (message.greater_than.oneofKind === "gt")
            writer.tag(4, runtime_1.WireType.Varint).sint32(message.greater_than.gt);
        /* sint32 gte = 5; */
        if (message.greater_than.oneofKind === "gte")
            writer.tag(5, runtime_1.WireType.Varint).sint32(message.greater_than.gte);
        /* repeated sint32 in = 6; */
        if (message.in.length) {
            writer.tag(6, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.sint32(message.in[i]);
            writer.join();
        }
        /* repeated sint32 not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.sint32(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.SInt32Rules
 */
exports.SInt32Rules = new SInt32Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SInt64Rules$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.SInt64Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "sint64.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "less_than", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "sint64.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "less_than", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "sint64.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greater_than", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "sint64.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "sint64.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "sint64.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "sint64.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "sint64.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greater_than", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "sint64.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "sint64.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "sint64.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "sint64.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "sint64.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "sint64.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "sint64.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.less_than = { oneofKind: undefined };
        message.greater_than = { oneofKind: undefined };
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional sint64 const */ 1:
                    message.const = reader.sint64().toBigInt();
                    break;
                case /* sint64 lt */ 2:
                    message.less_than = {
                        oneofKind: "lt",
                        lt: reader.sint64().toBigInt()
                    };
                    break;
                case /* sint64 lte */ 3:
                    message.less_than = {
                        oneofKind: "lte",
                        lte: reader.sint64().toBigInt()
                    };
                    break;
                case /* sint64 gt */ 4:
                    message.greater_than = {
                        oneofKind: "gt",
                        gt: reader.sint64().toBigInt()
                    };
                    break;
                case /* sint64 gte */ 5:
                    message.greater_than = {
                        oneofKind: "gte",
                        gte: reader.sint64().toBigInt()
                    };
                    break;
                case /* repeated sint64 in */ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.sint64().toBigInt());
                    else
                        message.in.push(reader.sint64().toBigInt());
                    break;
                case /* repeated sint64 not_in */ 7:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.sint64().toBigInt());
                    else
                        message.not_in.push(reader.sint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional sint64 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).sint64(message.const);
        /* sint64 lt = 2; */
        if (message.less_than.oneofKind === "lt")
            writer.tag(2, runtime_1.WireType.Varint).sint64(message.less_than.lt);
        /* sint64 lte = 3; */
        if (message.less_than.oneofKind === "lte")
            writer.tag(3, runtime_1.WireType.Varint).sint64(message.less_than.lte);
        /* sint64 gt = 4; */
        if (message.greater_than.oneofKind === "gt")
            writer.tag(4, runtime_1.WireType.Varint).sint64(message.greater_than.gt);
        /* sint64 gte = 5; */
        if (message.greater_than.oneofKind === "gte")
            writer.tag(5, runtime_1.WireType.Varint).sint64(message.greater_than.gte);
        /* repeated sint64 in = 6; */
        if (message.in.length) {
            writer.tag(6, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.sint64(message.in[i]);
            writer.join();
        }
        /* repeated sint64 not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.sint64(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.SInt64Rules
 */
exports.SInt64Rules = new SInt64Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Fixed32Rules$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.Fixed32Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/, options: { "buf.validate.priv.field": { cel: [{ id: "fixed32.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "less_than", T: 7 /*ScalarType.FIXED32*/, options: { "buf.validate.priv.field": { cel: [{ id: "fixed32.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "less_than", T: 7 /*ScalarType.FIXED32*/, options: { "buf.validate.priv.field": { cel: [{ id: "fixed32.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greater_than", T: 7 /*ScalarType.FIXED32*/, options: { "buf.validate.priv.field": { cel: [{ id: "fixed32.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "fixed32.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "fixed32.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "fixed32.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "fixed32.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greater_than", T: 7 /*ScalarType.FIXED32*/, options: { "buf.validate.priv.field": { cel: [{ id: "fixed32.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "fixed32.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "fixed32.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "fixed32.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "fixed32.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 7 /*ScalarType.FIXED32*/, options: { "buf.validate.priv.field": { cel: [{ id: "fixed32.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 7 /*ScalarType.FIXED32*/, options: { "buf.validate.priv.field": { cel: [{ id: "fixed32.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.less_than = { oneofKind: undefined };
        message.greater_than = { oneofKind: undefined };
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 const */ 1:
                    message.const = reader.fixed32();
                    break;
                case /* fixed32 lt */ 2:
                    message.less_than = {
                        oneofKind: "lt",
                        lt: reader.fixed32()
                    };
                    break;
                case /* fixed32 lte */ 3:
                    message.less_than = {
                        oneofKind: "lte",
                        lte: reader.fixed32()
                    };
                    break;
                case /* fixed32 gt */ 4:
                    message.greater_than = {
                        oneofKind: "gt",
                        gt: reader.fixed32()
                    };
                    break;
                case /* fixed32 gte */ 5:
                    message.greater_than = {
                        oneofKind: "gte",
                        gte: reader.fixed32()
                    };
                    break;
                case /* repeated fixed32 in */ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.fixed32());
                    else
                        message.in.push(reader.fixed32());
                    break;
                case /* repeated fixed32 not_in */ 7:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.fixed32());
                    else
                        message.not_in.push(reader.fixed32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional fixed32 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.const);
        /* fixed32 lt = 2; */
        if (message.less_than.oneofKind === "lt")
            writer.tag(2, runtime_1.WireType.Bit32).fixed32(message.less_than.lt);
        /* fixed32 lte = 3; */
        if (message.less_than.oneofKind === "lte")
            writer.tag(3, runtime_1.WireType.Bit32).fixed32(message.less_than.lte);
        /* fixed32 gt = 4; */
        if (message.greater_than.oneofKind === "gt")
            writer.tag(4, runtime_1.WireType.Bit32).fixed32(message.greater_than.gt);
        /* fixed32 gte = 5; */
        if (message.greater_than.oneofKind === "gte")
            writer.tag(5, runtime_1.WireType.Bit32).fixed32(message.greater_than.gte);
        /* repeated fixed32 in = 6; */
        if (message.in.length) {
            writer.tag(6, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.fixed32(message.in[i]);
            writer.join();
        }
        /* repeated fixed32 not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.fixed32(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.Fixed32Rules
 */
exports.Fixed32Rules = new Fixed32Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Fixed64Rules$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.Fixed64Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "fixed64.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "less_than", T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "fixed64.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "less_than", T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "fixed64.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greater_than", T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "fixed64.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "fixed64.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "fixed64.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "fixed64.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "fixed64.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greater_than", T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "fixed64.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "fixed64.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "fixed64.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "fixed64.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "fixed64.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "fixed64.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "fixed64.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.less_than = { oneofKind: undefined };
        message.greater_than = { oneofKind: undefined };
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 const */ 1:
                    message.const = reader.fixed64().toBigInt();
                    break;
                case /* fixed64 lt */ 2:
                    message.less_than = {
                        oneofKind: "lt",
                        lt: reader.fixed64().toBigInt()
                    };
                    break;
                case /* fixed64 lte */ 3:
                    message.less_than = {
                        oneofKind: "lte",
                        lte: reader.fixed64().toBigInt()
                    };
                    break;
                case /* fixed64 gt */ 4:
                    message.greater_than = {
                        oneofKind: "gt",
                        gt: reader.fixed64().toBigInt()
                    };
                    break;
                case /* fixed64 gte */ 5:
                    message.greater_than = {
                        oneofKind: "gte",
                        gte: reader.fixed64().toBigInt()
                    };
                    break;
                case /* repeated fixed64 in */ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.fixed64().toBigInt());
                    else
                        message.in.push(reader.fixed64().toBigInt());
                    break;
                case /* repeated fixed64 not_in */ 7:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.fixed64().toBigInt());
                    else
                        message.not_in.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional fixed64 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, runtime_1.WireType.Bit64).fixed64(message.const);
        /* fixed64 lt = 2; */
        if (message.less_than.oneofKind === "lt")
            writer.tag(2, runtime_1.WireType.Bit64).fixed64(message.less_than.lt);
        /* fixed64 lte = 3; */
        if (message.less_than.oneofKind === "lte")
            writer.tag(3, runtime_1.WireType.Bit64).fixed64(message.less_than.lte);
        /* fixed64 gt = 4; */
        if (message.greater_than.oneofKind === "gt")
            writer.tag(4, runtime_1.WireType.Bit64).fixed64(message.greater_than.gt);
        /* fixed64 gte = 5; */
        if (message.greater_than.oneofKind === "gte")
            writer.tag(5, runtime_1.WireType.Bit64).fixed64(message.greater_than.gte);
        /* repeated fixed64 in = 6; */
        if (message.in.length) {
            writer.tag(6, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.fixed64(message.in[i]);
            writer.join();
        }
        /* repeated fixed64 not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.fixed64(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.Fixed64Rules
 */
exports.Fixed64Rules = new Fixed64Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SFixed32Rules$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.SFixed32Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 15 /*ScalarType.SFIXED32*/, options: { "buf.validate.priv.field": { cel: [{ id: "sfixed32.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "less_than", T: 15 /*ScalarType.SFIXED32*/, options: { "buf.validate.priv.field": { cel: [{ id: "sfixed32.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "less_than", T: 15 /*ScalarType.SFIXED32*/, options: { "buf.validate.priv.field": { cel: [{ id: "sfixed32.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greater_than", T: 15 /*ScalarType.SFIXED32*/, options: { "buf.validate.priv.field": { cel: [{ id: "sfixed32.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "sfixed32.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "sfixed32.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "sfixed32.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "sfixed32.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greater_than", T: 15 /*ScalarType.SFIXED32*/, options: { "buf.validate.priv.field": { cel: [{ id: "sfixed32.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "sfixed32.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "sfixed32.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "sfixed32.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "sfixed32.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 15 /*ScalarType.SFIXED32*/, options: { "buf.validate.priv.field": { cel: [{ id: "sfixed32.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 15 /*ScalarType.SFIXED32*/, options: { "buf.validate.priv.field": { cel: [{ id: "sfixed32.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.less_than = { oneofKind: undefined };
        message.greater_than = { oneofKind: undefined };
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional sfixed32 const */ 1:
                    message.const = reader.sfixed32();
                    break;
                case /* sfixed32 lt */ 2:
                    message.less_than = {
                        oneofKind: "lt",
                        lt: reader.sfixed32()
                    };
                    break;
                case /* sfixed32 lte */ 3:
                    message.less_than = {
                        oneofKind: "lte",
                        lte: reader.sfixed32()
                    };
                    break;
                case /* sfixed32 gt */ 4:
                    message.greater_than = {
                        oneofKind: "gt",
                        gt: reader.sfixed32()
                    };
                    break;
                case /* sfixed32 gte */ 5:
                    message.greater_than = {
                        oneofKind: "gte",
                        gte: reader.sfixed32()
                    };
                    break;
                case /* repeated sfixed32 in */ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.sfixed32());
                    else
                        message.in.push(reader.sfixed32());
                    break;
                case /* repeated sfixed32 not_in */ 7:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.sfixed32());
                    else
                        message.not_in.push(reader.sfixed32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional sfixed32 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, runtime_1.WireType.Bit32).sfixed32(message.const);
        /* sfixed32 lt = 2; */
        if (message.less_than.oneofKind === "lt")
            writer.tag(2, runtime_1.WireType.Bit32).sfixed32(message.less_than.lt);
        /* sfixed32 lte = 3; */
        if (message.less_than.oneofKind === "lte")
            writer.tag(3, runtime_1.WireType.Bit32).sfixed32(message.less_than.lte);
        /* sfixed32 gt = 4; */
        if (message.greater_than.oneofKind === "gt")
            writer.tag(4, runtime_1.WireType.Bit32).sfixed32(message.greater_than.gt);
        /* sfixed32 gte = 5; */
        if (message.greater_than.oneofKind === "gte")
            writer.tag(5, runtime_1.WireType.Bit32).sfixed32(message.greater_than.gte);
        /* repeated sfixed32 in = 6; */
        if (message.in.length) {
            writer.tag(6, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.sfixed32(message.in[i]);
            writer.join();
        }
        /* repeated sfixed32 not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.sfixed32(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.SFixed32Rules
 */
exports.SFixed32Rules = new SFixed32Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SFixed64Rules$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.SFixed64Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 16 /*ScalarType.SFIXED64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "sfixed64.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "lt", kind: "scalar", oneof: "less_than", T: 16 /*ScalarType.SFIXED64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "sfixed64.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 3, name: "lte", kind: "scalar", oneof: "less_than", T: 16 /*ScalarType.SFIXED64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "sfixed64.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 4, name: "gt", kind: "scalar", oneof: "greater_than", T: 16 /*ScalarType.SFIXED64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "sfixed64.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "sfixed64.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "sfixed64.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "sfixed64.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "sfixed64.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 5, name: "gte", kind: "scalar", oneof: "greater_than", T: 16 /*ScalarType.SFIXED64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "sfixed64.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "sfixed64.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "sfixed64.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "sfixed64.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "sfixed64.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 16 /*ScalarType.SFIXED64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "sfixed64.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 16 /*ScalarType.SFIXED64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "sfixed64.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.less_than = { oneofKind: undefined };
        message.greater_than = { oneofKind: undefined };
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional sfixed64 const */ 1:
                    message.const = reader.sfixed64().toBigInt();
                    break;
                case /* sfixed64 lt */ 2:
                    message.less_than = {
                        oneofKind: "lt",
                        lt: reader.sfixed64().toBigInt()
                    };
                    break;
                case /* sfixed64 lte */ 3:
                    message.less_than = {
                        oneofKind: "lte",
                        lte: reader.sfixed64().toBigInt()
                    };
                    break;
                case /* sfixed64 gt */ 4:
                    message.greater_than = {
                        oneofKind: "gt",
                        gt: reader.sfixed64().toBigInt()
                    };
                    break;
                case /* sfixed64 gte */ 5:
                    message.greater_than = {
                        oneofKind: "gte",
                        gte: reader.sfixed64().toBigInt()
                    };
                    break;
                case /* repeated sfixed64 in */ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.sfixed64().toBigInt());
                    else
                        message.in.push(reader.sfixed64().toBigInt());
                    break;
                case /* repeated sfixed64 not_in */ 7:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.sfixed64().toBigInt());
                    else
                        message.not_in.push(reader.sfixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional sfixed64 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, runtime_1.WireType.Bit64).sfixed64(message.const);
        /* sfixed64 lt = 2; */
        if (message.less_than.oneofKind === "lt")
            writer.tag(2, runtime_1.WireType.Bit64).sfixed64(message.less_than.lt);
        /* sfixed64 lte = 3; */
        if (message.less_than.oneofKind === "lte")
            writer.tag(3, runtime_1.WireType.Bit64).sfixed64(message.less_than.lte);
        /* sfixed64 gt = 4; */
        if (message.greater_than.oneofKind === "gt")
            writer.tag(4, runtime_1.WireType.Bit64).sfixed64(message.greater_than.gt);
        /* sfixed64 gte = 5; */
        if (message.greater_than.oneofKind === "gte")
            writer.tag(5, runtime_1.WireType.Bit64).sfixed64(message.greater_than.gte);
        /* repeated sfixed64 in = 6; */
        if (message.in.length) {
            writer.tag(6, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.sfixed64(message.in[i]);
            writer.join();
        }
        /* repeated sfixed64 not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.sfixed64(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.SFixed64Rules
 */
exports.SFixed64Rules = new SFixed64Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BoolRules$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.BoolRules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "bool.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool const */ 1:
                    message.const = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional bool const = 1; */
        if (message.const !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.const);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.BoolRules
 */
exports.BoolRules = new BoolRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StringRules$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.StringRules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.const", expression: "this != rules.const ? 'value must equal `%s`'.format([rules.const]) : ''" }] } } },
            { no: 19, name: "len", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.len", expression: "uint(this.size()) != rules.len ? 'value length must be %s characters'.format([rules.len]) : ''" }] } } },
            { no: 2, name: "min_len", kind: "scalar", localName: "min_len", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.min_len", expression: "uint(this.size()) < rules.min_len ? 'value length must be at least %s characters'.format([rules.min_len]) : ''" }] } } },
            { no: 3, name: "max_len", kind: "scalar", localName: "max_len", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.max_len", expression: "uint(this.size()) > rules.max_len ? 'value length must be at most %s characters'.format([rules.max_len]) : ''" }] } } },
            { no: 20, name: "len_bytes", kind: "scalar", localName: "len_bytes", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.len_bytes", expression: "uint(bytes(this).size()) != rules.len_bytes ? 'value length must be %s bytes'.format([rules.len_bytes]) : ''" }] } } },
            { no: 4, name: "min_bytes", kind: "scalar", localName: "min_bytes", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.min_bytes", expression: "uint(bytes(this).size()) < rules.min_bytes ? 'value length must be at least %s bytes'.format([rules.min_bytes]) : ''" }] } } },
            { no: 5, name: "max_bytes", kind: "scalar", localName: "max_bytes", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.max_bytes", expression: "uint(bytes(this).size()) > rules.max_bytes ? 'value length must be at most %s bytes'.format([rules.max_bytes]) : ''" }] } } },
            { no: 6, name: "pattern", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.pattern", expression: "!this.matches(rules.pattern) ? 'value does not match regex pattern `%s`'.format([rules.pattern]) : ''" }] } } },
            { no: 7, name: "prefix", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.prefix", expression: "!this.startsWith(rules.prefix) ? 'value does not have prefix `%s`'.format([rules.prefix]) : ''" }] } } },
            { no: 8, name: "suffix", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.suffix", expression: "!this.endsWith(rules.suffix) ? 'value does not have suffix `%s`'.format([rules.suffix]) : ''" }] } } },
            { no: 9, name: "contains", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.contains", expression: "!this.contains(rules.contains) ? 'value does not contain substring `%s`'.format([rules.contains]) : ''" }] } } },
            { no: 23, name: "not_contains", kind: "scalar", localName: "not_contains", opt: true, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.not_contains", expression: "this.contains(rules.not_contains) ? 'value contains substring `%s`'.format([rules.not_contains]) : ''" }] } } },
            { no: 10, name: "in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 11, name: "not_in", kind: "scalar", localName: "not_in", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } },
            { no: 12, name: "email", kind: "scalar", oneof: "well_known", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.email", message: "value must be a valid email address", expression: "this.isEmail()" }] } } },
            { no: 13, name: "hostname", kind: "scalar", oneof: "well_known", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.hostname", message: "value must be a valid hostname", expression: "this.isHostname()" }] } } },
            { no: 14, name: "ip", kind: "scalar", oneof: "well_known", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.ip", message: "value must be a valid IP address", expression: "this.isIp()" }] } } },
            { no: 15, name: "ipv4", kind: "scalar", oneof: "well_known", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.ipv4", message: "value must be a valid IPv4 address", expression: "this.isIp(4)" }] } } },
            { no: 16, name: "ipv6", kind: "scalar", oneof: "well_known", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.ipv6", message: "value must be a valid IPv6 address", expression: "this.isIp(6)" }] } } },
            { no: 17, name: "uri", kind: "scalar", oneof: "well_known", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.uri", message: "value must be a valid URI", expression: "this.isUri()" }] } } },
            { no: 18, name: "uri_ref", kind: "scalar", localName: "uri_ref", oneof: "well_known", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.uri_ref", message: "value must be a valid URI", expression: "this.isUriRef()" }] } } },
            { no: 21, name: "address", kind: "scalar", oneof: "well_known", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.address", message: "value must be a valid hostname, or ip address", expression: "this.isHostname() || this.isIp()" }] } } },
            { no: 22, name: "uuid", kind: "scalar", oneof: "well_known", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.uuid", expression: "!this.matches('^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$') ? 'value must be a valid UUID' : ''" }] } } },
            { no: 26, name: "ip_with_prefixlen", kind: "scalar", localName: "ip_with_prefixlen", oneof: "well_known", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.ip_with_prefixlen", message: "value must be a valid IP prefix", expression: "this.isIpPrefix()" }] } } },
            { no: 27, name: "ipv4_with_prefixlen", kind: "scalar", localName: "ipv4_with_prefixlen", oneof: "well_known", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.ipv4_with_prefixlen", message: "value must be a valid IPv4 address with prefix length", expression: "this.isIpPrefix(4)" }] } } },
            { no: 28, name: "ipv6_with_prefixlen", kind: "scalar", localName: "ipv6_with_prefixlen", oneof: "well_known", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.ipv6_with_prefixlen", message: "value must be a valid IPv6 address with prefix length", expression: "this.isIpPrefix(6)" }] } } },
            { no: 29, name: "ip_prefix", kind: "scalar", localName: "ip_prefix", oneof: "well_known", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.ip_prefix", message: "value must be a valid IP prefix", expression: "this.isIpPrefix(true)" }] } } },
            { no: 30, name: "ipv4_prefix", kind: "scalar", localName: "ipv4_prefix", oneof: "well_known", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.ipv4_prefix", message: "value must be a valid IPv4 prefix", expression: "this.isIpPrefix(4, true)" }] } } },
            { no: 31, name: "ipv6_prefix", kind: "scalar", localName: "ipv6_prefix", oneof: "well_known", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "string.ipv6_prefix", message: "value must be a valid IPv6 prefix", expression: "this.isIpPrefix(6, true)" }] } } },
            { no: 24, name: "well_known_regex", kind: "enum", localName: "well_known_regex", oneof: "well_known", T: () => ["buf.validate.KnownRegex", KnownRegex], options: { "buf.validate.priv.field": { cel: [{ id: "string.well_known_regex.header_name", expression: "rules.well_known_regex == 1 && !this.matches(!has(rules.strict) || rules.strict ?'^:?[0-9a-zA-Z!#$%&\\'*+-.^_|~\\x60]+$' :'^[^\\u0000\\u000A\\u000D]+$') ? 'value must be a valid HTTP header name' : ''" }, { id: "string.well_known_regex.header_value", expression: "rules.well_known_regex == 2 && !this.matches(!has(rules.strict) || rules.strict ?'^[^\\u0000-\\u0008\\u000A-\\u001F\\u007F]*$' :'^[^\\u0000\\u000A\\u000D]*$') ? 'value must be a valid HTTP header value' : ''" }] } } },
            { no: 25, name: "strict", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.in = [];
        message.not_in = [];
        message.well_known = { oneofKind: undefined };
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string const */ 1:
                    message.const = reader.string();
                    break;
                case /* optional uint64 len */ 19:
                    message.len = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 min_len */ 2:
                    message.min_len = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 max_len */ 3:
                    message.max_len = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 len_bytes */ 20:
                    message.len_bytes = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 min_bytes */ 4:
                    message.min_bytes = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 max_bytes */ 5:
                    message.max_bytes = reader.uint64().toBigInt();
                    break;
                case /* optional string pattern */ 6:
                    message.pattern = reader.string();
                    break;
                case /* optional string prefix */ 7:
                    message.prefix = reader.string();
                    break;
                case /* optional string suffix */ 8:
                    message.suffix = reader.string();
                    break;
                case /* optional string contains */ 9:
                    message.contains = reader.string();
                    break;
                case /* optional string not_contains */ 23:
                    message.not_contains = reader.string();
                    break;
                case /* repeated string in */ 10:
                    message.in.push(reader.string());
                    break;
                case /* repeated string not_in */ 11:
                    message.not_in.push(reader.string());
                    break;
                case /* bool email */ 12:
                    message.well_known = {
                        oneofKind: "email",
                        email: reader.bool()
                    };
                    break;
                case /* bool hostname */ 13:
                    message.well_known = {
                        oneofKind: "hostname",
                        hostname: reader.bool()
                    };
                    break;
                case /* bool ip */ 14:
                    message.well_known = {
                        oneofKind: "ip",
                        ip: reader.bool()
                    };
                    break;
                case /* bool ipv4 */ 15:
                    message.well_known = {
                        oneofKind: "ipv4",
                        ipv4: reader.bool()
                    };
                    break;
                case /* bool ipv6 */ 16:
                    message.well_known = {
                        oneofKind: "ipv6",
                        ipv6: reader.bool()
                    };
                    break;
                case /* bool uri */ 17:
                    message.well_known = {
                        oneofKind: "uri",
                        uri: reader.bool()
                    };
                    break;
                case /* bool uri_ref */ 18:
                    message.well_known = {
                        oneofKind: "uri_ref",
                        uri_ref: reader.bool()
                    };
                    break;
                case /* bool address */ 21:
                    message.well_known = {
                        oneofKind: "address",
                        address: reader.bool()
                    };
                    break;
                case /* bool uuid */ 22:
                    message.well_known = {
                        oneofKind: "uuid",
                        uuid: reader.bool()
                    };
                    break;
                case /* bool ip_with_prefixlen */ 26:
                    message.well_known = {
                        oneofKind: "ip_with_prefixlen",
                        ip_with_prefixlen: reader.bool()
                    };
                    break;
                case /* bool ipv4_with_prefixlen */ 27:
                    message.well_known = {
                        oneofKind: "ipv4_with_prefixlen",
                        ipv4_with_prefixlen: reader.bool()
                    };
                    break;
                case /* bool ipv6_with_prefixlen */ 28:
                    message.well_known = {
                        oneofKind: "ipv6_with_prefixlen",
                        ipv6_with_prefixlen: reader.bool()
                    };
                    break;
                case /* bool ip_prefix */ 29:
                    message.well_known = {
                        oneofKind: "ip_prefix",
                        ip_prefix: reader.bool()
                    };
                    break;
                case /* bool ipv4_prefix */ 30:
                    message.well_known = {
                        oneofKind: "ipv4_prefix",
                        ipv4_prefix: reader.bool()
                    };
                    break;
                case /* bool ipv6_prefix */ 31:
                    message.well_known = {
                        oneofKind: "ipv6_prefix",
                        ipv6_prefix: reader.bool()
                    };
                    break;
                case /* buf.validate.KnownRegex well_known_regex */ 24:
                    message.well_known = {
                        oneofKind: "well_known_regex",
                        well_known_regex: reader.int32()
                    };
                    break;
                case /* optional bool strict */ 25:
                    message.strict = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string const = 1; */
        if (message.const !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.const);
        /* optional uint64 len = 19; */
        if (message.len !== undefined)
            writer.tag(19, runtime_1.WireType.Varint).uint64(message.len);
        /* optional uint64 min_len = 2; */
        if (message.min_len !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint64(message.min_len);
        /* optional uint64 max_len = 3; */
        if (message.max_len !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint64(message.max_len);
        /* optional uint64 len_bytes = 20; */
        if (message.len_bytes !== undefined)
            writer.tag(20, runtime_1.WireType.Varint).uint64(message.len_bytes);
        /* optional uint64 min_bytes = 4; */
        if (message.min_bytes !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint64(message.min_bytes);
        /* optional uint64 max_bytes = 5; */
        if (message.max_bytes !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).uint64(message.max_bytes);
        /* optional string pattern = 6; */
        if (message.pattern !== undefined)
            writer.tag(6, runtime_1.WireType.LengthDelimited).string(message.pattern);
        /* optional string prefix = 7; */
        if (message.prefix !== undefined)
            writer.tag(7, runtime_1.WireType.LengthDelimited).string(message.prefix);
        /* optional string suffix = 8; */
        if (message.suffix !== undefined)
            writer.tag(8, runtime_1.WireType.LengthDelimited).string(message.suffix);
        /* optional string contains = 9; */
        if (message.contains !== undefined)
            writer.tag(9, runtime_1.WireType.LengthDelimited).string(message.contains);
        /* optional string not_contains = 23; */
        if (message.not_contains !== undefined)
            writer.tag(23, runtime_1.WireType.LengthDelimited).string(message.not_contains);
        /* repeated string in = 10; */
        for (let i = 0; i < message.in.length; i++)
            writer.tag(10, runtime_1.WireType.LengthDelimited).string(message.in[i]);
        /* repeated string not_in = 11; */
        for (let i = 0; i < message.not_in.length; i++)
            writer.tag(11, runtime_1.WireType.LengthDelimited).string(message.not_in[i]);
        /* bool email = 12; */
        if (message.well_known.oneofKind === "email")
            writer.tag(12, runtime_1.WireType.Varint).bool(message.well_known.email);
        /* bool hostname = 13; */
        if (message.well_known.oneofKind === "hostname")
            writer.tag(13, runtime_1.WireType.Varint).bool(message.well_known.hostname);
        /* bool ip = 14; */
        if (message.well_known.oneofKind === "ip")
            writer.tag(14, runtime_1.WireType.Varint).bool(message.well_known.ip);
        /* bool ipv4 = 15; */
        if (message.well_known.oneofKind === "ipv4")
            writer.tag(15, runtime_1.WireType.Varint).bool(message.well_known.ipv4);
        /* bool ipv6 = 16; */
        if (message.well_known.oneofKind === "ipv6")
            writer.tag(16, runtime_1.WireType.Varint).bool(message.well_known.ipv6);
        /* bool uri = 17; */
        if (message.well_known.oneofKind === "uri")
            writer.tag(17, runtime_1.WireType.Varint).bool(message.well_known.uri);
        /* bool uri_ref = 18; */
        if (message.well_known.oneofKind === "uri_ref")
            writer.tag(18, runtime_1.WireType.Varint).bool(message.well_known.uri_ref);
        /* bool address = 21; */
        if (message.well_known.oneofKind === "address")
            writer.tag(21, runtime_1.WireType.Varint).bool(message.well_known.address);
        /* bool uuid = 22; */
        if (message.well_known.oneofKind === "uuid")
            writer.tag(22, runtime_1.WireType.Varint).bool(message.well_known.uuid);
        /* bool ip_with_prefixlen = 26; */
        if (message.well_known.oneofKind === "ip_with_prefixlen")
            writer.tag(26, runtime_1.WireType.Varint).bool(message.well_known.ip_with_prefixlen);
        /* bool ipv4_with_prefixlen = 27; */
        if (message.well_known.oneofKind === "ipv4_with_prefixlen")
            writer.tag(27, runtime_1.WireType.Varint).bool(message.well_known.ipv4_with_prefixlen);
        /* bool ipv6_with_prefixlen = 28; */
        if (message.well_known.oneofKind === "ipv6_with_prefixlen")
            writer.tag(28, runtime_1.WireType.Varint).bool(message.well_known.ipv6_with_prefixlen);
        /* bool ip_prefix = 29; */
        if (message.well_known.oneofKind === "ip_prefix")
            writer.tag(29, runtime_1.WireType.Varint).bool(message.well_known.ip_prefix);
        /* bool ipv4_prefix = 30; */
        if (message.well_known.oneofKind === "ipv4_prefix")
            writer.tag(30, runtime_1.WireType.Varint).bool(message.well_known.ipv4_prefix);
        /* bool ipv6_prefix = 31; */
        if (message.well_known.oneofKind === "ipv6_prefix")
            writer.tag(31, runtime_1.WireType.Varint).bool(message.well_known.ipv6_prefix);
        /* buf.validate.KnownRegex well_known_regex = 24; */
        if (message.well_known.oneofKind === "well_known_regex")
            writer.tag(24, runtime_1.WireType.Varint).int32(message.well_known.well_known_regex);
        /* optional bool strict = 25; */
        if (message.strict !== undefined)
            writer.tag(25, runtime_1.WireType.Varint).bool(message.strict);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.StringRules
 */
exports.StringRules = new StringRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BytesRules$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.BytesRules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/, options: { "buf.validate.priv.field": { cel: [{ id: "bytes.const", expression: "this != rules.const ? 'value must be %x'.format([rules.const]) : ''" }] } } },
            { no: 13, name: "len", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "bytes.len", expression: "uint(this.size()) != rules.len ? 'value length must be %s bytes'.format([rules.len]) : ''" }] } } },
            { no: 2, name: "min_len", kind: "scalar", localName: "min_len", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "bytes.min_len", expression: "uint(this.size()) < rules.min_len ? 'value length must be at least %s bytes'.format([rules.min_len]) : ''" }] } } },
            { no: 3, name: "max_len", kind: "scalar", localName: "max_len", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "bytes.max_len", expression: "uint(this.size()) > rules.max_len ? 'value must be at most %s bytes'.format([rules.max_len]) : ''" }] } } },
            { no: 4, name: "pattern", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.priv.field": { cel: [{ id: "bytes.pattern", expression: "!string(this).matches(rules.pattern) ? 'value must match regex pattern `%s`'.format([rules.pattern]) : ''" }] } } },
            { no: 5, name: "prefix", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/, options: { "buf.validate.priv.field": { cel: [{ id: "bytes.prefix", expression: "!this.startsWith(rules.prefix) ? 'value does not have prefix %x'.format([rules.prefix]) : ''" }] } } },
            { no: 6, name: "suffix", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/, options: { "buf.validate.priv.field": { cel: [{ id: "bytes.suffix", expression: "!this.endsWith(rules.suffix) ? 'value does not have suffix %x'.format([rules.suffix]) : ''" }] } } },
            { no: 7, name: "contains", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/, options: { "buf.validate.priv.field": { cel: [{ id: "bytes.contains", expression: "!this.contains(rules.contains) ? 'value does not contain %x'.format([rules.contains]) : ''" }] } } },
            { no: 8, name: "in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/, options: { "buf.validate.priv.field": { cel: [{ id: "bytes.in", expression: "dyn(rules)['in'].size() > 0 && !(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 9, name: "not_in", kind: "scalar", localName: "not_in", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/, options: { "buf.validate.priv.field": { cel: [{ id: "bytes.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } },
            { no: 10, name: "ip", kind: "scalar", oneof: "well_known", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "bytes.ip", expression: "this.size() != 4 && this.size() != 16 ? 'value must be a valid IP address' : ''" }] } } },
            { no: 11, name: "ipv4", kind: "scalar", oneof: "well_known", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "bytes.ipv4", expression: "this.size() != 4 ? 'value must be a valid IPv4 address' : ''" }] } } },
            { no: 12, name: "ipv6", kind: "scalar", oneof: "well_known", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "bytes.ipv6", expression: "this.size() != 16 ? 'value must be a valid IPv6 address' : ''" }] } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.in = [];
        message.not_in = [];
        message.well_known = { oneofKind: undefined };
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes const */ 1:
                    message.const = reader.bytes();
                    break;
                case /* optional uint64 len */ 13:
                    message.len = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 min_len */ 2:
                    message.min_len = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 max_len */ 3:
                    message.max_len = reader.uint64().toBigInt();
                    break;
                case /* optional string pattern */ 4:
                    message.pattern = reader.string();
                    break;
                case /* optional bytes prefix */ 5:
                    message.prefix = reader.bytes();
                    break;
                case /* optional bytes suffix */ 6:
                    message.suffix = reader.bytes();
                    break;
                case /* optional bytes contains */ 7:
                    message.contains = reader.bytes();
                    break;
                case /* repeated bytes in */ 8:
                    message.in.push(reader.bytes());
                    break;
                case /* repeated bytes not_in */ 9:
                    message.not_in.push(reader.bytes());
                    break;
                case /* bool ip */ 10:
                    message.well_known = {
                        oneofKind: "ip",
                        ip: reader.bool()
                    };
                    break;
                case /* bool ipv4 */ 11:
                    message.well_known = {
                        oneofKind: "ipv4",
                        ipv4: reader.bool()
                    };
                    break;
                case /* bool ipv6 */ 12:
                    message.well_known = {
                        oneofKind: "ipv6",
                        ipv6: reader.bool()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional bytes const = 1; */
        if (message.const !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).bytes(message.const);
        /* optional uint64 len = 13; */
        if (message.len !== undefined)
            writer.tag(13, runtime_1.WireType.Varint).uint64(message.len);
        /* optional uint64 min_len = 2; */
        if (message.min_len !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint64(message.min_len);
        /* optional uint64 max_len = 3; */
        if (message.max_len !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint64(message.max_len);
        /* optional string pattern = 4; */
        if (message.pattern !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.pattern);
        /* optional bytes prefix = 5; */
        if (message.prefix !== undefined)
            writer.tag(5, runtime_1.WireType.LengthDelimited).bytes(message.prefix);
        /* optional bytes suffix = 6; */
        if (message.suffix !== undefined)
            writer.tag(6, runtime_1.WireType.LengthDelimited).bytes(message.suffix);
        /* optional bytes contains = 7; */
        if (message.contains !== undefined)
            writer.tag(7, runtime_1.WireType.LengthDelimited).bytes(message.contains);
        /* repeated bytes in = 8; */
        for (let i = 0; i < message.in.length; i++)
            writer.tag(8, runtime_1.WireType.LengthDelimited).bytes(message.in[i]);
        /* repeated bytes not_in = 9; */
        for (let i = 0; i < message.not_in.length; i++)
            writer.tag(9, runtime_1.WireType.LengthDelimited).bytes(message.not_in[i]);
        /* bool ip = 10; */
        if (message.well_known.oneofKind === "ip")
            writer.tag(10, runtime_1.WireType.Varint).bool(message.well_known.ip);
        /* bool ipv4 = 11; */
        if (message.well_known.oneofKind === "ipv4")
            writer.tag(11, runtime_1.WireType.Varint).bool(message.well_known.ipv4);
        /* bool ipv6 = 12; */
        if (message.well_known.oneofKind === "ipv6")
            writer.tag(12, runtime_1.WireType.Varint).bool(message.well_known.ipv6);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.BytesRules
 */
exports.BytesRules = new BytesRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnumRules$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.EnumRules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "enum.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 2, name: "defined_only", kind: "scalar", localName: "defined_only", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "enum.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 4, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/, options: { "buf.validate.priv.field": { cel: [{ id: "enum.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 const */ 1:
                    message.const = reader.int32();
                    break;
                case /* optional bool defined_only */ 2:
                    message.defined_only = reader.bool();
                    break;
                case /* repeated int32 in */ 3:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.int32());
                    else
                        message.in.push(reader.int32());
                    break;
                case /* repeated int32 not_in */ 4:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.int32());
                    else
                        message.not_in.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional int32 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.const);
        /* optional bool defined_only = 2; */
        if (message.defined_only !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.defined_only);
        /* repeated int32 in = 3; */
        if (message.in.length) {
            writer.tag(3, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.int32(message.in[i]);
            writer.join();
        }
        /* repeated int32 not_in = 4; */
        if (message.not_in.length) {
            writer.tag(4, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.int32(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.EnumRules
 */
exports.EnumRules = new EnumRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RepeatedRules$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.RepeatedRules", [
            { no: 1, name: "min_items", kind: "scalar", localName: "min_items", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "repeated.min_items", expression: "uint(this.size()) < rules.min_items ? 'value must contain at least %d item(s)'.format([rules.min_items]) : ''" }] } } },
            { no: 2, name: "max_items", kind: "scalar", localName: "max_items", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "repeated.max_items", expression: "uint(this.size()) > rules.max_items ? 'value must contain no more than %s item(s)'.format([rules.max_items]) : ''" }] } } },
            { no: 3, name: "unique", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "repeated.unique", message: "repeated value must contain unique items", expression: "this.unique()" }] } } },
            { no: 4, name: "items", kind: "message", T: () => exports.FieldConstraints }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 min_items */ 1:
                    message.min_items = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 max_items */ 2:
                    message.max_items = reader.uint64().toBigInt();
                    break;
                case /* optional bool unique */ 3:
                    message.unique = reader.bool();
                    break;
                case /* optional buf.validate.FieldConstraints items */ 4:
                    message.items = exports.FieldConstraints.internalBinaryRead(reader, reader.uint32(), options, message.items);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional uint64 min_items = 1; */
        if (message.min_items !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.min_items);
        /* optional uint64 max_items = 2; */
        if (message.max_items !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint64(message.max_items);
        /* optional bool unique = 3; */
        if (message.unique !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.unique);
        /* optional buf.validate.FieldConstraints items = 4; */
        if (message.items)
            exports.FieldConstraints.internalBinaryWrite(message.items, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.RepeatedRules
 */
exports.RepeatedRules = new RepeatedRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapRules$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.MapRules", [
            { no: 1, name: "min_pairs", kind: "scalar", localName: "min_pairs", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "map.min_pairs", expression: "uint(this.size()) < rules.min_pairs ? 'map must be at least %d entries'.format([rules.min_pairs]) : ''" }] } } },
            { no: 2, name: "max_pairs", kind: "scalar", localName: "max_pairs", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "buf.validate.priv.field": { cel: [{ id: "map.max_pairs", expression: "uint(this.size()) > rules.max_pairs ? 'map must be at most %d entries'.format([rules.max_pairs]) : ''" }] } } },
            { no: 4, name: "keys", kind: "message", T: () => exports.FieldConstraints },
            { no: 5, name: "values", kind: "message", T: () => exports.FieldConstraints }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 min_pairs */ 1:
                    message.min_pairs = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 max_pairs */ 2:
                    message.max_pairs = reader.uint64().toBigInt();
                    break;
                case /* optional buf.validate.FieldConstraints keys */ 4:
                    message.keys = exports.FieldConstraints.internalBinaryRead(reader, reader.uint32(), options, message.keys);
                    break;
                case /* optional buf.validate.FieldConstraints values */ 5:
                    message.values = exports.FieldConstraints.internalBinaryRead(reader, reader.uint32(), options, message.values);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional uint64 min_pairs = 1; */
        if (message.min_pairs !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.min_pairs);
        /* optional uint64 max_pairs = 2; */
        if (message.max_pairs !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint64(message.max_pairs);
        /* optional buf.validate.FieldConstraints keys = 4; */
        if (message.keys)
            exports.FieldConstraints.internalBinaryWrite(message.keys, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional buf.validate.FieldConstraints values = 5; */
        if (message.values)
            exports.FieldConstraints.internalBinaryWrite(message.values, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.MapRules
 */
exports.MapRules = new MapRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnyRules$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.AnyRules", [
            { no: 2, name: "in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "not_in", kind: "scalar", localName: "not_in", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string in */ 2:
                    message.in.push(reader.string());
                    break;
                case /* repeated string not_in */ 3:
                    message.not_in.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated string in = 2; */
        for (let i = 0; i < message.in.length; i++)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.in[i]);
        /* repeated string not_in = 3; */
        for (let i = 0; i < message.not_in.length; i++)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.not_in[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.AnyRules
 */
exports.AnyRules = new AnyRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DurationRules$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.DurationRules", [
            { no: 2, name: "const", kind: "message", T: () => duration_pb_1.Duration, options: { "buf.validate.priv.field": { cel: [{ id: "duration.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 3, name: "lt", kind: "message", oneof: "less_than", T: () => duration_pb_1.Duration, options: { "buf.validate.priv.field": { cel: [{ id: "duration.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 4, name: "lte", kind: "message", oneof: "less_than", T: () => duration_pb_1.Duration, options: { "buf.validate.priv.field": { cel: [{ id: "duration.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 5, name: "gt", kind: "message", oneof: "greater_than", T: () => duration_pb_1.Duration, options: { "buf.validate.priv.field": { cel: [{ id: "duration.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "duration.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "duration.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "duration.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "duration.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 6, name: "gte", kind: "message", oneof: "greater_than", T: () => duration_pb_1.Duration, options: { "buf.validate.priv.field": { cel: [{ id: "duration.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "duration.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "duration.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "duration.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "duration.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 7, name: "in", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => duration_pb_1.Duration, options: { "buf.validate.priv.field": { cel: [{ id: "duration.in", expression: "!(this in dyn(rules)['in']) ? 'value must be in list %s'.format([dyn(rules)['in']]) : ''" }] } } },
            { no: 8, name: "not_in", kind: "message", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: () => duration_pb_1.Duration, options: { "buf.validate.priv.field": { cel: [{ id: "duration.not_in", expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''" }] } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.less_than = { oneofKind: undefined };
        message.greater_than = { oneofKind: undefined };
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional google.protobuf.Duration const */ 2:
                    message.const = duration_pb_1.Duration.internalBinaryRead(reader, reader.uint32(), options, message.const);
                    break;
                case /* google.protobuf.Duration lt */ 3:
                    message.less_than = {
                        oneofKind: "lt",
                        lt: duration_pb_1.Duration.internalBinaryRead(reader, reader.uint32(), options, message.less_than.lt)
                    };
                    break;
                case /* google.protobuf.Duration lte */ 4:
                    message.less_than = {
                        oneofKind: "lte",
                        lte: duration_pb_1.Duration.internalBinaryRead(reader, reader.uint32(), options, message.less_than.lte)
                    };
                    break;
                case /* google.protobuf.Duration gt */ 5:
                    message.greater_than = {
                        oneofKind: "gt",
                        gt: duration_pb_1.Duration.internalBinaryRead(reader, reader.uint32(), options, message.greater_than.gt)
                    };
                    break;
                case /* google.protobuf.Duration gte */ 6:
                    message.greater_than = {
                        oneofKind: "gte",
                        gte: duration_pb_1.Duration.internalBinaryRead(reader, reader.uint32(), options, message.greater_than.gte)
                    };
                    break;
                case /* repeated google.protobuf.Duration in */ 7:
                    message.in.push(duration_pb_1.Duration.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated google.protobuf.Duration not_in */ 8:
                    message.not_in.push(duration_pb_1.Duration.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional google.protobuf.Duration const = 2; */
        if (message.const)
            duration_pb_1.Duration.internalBinaryWrite(message.const, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration lt = 3; */
        if (message.less_than.oneofKind === "lt")
            duration_pb_1.Duration.internalBinaryWrite(message.less_than.lt, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration lte = 4; */
        if (message.less_than.oneofKind === "lte")
            duration_pb_1.Duration.internalBinaryWrite(message.less_than.lte, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration gt = 5; */
        if (message.greater_than.oneofKind === "gt")
            duration_pb_1.Duration.internalBinaryWrite(message.greater_than.gt, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration gte = 6; */
        if (message.greater_than.oneofKind === "gte")
            duration_pb_1.Duration.internalBinaryWrite(message.greater_than.gte, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.Duration in = 7; */
        for (let i = 0; i < message.in.length; i++)
            duration_pb_1.Duration.internalBinaryWrite(message.in[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.Duration not_in = 8; */
        for (let i = 0; i < message.not_in.length; i++)
            duration_pb_1.Duration.internalBinaryWrite(message.not_in[i], writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.DurationRules
 */
exports.DurationRules = new DurationRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TimestampRules$Type extends runtime_4.MessageType {
    constructor() {
        super("buf.validate.TimestampRules", [
            { no: 2, name: "const", kind: "message", T: () => timestamp_pb_1.Timestamp, options: { "buf.validate.priv.field": { cel: [{ id: "timestamp.const", expression: "this != rules.const ? 'value must equal %s'.format([rules.const]) : ''" }] } } },
            { no: 3, name: "lt", kind: "message", oneof: "less_than", T: () => timestamp_pb_1.Timestamp, options: { "buf.validate.priv.field": { cel: [{ id: "timestamp.lt", expression: "!has(rules.gte) && !has(rules.gt) && this >= rules.lt? 'value must be less than %s'.format([rules.lt]) : ''" }] } } },
            { no: 4, name: "lte", kind: "message", oneof: "less_than", T: () => timestamp_pb_1.Timestamp, options: { "buf.validate.priv.field": { cel: [{ id: "timestamp.lte", expression: "!has(rules.gte) && !has(rules.gt) && this > rules.lte? 'value must be less than or equal to %s'.format([rules.lte]) : ''" }] } } },
            { no: 7, name: "lt_now", kind: "scalar", localName: "lt_now", oneof: "less_than", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "timestamp.lt_now", expression: "this > now ? 'value must be less than now' : ''" }] } } },
            { no: 5, name: "gt", kind: "message", oneof: "greater_than", T: () => timestamp_pb_1.Timestamp, options: { "buf.validate.priv.field": { cel: [{ id: "timestamp.gt", expression: "!has(rules.lt) && !has(rules.lte) && this <= rules.gt? 'value must be greater than %s'.format([rules.gt]) : ''" }, { id: "timestamp.gt_lt", expression: "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "timestamp.gt_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''" }, { id: "timestamp.gt_lte", expression: "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }, { id: "timestamp.gt_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''" }] } } },
            { no: 6, name: "gte", kind: "message", oneof: "greater_than", T: () => timestamp_pb_1.Timestamp, options: { "buf.validate.priv.field": { cel: [{ id: "timestamp.gte", expression: "!has(rules.lt) && !has(rules.lte) && this < rules.gte? 'value must be greater than or equal to %s'.format([rules.gte]) : ''" }, { id: "timestamp.gte_lt", expression: "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "timestamp.gte_lt_exclusive", expression: "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''" }, { id: "timestamp.gte_lte", expression: "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }, { id: "timestamp.gte_lte_exclusive", expression: "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''" }] } } },
            { no: 8, name: "gt_now", kind: "scalar", localName: "gt_now", oneof: "greater_than", T: 8 /*ScalarType.BOOL*/, options: { "buf.validate.priv.field": { cel: [{ id: "timestamp.gt_now", expression: "this < now ? 'value must be greater than now' : ''" }] } } },
            { no: 9, name: "within", kind: "message", T: () => duration_pb_1.Duration, options: { "buf.validate.priv.field": { cel: [{ id: "timestamp.within", expression: "this < now-rules.within || this > now+rules.within ? 'value must be within %s of now'.format([rules.within]) : ''" }] } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.less_than = { oneofKind: undefined };
        message.greater_than = { oneofKind: undefined };
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional google.protobuf.Timestamp const */ 2:
                    message.const = timestamp_pb_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.const);
                    break;
                case /* google.protobuf.Timestamp lt */ 3:
                    message.less_than = {
                        oneofKind: "lt",
                        lt: timestamp_pb_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.less_than.lt)
                    };
                    break;
                case /* google.protobuf.Timestamp lte */ 4:
                    message.less_than = {
                        oneofKind: "lte",
                        lte: timestamp_pb_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.less_than.lte)
                    };
                    break;
                case /* bool lt_now */ 7:
                    message.less_than = {
                        oneofKind: "lt_now",
                        lt_now: reader.bool()
                    };
                    break;
                case /* google.protobuf.Timestamp gt */ 5:
                    message.greater_than = {
                        oneofKind: "gt",
                        gt: timestamp_pb_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.greater_than.gt)
                    };
                    break;
                case /* google.protobuf.Timestamp gte */ 6:
                    message.greater_than = {
                        oneofKind: "gte",
                        gte: timestamp_pb_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.greater_than.gte)
                    };
                    break;
                case /* bool gt_now */ 8:
                    message.greater_than = {
                        oneofKind: "gt_now",
                        gt_now: reader.bool()
                    };
                    break;
                case /* optional google.protobuf.Duration within */ 9:
                    message.within = duration_pb_1.Duration.internalBinaryRead(reader, reader.uint32(), options, message.within);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional google.protobuf.Timestamp const = 2; */
        if (message.const)
            timestamp_pb_1.Timestamp.internalBinaryWrite(message.const, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp lt = 3; */
        if (message.less_than.oneofKind === "lt")
            timestamp_pb_1.Timestamp.internalBinaryWrite(message.less_than.lt, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp lte = 4; */
        if (message.less_than.oneofKind === "lte")
            timestamp_pb_1.Timestamp.internalBinaryWrite(message.less_than.lte, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool lt_now = 7; */
        if (message.less_than.oneofKind === "lt_now")
            writer.tag(7, runtime_1.WireType.Varint).bool(message.less_than.lt_now);
        /* google.protobuf.Timestamp gt = 5; */
        if (message.greater_than.oneofKind === "gt")
            timestamp_pb_1.Timestamp.internalBinaryWrite(message.greater_than.gt, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp gte = 6; */
        if (message.greater_than.oneofKind === "gte")
            timestamp_pb_1.Timestamp.internalBinaryWrite(message.greater_than.gte, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool gt_now = 8; */
        if (message.greater_than.oneofKind === "gt_now")
            writer.tag(8, runtime_1.WireType.Varint).bool(message.greater_than.gt_now);
        /* optional google.protobuf.Duration within = 9; */
        if (message.within)
            duration_pb_1.Duration.internalBinaryWrite(message.within, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message buf.validate.TimestampRules
 */
exports.TimestampRules = new TimestampRules$Type();
