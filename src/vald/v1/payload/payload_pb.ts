// @generated by protobuf-ts 2.9.3 with parameter add_pb_suffix,client_grpc1,generate_dependencies,keep_enum_prefix,ts_nocheck,use_proto_field_name
// @generated from protobuf file "vald/v1/payload/payload.proto" (package "payload.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
//
//
// Copyright (C) 2019-2023 vdaas.org vald team <vald@vdaas.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Status } from "../../../google/rpc/status_pb";
/**
 * Search related messages.
 *
 * @generated from protobuf message payload.v1.Search
 */
export interface Search {
}
/**
 * Represent a search request.
 *
 * @generated from protobuf message payload.v1.Search.Request
 */
export interface Search_Request {
    /**
     * The vector to be searched.
     *
     * @generated from protobuf field: repeated float vector = 1;
     */
    vector: number[];
    /**
     * The configuration of the search request.
     *
     * @generated from protobuf field: payload.v1.Search.Config config = 2;
     */
    config?: Search_Config;
}
/**
 * Represent the multiple search request.
 *
 * @generated from protobuf message payload.v1.Search.MultiRequest
 */
export interface Search_MultiRequest {
    /**
     * Represent the multiple search request content.
     *
     * @generated from protobuf field: repeated payload.v1.Search.Request requests = 1;
     */
    requests: Search_Request[];
}
/**
 * Represent a search by ID request.
 *
 * @generated from protobuf message payload.v1.Search.IDRequest
 */
export interface Search_IDRequest {
    /**
     * The vector ID to be searched.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * The configuration of the search request.
     *
     * @generated from protobuf field: payload.v1.Search.Config config = 2;
     */
    config?: Search_Config;
}
/**
 * Represent the multiple search by ID request.
 *
 * @generated from protobuf message payload.v1.Search.MultiIDRequest
 */
export interface Search_MultiIDRequest {
    /**
     * Represent the multiple search by ID request content.
     *
     * @generated from protobuf field: repeated payload.v1.Search.IDRequest requests = 1;
     */
    requests: Search_IDRequest[];
}
/**
 * Represent a search by binary object request.
 *
 * @generated from protobuf message payload.v1.Search.ObjectRequest
 */
export interface Search_ObjectRequest {
    /**
     * The binary object to be searched.
     *
     * @generated from protobuf field: bytes object = 1;
     */
    object: Uint8Array;
    /**
     * The configuration of the search request.
     *
     * @generated from protobuf field: payload.v1.Search.Config config = 2;
     */
    config?: Search_Config;
    /**
     * Filter configuration.
     *
     * @generated from protobuf field: payload.v1.Filter.Target vectorizer = 3;
     */
    vectorizer?: Filter_Target;
}
/**
 * Represent the multiple search by binary object request.
 *
 * @generated from protobuf message payload.v1.Search.MultiObjectRequest
 */
export interface Search_MultiObjectRequest {
    /**
     * Represent the multiple search by binary object request content.
     *
     * @generated from protobuf field: repeated payload.v1.Search.ObjectRequest requests = 1;
     */
    requests: Search_ObjectRequest[];
}
/**
 * Represent search configuration.
 *
 * @generated from protobuf message payload.v1.Search.Config
 */
export interface Search_Config {
    /**
     * Unique request ID.
     *
     * @generated from protobuf field: string request_id = 1;
     */
    request_id: string;
    /**
     * Maximum number of result to be returned.
     *
     * @generated from protobuf field: uint32 num = 2;
     */
    num: number;
    /**
     * Search radius.
     *
     * @generated from protobuf field: float radius = 3;
     */
    radius: number;
    /**
     * Search coefficient.
     *
     * @generated from protobuf field: float epsilon = 4;
     */
    epsilon: number;
    /**
     * Search timeout in nanoseconds.
     *
     * @generated from protobuf field: int64 timeout = 5;
     */
    timeout: bigint;
    /**
     * Ingress filter configurations.
     *
     * @generated from protobuf field: payload.v1.Filter.Config ingress_filters = 6;
     */
    ingress_filters?: Filter_Config;
    /**
     * Egress filter configurations.
     *
     * @generated from protobuf field: payload.v1.Filter.Config egress_filters = 7;
     */
    egress_filters?: Filter_Config;
    /**
     * Minimum number of result to be returned.
     *
     * @generated from protobuf field: uint32 min_num = 8;
     */
    min_num: number;
    /**
     * Aggregation Algorithm
     *
     * @generated from protobuf field: payload.v1.Search.AggregationAlgorithm aggregation_algorithm = 9;
     */
    aggregation_algorithm: Search_AggregationAlgorithm;
}
/**
 * Represent a search response.
 *
 * @generated from protobuf message payload.v1.Search.Response
 */
export interface Search_Response {
    /**
     * The unique request ID.
     *
     * @generated from protobuf field: string request_id = 1;
     */
    request_id: string;
    /**
     * Search results.
     *
     * @generated from protobuf field: repeated payload.v1.Object.Distance results = 2;
     */
    results: Object_Distance[];
}
/**
 * Represent multiple search responses.
 *
 * @generated from protobuf message payload.v1.Search.Responses
 */
export interface Search_Responses {
    /**
     * Represent the multiple search response content.
     *
     * @generated from protobuf field: repeated payload.v1.Search.Response responses = 1;
     */
    responses: Search_Response[];
}
/**
 * Represent stream search response.
 *
 * @generated from protobuf message payload.v1.Search.StreamResponse
 */
export interface Search_StreamResponse {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "response";
        /**
         * Represent the search response.
         *
         * @generated from protobuf field: payload.v1.Search.Response response = 1;
         */
        response: Search_Response;
    } | {
        oneofKind: "status";
        /**
         * The RPC error status.
         *
         * @generated from protobuf field: google.rpc.Status status = 2;
         */
        status: Status;
    } | {
        oneofKind: undefined;
    };
}
/**
 * AggregationAlgorithm is enum of each aggregation algorithms
 *
 * @generated from protobuf enum payload.v1.Search.AggregationAlgorithm
 */
export enum Search_AggregationAlgorithm {
    /**
     * @generated from protobuf enum value: Unknown = 0;
     */
    Unknown = 0,
    /**
     * @generated from protobuf enum value: ConcurrentQueue = 1;
     */
    ConcurrentQueue = 1,
    /**
     * @generated from protobuf enum value: SortSlice = 2;
     */
    SortSlice = 2,
    /**
     * @generated from protobuf enum value: SortPoolSlice = 3;
     */
    SortPoolSlice = 3,
    /**
     * @generated from protobuf enum value: PairingHeap = 4;
     */
    PairingHeap = 4
}
/**
 * Filter related messages.
 *
 * @generated from protobuf message payload.v1.Filter
 */
export interface Filter {
}
/**
 * Represent the target filter server.
 *
 * @generated from protobuf message payload.v1.Filter.Target
 */
export interface Filter_Target {
    /**
     * The target hostname.
     *
     * @generated from protobuf field: string host = 1;
     */
    host: string;
    /**
     * The target port.
     *
     * @generated from protobuf field: uint32 port = 2;
     */
    port: number;
}
/**
 * Represent filter configuration.
 *
 * @generated from protobuf message payload.v1.Filter.Config
 */
export interface Filter_Config {
    /**
     * Represent the filter target configuration.
     *
     * @generated from protobuf field: repeated payload.v1.Filter.Target targets = 1;
     */
    targets: Filter_Target[];
}
/**
 * Insert related messages.
 *
 * @generated from protobuf message payload.v1.Insert
 */
export interface Insert {
}
/**
 * Represent the insert request.
 *
 * @generated from protobuf message payload.v1.Insert.Request
 */
export interface Insert_Request {
    /**
     * The vector to be inserted.
     *
     * @generated from protobuf field: payload.v1.Object.Vector vector = 1;
     */
    vector?: Object_Vector;
    /**
     * The configuration of the insert request.
     *
     * @generated from protobuf field: payload.v1.Insert.Config config = 2;
     */
    config?: Insert_Config;
}
/**
 * Represent the multiple insert request.
 *
 * @generated from protobuf message payload.v1.Insert.MultiRequest
 */
export interface Insert_MultiRequest {
    /**
     * Represent multiple insert request content.
     *
     * @generated from protobuf field: repeated payload.v1.Insert.Request requests = 1;
     */
    requests: Insert_Request[];
}
/**
 * Represent the insert by binary object request.
 *
 * @generated from protobuf message payload.v1.Insert.ObjectRequest
 */
export interface Insert_ObjectRequest {
    /**
     * The binary object to be inserted.
     *
     * @generated from protobuf field: payload.v1.Object.Blob object = 1;
     */
    object?: Object_Blob;
    /**
     * The configuration of the insert request.
     *
     * @generated from protobuf field: payload.v1.Insert.Config config = 2;
     */
    config?: Insert_Config;
    /**
     * Filter configurations.
     *
     * @generated from protobuf field: payload.v1.Filter.Target vectorizer = 3;
     */
    vectorizer?: Filter_Target;
}
/**
 * Represent the multiple insert by binary object request.
 *
 * @generated from protobuf message payload.v1.Insert.MultiObjectRequest
 */
export interface Insert_MultiObjectRequest {
    /**
     * Represent multiple insert by object content.
     *
     * @generated from protobuf field: repeated payload.v1.Insert.ObjectRequest requests = 1;
     */
    requests: Insert_ObjectRequest[];
}
/**
 * Represent insert configurations.
 *
 * @generated from protobuf message payload.v1.Insert.Config
 */
export interface Insert_Config {
    /**
     * A flag to skip exist check during insert operation.
     *
     * @generated from protobuf field: bool skip_strict_exist_check = 1;
     */
    skip_strict_exist_check: boolean;
    /**
     * Filter configurations.
     *
     * @generated from protobuf field: payload.v1.Filter.Config filters = 2;
     */
    filters?: Filter_Config;
    /**
     * Insert timestamp.
     *
     * @generated from protobuf field: int64 timestamp = 3;
     */
    timestamp: bigint;
}
/**
 * Update related messages
 *
 * @generated from protobuf message payload.v1.Update
 */
export interface Update {
}
/**
 * Represent the update request.
 *
 * @generated from protobuf message payload.v1.Update.Request
 */
export interface Update_Request {
    /**
     * The vector to be updated.
     *
     * @generated from protobuf field: payload.v1.Object.Vector vector = 1;
     */
    vector?: Object_Vector;
    /**
     * The configuration of the update request.
     *
     * @generated from protobuf field: payload.v1.Update.Config config = 2;
     */
    config?: Update_Config;
}
/**
 * Represent the multiple update request.
 *
 * @generated from protobuf message payload.v1.Update.MultiRequest
 */
export interface Update_MultiRequest {
    /**
     * Represent the multiple update request content.
     *
     * @generated from protobuf field: repeated payload.v1.Update.Request requests = 1;
     */
    requests: Update_Request[];
}
/**
 * Represent the update binary object request.
 *
 * @generated from protobuf message payload.v1.Update.ObjectRequest
 */
export interface Update_ObjectRequest {
    /**
     * The binary object to be updated.
     *
     * @generated from protobuf field: payload.v1.Object.Blob object = 1;
     */
    object?: Object_Blob;
    /**
     * The configuration of the update request.
     *
     * @generated from protobuf field: payload.v1.Update.Config config = 2;
     */
    config?: Update_Config;
    /**
     * Filter target.
     *
     * @generated from protobuf field: payload.v1.Filter.Target vectorizer = 3;
     */
    vectorizer?: Filter_Target;
}
/**
 * Represent the multiple update binary object request.
 *
 * @generated from protobuf message payload.v1.Update.MultiObjectRequest
 */
export interface Update_MultiObjectRequest {
    /**
     * Represent the multiple update object request content.
     *
     * @generated from protobuf field: repeated payload.v1.Update.ObjectRequest requests = 1;
     */
    requests: Update_ObjectRequest[];
}
/**
 * Represent the update configuration.
 *
 * @generated from protobuf message payload.v1.Update.Config
 */
export interface Update_Config {
    /**
     * A flag to skip exist check during update operation.
     *
     * @generated from protobuf field: bool skip_strict_exist_check = 1;
     */
    skip_strict_exist_check: boolean;
    /**
     * Filter configuration.
     *
     * @generated from protobuf field: payload.v1.Filter.Config filters = 2;
     */
    filters?: Filter_Config;
    /**
     * Update timestamp.
     *
     * @generated from protobuf field: int64 timestamp = 3;
     */
    timestamp: bigint;
    /**
     * A flag to disable balanced update (split remove -> insert operation)
     * during update operation.
     *
     * @generated from protobuf field: bool disable_balanced_update = 4;
     */
    disable_balanced_update: boolean;
}
/**
 * Upsert related messages.
 *
 * @generated from protobuf message payload.v1.Upsert
 */
export interface Upsert {
}
/**
 * Represent the upsert request.
 *
 * @generated from protobuf message payload.v1.Upsert.Request
 */
export interface Upsert_Request {
    /**
     * The vector to be upserted.
     *
     * @generated from protobuf field: payload.v1.Object.Vector vector = 1;
     */
    vector?: Object_Vector;
    /**
     * The configuration of the upsert request.
     *
     * @generated from protobuf field: payload.v1.Upsert.Config config = 2;
     */
    config?: Upsert_Config;
}
/**
 * Represent mthe ultiple upsert request.
 *
 * @generated from protobuf message payload.v1.Upsert.MultiRequest
 */
export interface Upsert_MultiRequest {
    /**
     * Represent the multiple upsert request content.
     *
     * @generated from protobuf field: repeated payload.v1.Upsert.Request requests = 1;
     */
    requests: Upsert_Request[];
}
/**
 * Represent the upsert binary object request.
 *
 * @generated from protobuf message payload.v1.Upsert.ObjectRequest
 */
export interface Upsert_ObjectRequest {
    /**
     * The binary object to be upserted.
     *
     * @generated from protobuf field: payload.v1.Object.Blob object = 1;
     */
    object?: Object_Blob;
    /**
     * The configuration of the upsert request.
     *
     * @generated from protobuf field: payload.v1.Upsert.Config config = 2;
     */
    config?: Upsert_Config;
    /**
     * Filter target.
     *
     * @generated from protobuf field: payload.v1.Filter.Target vectorizer = 3;
     */
    vectorizer?: Filter_Target;
}
/**
 * Represent the multiple upsert binary object request.
 *
 * @generated from protobuf message payload.v1.Upsert.MultiObjectRequest
 */
export interface Upsert_MultiObjectRequest {
    /**
     * Represent the multiple upsert object request content.
     *
     * @generated from protobuf field: repeated payload.v1.Upsert.ObjectRequest requests = 1;
     */
    requests: Upsert_ObjectRequest[];
}
/**
 * Represent the upsert configuration.
 *
 * @generated from protobuf message payload.v1.Upsert.Config
 */
export interface Upsert_Config {
    /**
     * A flag to skip exist check during upsert operation.
     *
     * @generated from protobuf field: bool skip_strict_exist_check = 1;
     */
    skip_strict_exist_check: boolean;
    /**
     * Filter configuration.
     *
     * @generated from protobuf field: payload.v1.Filter.Config filters = 2;
     */
    filters?: Filter_Config;
    /**
     * Upsert timestamp.
     *
     * @generated from protobuf field: int64 timestamp = 3;
     */
    timestamp: bigint;
    /**
     * A flag to disable balanced update (split remove -> insert operation)
     * during update operation.
     *
     * @generated from protobuf field: bool disable_balanced_update = 4;
     */
    disable_balanced_update: boolean;
}
/**
 * Remove related messages.
 *
 * @generated from protobuf message payload.v1.Remove
 */
export interface Remove {
}
/**
 * Represent the remove request.
 *
 * @generated from protobuf message payload.v1.Remove.Request
 */
export interface Remove_Request {
    /**
     * The object ID to be removed.
     *
     * @generated from protobuf field: payload.v1.Object.ID id = 1;
     */
    id?: Object_ID;
    /**
     * The configuration of the remove request.
     *
     * @generated from protobuf field: payload.v1.Remove.Config config = 2;
     */
    config?: Remove_Config;
}
/**
 * Represent the multiple remove request.
 *
 * @generated from protobuf message payload.v1.Remove.MultiRequest
 */
export interface Remove_MultiRequest {
    /**
     * Represent the multiple remove request content.
     *
     * @generated from protobuf field: repeated payload.v1.Remove.Request requests = 1;
     */
    requests: Remove_Request[];
}
/**
 * Represent the remove request based on timestamp.
 *
 * @generated from protobuf message payload.v1.Remove.TimestampRequest
 */
export interface Remove_TimestampRequest {
    /**
     * The timestamp comparison list. If more than one is specified, the `AND` search is applied.
     *
     * @generated from protobuf field: repeated payload.v1.Remove.Timestamp timestamps = 1;
     */
    timestamps: Remove_Timestamp[];
}
/**
 * Represent the timestamp comparison.
 *
 * @generated from protobuf message payload.v1.Remove.Timestamp
 */
export interface Remove_Timestamp {
    /**
     * The timestamp.
     *
     * @generated from protobuf field: int64 timestamp = 1;
     */
    timestamp: bigint;
    /**
     * The conditional operator.
     *
     * @generated from protobuf field: payload.v1.Remove.Timestamp.Operator operator = 2;
     */
    operator: Remove_Timestamp_Operator;
}
/**
 * Operator is enum of each conditional operator.
 *
 * @generated from protobuf enum payload.v1.Remove.Timestamp.Operator
 */
export enum Remove_Timestamp_Operator {
    /**
     * The timestamp is equal to the specified value in the request.
     *
     * @generated from protobuf enum value: Eq = 0;
     */
    Eq = 0,
    /**
     * The timestamp is not equal to the specified value in the request.
     *
     * @generated from protobuf enum value: Ne = 1;
     */
    Ne = 1,
    /**
     * The timestamp is greater than or equal to the specified value in the request.
     *
     * @generated from protobuf enum value: Ge = 2;
     */
    Ge = 2,
    /**
     * The timestamp is greater than the specified value in the request.
     *
     * @generated from protobuf enum value: Gt = 3;
     */
    Gt = 3,
    /**
     * The timestamp is less than or equal to the specified value in the request.
     *
     * @generated from protobuf enum value: Le = 4;
     */
    Le = 4,
    /**
     * The timestamp is less than the specified value in the request.
     *
     * @generated from protobuf enum value: Lt = 5;
     */
    Lt = 5
}
/**
 * Represent the remove configuration.
 *
 * @generated from protobuf message payload.v1.Remove.Config
 */
export interface Remove_Config {
    /**
     * A flag to skip exist check during upsert operation.
     *
     * @generated from protobuf field: bool skip_strict_exist_check = 1;
     */
    skip_strict_exist_check: boolean;
    /**
     * Remove timestamp.
     *
     * @generated from protobuf field: int64 timestamp = 3;
     */
    timestamp: bigint;
}
/**
 * Common messages.
 *
 * @generated from protobuf message payload.v1.Object
 */
export interface Object {
}
/**
 * Represent a request to fetch raw vector.
 *
 * @generated from protobuf message payload.v1.Object.VectorRequest
 */
export interface Object_VectorRequest {
    /**
     * The vector ID to be fetched.
     *
     * @generated from protobuf field: payload.v1.Object.ID id = 1;
     */
    id?: Object_ID;
    /**
     * Filter configurations.
     *
     * @generated from protobuf field: payload.v1.Filter.Config filters = 2;
     */
    filters?: Filter_Config;
}
/**
 * Represent the ID and distance pair.
 *
 * @generated from protobuf message payload.v1.Object.Distance
 */
export interface Object_Distance {
    /**
     * The vector ID.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * The distance.
     *
     * @generated from protobuf field: float distance = 2;
     */
    distance: number;
}
/**
 * Represent stream response of distances.
 *
 * @generated from protobuf message payload.v1.Object.StreamDistance
 */
export interface Object_StreamDistance {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "distance";
        /**
         * The distance.
         *
         * @generated from protobuf field: payload.v1.Object.Distance distance = 1;
         */
        distance: Object_Distance;
    } | {
        oneofKind: "status";
        /**
         * The RPC error status.
         *
         * @generated from protobuf field: google.rpc.Status status = 2;
         */
        status: Status;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Represent the vector ID.
 *
 * @generated from protobuf message payload.v1.Object.ID
 */
export interface Object_ID {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
}
/**
 * Represent multiple vector IDs.
 *
 * @generated from protobuf message payload.v1.Object.IDs
 */
export interface Object_IDs {
    /**
     * @generated from protobuf field: repeated string ids = 1;
     */
    ids: string[];
}
/**
 * Represent a vector.
 *
 * @generated from protobuf message payload.v1.Object.Vector
 */
export interface Object_Vector {
    /**
     * The vector ID.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * The vector.
     *
     * @generated from protobuf field: repeated float vector = 2;
     */
    vector: number[];
    /**
     * timestamp represents when this vector inserted.
     *
     * @generated from protobuf field: int64 timestamp = 3;
     */
    timestamp: bigint;
}
/**
 * Represent a request to fetch vector meta data.
 *
 * @generated from protobuf message payload.v1.Object.GetTimestampRequest
 */
export interface Object_GetTimestampRequest {
    /**
     * The vector ID to be fetched.
     *
     * @generated from protobuf field: payload.v1.Object.ID id = 1;
     */
    id?: Object_ID;
}
/**
 * Represent a vector meta data.
 *
 * @generated from protobuf message payload.v1.Object.Timestamp
 */
export interface Object_Timestamp {
    /**
     * The vector ID.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * timestamp represents when this vector inserted.
     *
     * @generated from protobuf field: int64 timestamp = 2;
     */
    timestamp: bigint;
}
/**
 * Represent multiple vectors.
 *
 * @generated from protobuf message payload.v1.Object.Vectors
 */
export interface Object_Vectors {
    /**
     * @generated from protobuf field: repeated payload.v1.Object.Vector vectors = 1;
     */
    vectors: Object_Vector[];
}
/**
 * Represent stream response of the vector.
 *
 * @generated from protobuf message payload.v1.Object.StreamVector
 */
export interface Object_StreamVector {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "vector";
        /**
         * The vector.
         *
         * @generated from protobuf field: payload.v1.Object.Vector vector = 1;
         */
        vector: Object_Vector;
    } | {
        oneofKind: "status";
        /**
         * The RPC error status.
         *
         * @generated from protobuf field: google.rpc.Status status = 2;
         */
        status: Status;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Represent reshape vector.
 *
 * @generated from protobuf message payload.v1.Object.ReshapeVector
 */
export interface Object_ReshapeVector {
    /**
     * The binary object.
     *
     * @generated from protobuf field: bytes object = 1;
     */
    object: Uint8Array;
    /**
     * The new shape.
     *
     * @generated from protobuf field: repeated int32 shape = 2;
     */
    shape: number[];
}
/**
 * Represent the binary object.
 *
 * @generated from protobuf message payload.v1.Object.Blob
 */
export interface Object_Blob {
    /**
     * The object ID.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * The binary object.
     *
     * @generated from protobuf field: bytes object = 2;
     */
    object: Uint8Array;
}
/**
 * Represent stream response of binary objects.
 *
 * @generated from protobuf message payload.v1.Object.StreamBlob
 */
export interface Object_StreamBlob {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "blob";
        /**
         * The binary object.
         *
         * @generated from protobuf field: payload.v1.Object.Blob blob = 1;
         */
        blob: Object_Blob;
    } | {
        oneofKind: "status";
        /**
         * The RPC error status.
         *
         * @generated from protobuf field: google.rpc.Status status = 2;
         */
        status: Status;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Represent the vector location.
 *
 * @generated from protobuf message payload.v1.Object.Location
 */
export interface Object_Location {
    /**
     * The name of the location.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The UUID of the vector.
     *
     * @generated from protobuf field: string uuid = 2;
     */
    uuid: string;
    /**
     * The IP list.
     *
     * @generated from protobuf field: repeated string ips = 3;
     */
    ips: string[];
}
/**
 * Represent the stream response of the vector location.
 *
 * @generated from protobuf message payload.v1.Object.StreamLocation
 */
export interface Object_StreamLocation {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "location";
        /**
         * The vector location.
         *
         * @generated from protobuf field: payload.v1.Object.Location location = 1;
         */
        location: Object_Location;
    } | {
        oneofKind: "status";
        /**
         * The RPC error status.
         *
         * @generated from protobuf field: google.rpc.Status status = 2;
         */
        status: Status;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Represent multiple vector locations.
 *
 * @generated from protobuf message payload.v1.Object.Locations
 */
export interface Object_Locations {
    /**
     * @generated from protobuf field: repeated payload.v1.Object.Location locations = 1;
     */
    locations: Object_Location[];
}
/**
 * Represent the list object vector stream request and response.
 *
 * @generated from protobuf message payload.v1.Object.List
 */
export interface Object_List {
}
/**
 * @generated from protobuf message payload.v1.Object.List.Request
 */
export interface Object_List_Request {
}
/**
 * @generated from protobuf message payload.v1.Object.List.Response
 */
export interface Object_List_Response {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "vector";
        /**
         * The vector
         *
         * @generated from protobuf field: payload.v1.Object.Vector vector = 1;
         */
        vector: Object_Vector;
    } | {
        oneofKind: "status";
        /**
         * The RPC error status.
         *
         * @generated from protobuf field: google.rpc.Status status = 2;
         */
        status: Status;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Control related messages.
 *
 * @generated from protobuf message payload.v1.Control
 */
export interface Control {
}
/**
 * Represent the create index request.
 *
 * @generated from protobuf message payload.v1.Control.CreateIndexRequest
 */
export interface Control_CreateIndexRequest {
    /**
     * The pool size of the create index operation.
     *
     * @generated from protobuf field: uint32 pool_size = 1;
     */
    pool_size: number;
}
/**
 * Discoverer related messages.
 *
 * @generated from protobuf message payload.v1.Discoverer
 */
export interface Discoverer {
}
/**
 * Represent the dicoverer request.
 *
 * @generated from protobuf message payload.v1.Discoverer.Request
 */
export interface Discoverer_Request {
    /**
     * The agent name to be discovered.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The namespace to be discovered.
     *
     * @generated from protobuf field: string namespace = 2;
     */
    namespace: string;
    /**
     * The node to be discovered.
     *
     * @generated from protobuf field: string node = 3;
     */
    node: string;
}
/**
 * Info related messages.
 *
 * @generated from protobuf message payload.v1.Info
 */
export interface Info {
}
/**
 * Represent the index information messages.
 *
 * @generated from protobuf message payload.v1.Info.Index
 */
export interface Info_Index {
}
/**
 * Represent the index count message.
 *
 * @generated from protobuf message payload.v1.Info.Index.Count
 */
export interface Info_Index_Count {
    /**
     * The stored index count.
     *
     * @generated from protobuf field: uint32 stored = 1;
     */
    stored: number;
    /**
     * The uncommitted index count.
     *
     * @generated from protobuf field: uint32 uncommitted = 2;
     */
    uncommitted: number;
    /**
     * The indexing index count.
     *
     * @generated from protobuf field: bool indexing = 3;
     */
    indexing: boolean;
    /**
     * The saving index count.
     *
     * @generated from protobuf field: bool saving = 4;
     */
    saving: boolean;
}
/**
 * Represent the UUID message.
 *
 * @generated from protobuf message payload.v1.Info.Index.UUID
 */
export interface Info_Index_UUID {
}
/**
 * The committed UUID.
 *
 * @generated from protobuf message payload.v1.Info.Index.UUID.Committed
 */
export interface Info_Index_UUID_Committed {
    /**
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
}
/**
 * The uncommitted UUID.
 *
 * @generated from protobuf message payload.v1.Info.Index.UUID.Uncommitted
 */
export interface Info_Index_UUID_Uncommitted {
    /**
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
}
/**
 * Represent the pod information message.
 *
 * @generated from protobuf message payload.v1.Info.Pod
 */
export interface Info_Pod {
    /**
     * The app name of the pod on the label.
     *
     * @generated from protobuf field: string app_name = 1;
     */
    app_name: string;
    /**
     * The name of the pod.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * The namespace of the pod.
     *
     * @generated from protobuf field: string namespace = 3;
     */
    namespace: string;
    /**
     * The IP of the pod.
     *
     * @generated from protobuf field: string ip = 4;
     */
    ip: string;
    /**
     * The CPU information of the pod.
     *
     * @generated from protobuf field: payload.v1.Info.CPU cpu = 5;
     */
    cpu?: Info_CPU;
    /**
     * The memory information of the pod.
     *
     * @generated from protobuf field: payload.v1.Info.Memory memory = 6;
     */
    memory?: Info_Memory;
    /**
     * The node information of the pod.
     *
     * @generated from protobuf field: payload.v1.Info.Node node = 7;
     */
    node?: Info_Node;
}
/**
 * Represent the node information message.
 *
 * @generated from protobuf message payload.v1.Info.Node
 */
export interface Info_Node {
    /**
     * The name of the node.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The internal IP address of the node.
     *
     * @generated from protobuf field: string internal_addr = 2;
     */
    internal_addr: string;
    /**
     * The external IP address of the node.
     *
     * @generated from protobuf field: string external_addr = 3;
     */
    external_addr: string;
    /**
     * The CPU information of the node.
     *
     * @generated from protobuf field: payload.v1.Info.CPU cpu = 4;
     */
    cpu?: Info_CPU;
    /**
     * The memory information of the node.
     *
     * @generated from protobuf field: payload.v1.Info.Memory memory = 5;
     */
    memory?: Info_Memory;
    /**
     * The pod information of the node.
     *
     * @generated from protobuf field: payload.v1.Info.Pods Pods = 6 [json_name = "Pods"];
     */
    Pods?: Info_Pods;
}
/**
 * Represent the service information message.
 *
 * @generated from protobuf message payload.v1.Info.Service
 */
export interface Info_Service {
    /**
     * The name of the svc.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The cluster ip of the svc.
     *
     * @generated from protobuf field: string cluster_ip = 2;
     */
    cluster_ip: string;
    /**
     * The cluster ips of the svc.
     *
     * @generated from protobuf field: repeated string cluster_ips = 3;
     */
    cluster_ips: string[];
    /**
     * The port of the svc.
     *
     * @generated from protobuf field: repeated payload.v1.Info.ServicePort ports = 4;
     */
    ports: Info_ServicePort[];
    /**
     * The labels of the service.
     *
     * @generated from protobuf field: payload.v1.Info.Labels labels = 5;
     */
    labels?: Info_Labels;
    /**
     * The annotations of the service.
     *
     * @generated from protobuf field: payload.v1.Info.Annotations annotations = 6;
     */
    annotations?: Info_Annotations;
}
/**
 * Represets the service port information message.
 *
 * @generated from protobuf message payload.v1.Info.ServicePort
 */
export interface Info_ServicePort {
    /**
     * The name of the port.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The port number
     *
     * @generated from protobuf field: int32 port = 2;
     */
    port: number;
}
/**
 * Represent the kubernetes labels.
 *
 * @generated from protobuf message payload.v1.Info.Labels
 */
export interface Info_Labels {
    /**
     * @generated from protobuf field: map<string, string> labels = 1;
     */
    labels: {
        [key: string]: string;
    };
}
/**
 * Represent the kubernetes annotations.
 *
 * @generated from protobuf message payload.v1.Info.Annotations
 */
export interface Info_Annotations {
    /**
     * @generated from protobuf field: map<string, string> annotations = 1;
     */
    annotations: {
        [key: string]: string;
    };
}
/**
 * Represent the CPU information message.
 *
 * @generated from protobuf message payload.v1.Info.CPU
 */
export interface Info_CPU {
    /**
     * The CPU resource limit.
     *
     * @generated from protobuf field: double limit = 1;
     */
    limit: number;
    /**
     * The CPU resource requested.
     *
     * @generated from protobuf field: double request = 2;
     */
    request: number;
    /**
     * The CPU usage.
     *
     * @generated from protobuf field: double usage = 3;
     */
    usage: number;
}
/**
 * Represent the memory information message.
 *
 * @generated from protobuf message payload.v1.Info.Memory
 */
export interface Info_Memory {
    /**
     * The memory limit.
     *
     * @generated from protobuf field: double limit = 1;
     */
    limit: number;
    /**
     * The memory requested.
     *
     * @generated from protobuf field: double request = 2;
     */
    request: number;
    /**
     * The memory usage.
     *
     * @generated from protobuf field: double usage = 3;
     */
    usage: number;
}
/**
 * Represent the multiple pod information message.
 *
 * @generated from protobuf message payload.v1.Info.Pods
 */
export interface Info_Pods {
    /**
     * The multiple pod information.
     *
     * @generated from protobuf field: repeated payload.v1.Info.Pod pods = 1;
     */
    pods: Info_Pod[];
}
/**
 * Represent the multiple node information message.
 *
 * @generated from protobuf message payload.v1.Info.Nodes
 */
export interface Info_Nodes {
    /**
     * The multiple node information.
     *
     * @generated from protobuf field: repeated payload.v1.Info.Node nodes = 1;
     */
    nodes: Info_Node[];
}
/**
 * Represent the multiple service information message.
 *
 * @generated from protobuf message payload.v1.Info.Services
 */
export interface Info_Services {
    /**
     * The multiple service information.
     *
     * @generated from protobuf field: repeated payload.v1.Info.Service services = 1;
     */
    services: Info_Service[];
}
/**
 * Represent the multiple IP message.
 *
 * @generated from protobuf message payload.v1.Info.IPs
 */
export interface Info_IPs {
    /**
     * @generated from protobuf field: repeated string ip = 1;
     */
    ip: string[];
}
/**
 * Represent an empty message.
 *
 * @generated from protobuf message payload.v1.Empty
 */
export interface Empty {
}
// @generated message type with reflection information, may provide speed optimized methods
class Search$Type extends MessageType<Search> {
    constructor() {
        super("payload.v1.Search", []);
    }
    create(value?: PartialMessage<Search>): Search {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Search>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Search): Search {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Search, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Search
 */
export const Search = new Search$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Search_Request$Type extends MessageType<Search_Request> {
    constructor() {
        super("payload.v1.Search.Request", [
            { no: 1, name: "vector", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/, options: { "buf.validate.field": { repeated: { minItems: "2" } } } },
            { no: 2, name: "config", kind: "message", T: () => Search_Config }
        ]);
    }
    create(value?: PartialMessage<Search_Request>): Search_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vector = [];
        if (value !== undefined)
            reflectionMergePartial<Search_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Search_Request): Search_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated float vector */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.vector.push(reader.float());
                    else
                        message.vector.push(reader.float());
                    break;
                case /* payload.v1.Search.Config config */ 2:
                    message.config = Search_Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Search_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated float vector = 1; */
        if (message.vector.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.vector.length; i++)
                writer.float(message.vector[i]);
            writer.join();
        }
        /* payload.v1.Search.Config config = 2; */
        if (message.config)
            Search_Config.internalBinaryWrite(message.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Search.Request
 */
export const Search_Request = new Search_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Search_MultiRequest$Type extends MessageType<Search_MultiRequest> {
    constructor() {
        super("payload.v1.Search.MultiRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Search_Request }
        ]);
    }
    create(value?: PartialMessage<Search_MultiRequest>): Search_MultiRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requests = [];
        if (value !== undefined)
            reflectionMergePartial<Search_MultiRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Search_MultiRequest): Search_MultiRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Search.Request requests */ 1:
                    message.requests.push(Search_Request.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Search_MultiRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payload.v1.Search.Request requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            Search_Request.internalBinaryWrite(message.requests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Search.MultiRequest
 */
export const Search_MultiRequest = new Search_MultiRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Search_IDRequest$Type extends MessageType<Search_IDRequest> {
    constructor() {
        super("payload.v1.Search.IDRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "config", kind: "message", T: () => Search_Config }
        ]);
    }
    create(value?: PartialMessage<Search_IDRequest>): Search_IDRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<Search_IDRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Search_IDRequest): Search_IDRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* payload.v1.Search.Config config */ 2:
                    message.config = Search_Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Search_IDRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* payload.v1.Search.Config config = 2; */
        if (message.config)
            Search_Config.internalBinaryWrite(message.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Search.IDRequest
 */
export const Search_IDRequest = new Search_IDRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Search_MultiIDRequest$Type extends MessageType<Search_MultiIDRequest> {
    constructor() {
        super("payload.v1.Search.MultiIDRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Search_IDRequest }
        ]);
    }
    create(value?: PartialMessage<Search_MultiIDRequest>): Search_MultiIDRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requests = [];
        if (value !== undefined)
            reflectionMergePartial<Search_MultiIDRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Search_MultiIDRequest): Search_MultiIDRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Search.IDRequest requests */ 1:
                    message.requests.push(Search_IDRequest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Search_MultiIDRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payload.v1.Search.IDRequest requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            Search_IDRequest.internalBinaryWrite(message.requests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Search.MultiIDRequest
 */
export const Search_MultiIDRequest = new Search_MultiIDRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Search_ObjectRequest$Type extends MessageType<Search_ObjectRequest> {
    constructor() {
        super("payload.v1.Search.ObjectRequest", [
            { no: 1, name: "object", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "config", kind: "message", T: () => Search_Config },
            { no: 3, name: "vectorizer", kind: "message", T: () => Filter_Target }
        ]);
    }
    create(value?: PartialMessage<Search_ObjectRequest>): Search_ObjectRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.object = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Search_ObjectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Search_ObjectRequest): Search_ObjectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes object */ 1:
                    message.object = reader.bytes();
                    break;
                case /* payload.v1.Search.Config config */ 2:
                    message.config = Search_Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                case /* payload.v1.Filter.Target vectorizer */ 3:
                    message.vectorizer = Filter_Target.internalBinaryRead(reader, reader.uint32(), options, message.vectorizer);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Search_ObjectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes object = 1; */
        if (message.object.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.object);
        /* payload.v1.Search.Config config = 2; */
        if (message.config)
            Search_Config.internalBinaryWrite(message.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Filter.Target vectorizer = 3; */
        if (message.vectorizer)
            Filter_Target.internalBinaryWrite(message.vectorizer, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Search.ObjectRequest
 */
export const Search_ObjectRequest = new Search_ObjectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Search_MultiObjectRequest$Type extends MessageType<Search_MultiObjectRequest> {
    constructor() {
        super("payload.v1.Search.MultiObjectRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Search_ObjectRequest }
        ]);
    }
    create(value?: PartialMessage<Search_MultiObjectRequest>): Search_MultiObjectRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requests = [];
        if (value !== undefined)
            reflectionMergePartial<Search_MultiObjectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Search_MultiObjectRequest): Search_MultiObjectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Search.ObjectRequest requests */ 1:
                    message.requests.push(Search_ObjectRequest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Search_MultiObjectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payload.v1.Search.ObjectRequest requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            Search_ObjectRequest.internalBinaryWrite(message.requests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Search.MultiObjectRequest
 */
export const Search_MultiObjectRequest = new Search_MultiObjectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Search_Config$Type extends MessageType<Search_Config> {
    constructor() {
        super("payload.v1.Search.Config", [
            { no: 1, name: "request_id", kind: "scalar", localName: "request_id", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "num", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "buf.validate.field": { uint32: { gte: 1 } } } },
            { no: 3, name: "radius", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "epsilon", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "timeout", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "ingress_filters", kind: "message", localName: "ingress_filters", T: () => Filter_Config },
            { no: 7, name: "egress_filters", kind: "message", localName: "egress_filters", T: () => Filter_Config },
            { no: 8, name: "min_num", kind: "scalar", localName: "min_num", T: 13 /*ScalarType.UINT32*/, options: { "buf.validate.field": { uint32: { gte: 0 } } } },
            { no: 9, name: "aggregation_algorithm", kind: "enum", localName: "aggregation_algorithm", T: () => ["payload.v1.Search.AggregationAlgorithm", Search_AggregationAlgorithm] }
        ]);
    }
    create(value?: PartialMessage<Search_Config>): Search_Config {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.request_id = "";
        message.num = 0;
        message.radius = 0;
        message.epsilon = 0;
        message.timeout = 0n;
        message.min_num = 0;
        message.aggregation_algorithm = 0;
        if (value !== undefined)
            reflectionMergePartial<Search_Config>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Search_Config): Search_Config {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string request_id */ 1:
                    message.request_id = reader.string();
                    break;
                case /* uint32 num */ 2:
                    message.num = reader.uint32();
                    break;
                case /* float radius */ 3:
                    message.radius = reader.float();
                    break;
                case /* float epsilon */ 4:
                    message.epsilon = reader.float();
                    break;
                case /* int64 timeout */ 5:
                    message.timeout = reader.int64().toBigInt();
                    break;
                case /* payload.v1.Filter.Config ingress_filters */ 6:
                    message.ingress_filters = Filter_Config.internalBinaryRead(reader, reader.uint32(), options, message.ingress_filters);
                    break;
                case /* payload.v1.Filter.Config egress_filters */ 7:
                    message.egress_filters = Filter_Config.internalBinaryRead(reader, reader.uint32(), options, message.egress_filters);
                    break;
                case /* uint32 min_num */ 8:
                    message.min_num = reader.uint32();
                    break;
                case /* payload.v1.Search.AggregationAlgorithm aggregation_algorithm */ 9:
                    message.aggregation_algorithm = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Search_Config, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string request_id = 1; */
        if (message.request_id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.request_id);
        /* uint32 num = 2; */
        if (message.num !== 0)
            writer.tag(2, WireType.Varint).uint32(message.num);
        /* float radius = 3; */
        if (message.radius !== 0)
            writer.tag(3, WireType.Bit32).float(message.radius);
        /* float epsilon = 4; */
        if (message.epsilon !== 0)
            writer.tag(4, WireType.Bit32).float(message.epsilon);
        /* int64 timeout = 5; */
        if (message.timeout !== 0n)
            writer.tag(5, WireType.Varint).int64(message.timeout);
        /* payload.v1.Filter.Config ingress_filters = 6; */
        if (message.ingress_filters)
            Filter_Config.internalBinaryWrite(message.ingress_filters, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Filter.Config egress_filters = 7; */
        if (message.egress_filters)
            Filter_Config.internalBinaryWrite(message.egress_filters, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* uint32 min_num = 8; */
        if (message.min_num !== 0)
            writer.tag(8, WireType.Varint).uint32(message.min_num);
        /* payload.v1.Search.AggregationAlgorithm aggregation_algorithm = 9; */
        if (message.aggregation_algorithm !== 0)
            writer.tag(9, WireType.Varint).int32(message.aggregation_algorithm);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Search.Config
 */
export const Search_Config = new Search_Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Search_Response$Type extends MessageType<Search_Response> {
    constructor() {
        super("payload.v1.Search.Response", [
            { no: 1, name: "request_id", kind: "scalar", localName: "request_id", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "results", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Object_Distance }
        ]);
    }
    create(value?: PartialMessage<Search_Response>): Search_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.request_id = "";
        message.results = [];
        if (value !== undefined)
            reflectionMergePartial<Search_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Search_Response): Search_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string request_id */ 1:
                    message.request_id = reader.string();
                    break;
                case /* repeated payload.v1.Object.Distance results */ 2:
                    message.results.push(Object_Distance.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Search_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string request_id = 1; */
        if (message.request_id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.request_id);
        /* repeated payload.v1.Object.Distance results = 2; */
        for (let i = 0; i < message.results.length; i++)
            Object_Distance.internalBinaryWrite(message.results[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Search.Response
 */
export const Search_Response = new Search_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Search_Responses$Type extends MessageType<Search_Responses> {
    constructor() {
        super("payload.v1.Search.Responses", [
            { no: 1, name: "responses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Search_Response }
        ]);
    }
    create(value?: PartialMessage<Search_Responses>): Search_Responses {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.responses = [];
        if (value !== undefined)
            reflectionMergePartial<Search_Responses>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Search_Responses): Search_Responses {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Search.Response responses */ 1:
                    message.responses.push(Search_Response.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Search_Responses, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payload.v1.Search.Response responses = 1; */
        for (let i = 0; i < message.responses.length; i++)
            Search_Response.internalBinaryWrite(message.responses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Search.Responses
 */
export const Search_Responses = new Search_Responses$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Search_StreamResponse$Type extends MessageType<Search_StreamResponse> {
    constructor() {
        super("payload.v1.Search.StreamResponse", [
            { no: 1, name: "response", kind: "message", oneof: "payload", T: () => Search_Response },
            { no: 2, name: "status", kind: "message", oneof: "payload", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<Search_StreamResponse>): Search_StreamResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Search_StreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Search_StreamResponse): Search_StreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Search.Response response */ 1:
                    message.payload = {
                        oneofKind: "response",
                        response: Search_Response.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).response)
                    };
                    break;
                case /* google.rpc.Status status */ 2:
                    message.payload = {
                        oneofKind: "status",
                        status: Status.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).status)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Search_StreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payload.v1.Search.Response response = 1; */
        if (message.payload.oneofKind === "response")
            Search_Response.internalBinaryWrite(message.payload.response, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.rpc.Status status = 2; */
        if (message.payload.oneofKind === "status")
            Status.internalBinaryWrite(message.payload.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Search.StreamResponse
 */
export const Search_StreamResponse = new Search_StreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Filter$Type extends MessageType<Filter> {
    constructor() {
        super("payload.v1.Filter", []);
    }
    create(value?: PartialMessage<Filter>): Filter {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Filter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Filter): Filter {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Filter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Filter
 */
export const Filter = new Filter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Filter_Target$Type extends MessageType<Filter_Target> {
    constructor() {
        super("payload.v1.Filter.Target", [
            { no: 1, name: "host", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Filter_Target>): Filter_Target {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.host = "";
        message.port = 0;
        if (value !== undefined)
            reflectionMergePartial<Filter_Target>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Filter_Target): Filter_Target {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string host */ 1:
                    message.host = reader.string();
                    break;
                case /* uint32 port */ 2:
                    message.port = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Filter_Target, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string host = 1; */
        if (message.host !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.host);
        /* uint32 port = 2; */
        if (message.port !== 0)
            writer.tag(2, WireType.Varint).uint32(message.port);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Filter.Target
 */
export const Filter_Target = new Filter_Target$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Filter_Config$Type extends MessageType<Filter_Config> {
    constructor() {
        super("payload.v1.Filter.Config", [
            { no: 1, name: "targets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Filter_Target }
        ]);
    }
    create(value?: PartialMessage<Filter_Config>): Filter_Config {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.targets = [];
        if (value !== undefined)
            reflectionMergePartial<Filter_Config>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Filter_Config): Filter_Config {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Filter.Target targets */ 1:
                    message.targets.push(Filter_Target.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Filter_Config, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payload.v1.Filter.Target targets = 1; */
        for (let i = 0; i < message.targets.length; i++)
            Filter_Target.internalBinaryWrite(message.targets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Filter.Config
 */
export const Filter_Config = new Filter_Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Insert$Type extends MessageType<Insert> {
    constructor() {
        super("payload.v1.Insert", []);
    }
    create(value?: PartialMessage<Insert>): Insert {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Insert>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Insert): Insert {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Insert, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Insert
 */
export const Insert = new Insert$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Insert_Request$Type extends MessageType<Insert_Request> {
    constructor() {
        super("payload.v1.Insert.Request", [
            { no: 1, name: "vector", kind: "message", T: () => Object_Vector, options: { "buf.validate.field": { repeated: { minItems: "2" } } } },
            { no: 2, name: "config", kind: "message", T: () => Insert_Config }
        ]);
    }
    create(value?: PartialMessage<Insert_Request>): Insert_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Insert_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Insert_Request): Insert_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.Vector vector */ 1:
                    message.vector = Object_Vector.internalBinaryRead(reader, reader.uint32(), options, message.vector);
                    break;
                case /* payload.v1.Insert.Config config */ 2:
                    message.config = Insert_Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Insert_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payload.v1.Object.Vector vector = 1; */
        if (message.vector)
            Object_Vector.internalBinaryWrite(message.vector, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Insert.Config config = 2; */
        if (message.config)
            Insert_Config.internalBinaryWrite(message.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Insert.Request
 */
export const Insert_Request = new Insert_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Insert_MultiRequest$Type extends MessageType<Insert_MultiRequest> {
    constructor() {
        super("payload.v1.Insert.MultiRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Insert_Request }
        ]);
    }
    create(value?: PartialMessage<Insert_MultiRequest>): Insert_MultiRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requests = [];
        if (value !== undefined)
            reflectionMergePartial<Insert_MultiRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Insert_MultiRequest): Insert_MultiRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Insert.Request requests */ 1:
                    message.requests.push(Insert_Request.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Insert_MultiRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payload.v1.Insert.Request requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            Insert_Request.internalBinaryWrite(message.requests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Insert.MultiRequest
 */
export const Insert_MultiRequest = new Insert_MultiRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Insert_ObjectRequest$Type extends MessageType<Insert_ObjectRequest> {
    constructor() {
        super("payload.v1.Insert.ObjectRequest", [
            { no: 1, name: "object", kind: "message", T: () => Object_Blob },
            { no: 2, name: "config", kind: "message", T: () => Insert_Config },
            { no: 3, name: "vectorizer", kind: "message", T: () => Filter_Target }
        ]);
    }
    create(value?: PartialMessage<Insert_ObjectRequest>): Insert_ObjectRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Insert_ObjectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Insert_ObjectRequest): Insert_ObjectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.Blob object */ 1:
                    message.object = Object_Blob.internalBinaryRead(reader, reader.uint32(), options, message.object);
                    break;
                case /* payload.v1.Insert.Config config */ 2:
                    message.config = Insert_Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                case /* payload.v1.Filter.Target vectorizer */ 3:
                    message.vectorizer = Filter_Target.internalBinaryRead(reader, reader.uint32(), options, message.vectorizer);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Insert_ObjectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payload.v1.Object.Blob object = 1; */
        if (message.object)
            Object_Blob.internalBinaryWrite(message.object, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Insert.Config config = 2; */
        if (message.config)
            Insert_Config.internalBinaryWrite(message.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Filter.Target vectorizer = 3; */
        if (message.vectorizer)
            Filter_Target.internalBinaryWrite(message.vectorizer, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Insert.ObjectRequest
 */
export const Insert_ObjectRequest = new Insert_ObjectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Insert_MultiObjectRequest$Type extends MessageType<Insert_MultiObjectRequest> {
    constructor() {
        super("payload.v1.Insert.MultiObjectRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Insert_ObjectRequest }
        ]);
    }
    create(value?: PartialMessage<Insert_MultiObjectRequest>): Insert_MultiObjectRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requests = [];
        if (value !== undefined)
            reflectionMergePartial<Insert_MultiObjectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Insert_MultiObjectRequest): Insert_MultiObjectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Insert.ObjectRequest requests */ 1:
                    message.requests.push(Insert_ObjectRequest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Insert_MultiObjectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payload.v1.Insert.ObjectRequest requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            Insert_ObjectRequest.internalBinaryWrite(message.requests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Insert.MultiObjectRequest
 */
export const Insert_MultiObjectRequest = new Insert_MultiObjectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Insert_Config$Type extends MessageType<Insert_Config> {
    constructor() {
        super("payload.v1.Insert.Config", [
            { no: 1, name: "skip_strict_exist_check", kind: "scalar", localName: "skip_strict_exist_check", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "filters", kind: "message", T: () => Filter_Config },
            { no: 3, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Insert_Config>): Insert_Config {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.skip_strict_exist_check = false;
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<Insert_Config>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Insert_Config): Insert_Config {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool skip_strict_exist_check */ 1:
                    message.skip_strict_exist_check = reader.bool();
                    break;
                case /* payload.v1.Filter.Config filters */ 2:
                    message.filters = Filter_Config.internalBinaryRead(reader, reader.uint32(), options, message.filters);
                    break;
                case /* int64 timestamp */ 3:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Insert_Config, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool skip_strict_exist_check = 1; */
        if (message.skip_strict_exist_check !== false)
            writer.tag(1, WireType.Varint).bool(message.skip_strict_exist_check);
        /* payload.v1.Filter.Config filters = 2; */
        if (message.filters)
            Filter_Config.internalBinaryWrite(message.filters, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).int64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Insert.Config
 */
export const Insert_Config = new Insert_Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Update$Type extends MessageType<Update> {
    constructor() {
        super("payload.v1.Update", []);
    }
    create(value?: PartialMessage<Update>): Update {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Update>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Update): Update {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Update, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Update
 */
export const Update = new Update$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Update_Request$Type extends MessageType<Update_Request> {
    constructor() {
        super("payload.v1.Update.Request", [
            { no: 1, name: "vector", kind: "message", T: () => Object_Vector, options: { "buf.validate.field": { repeated: { minItems: "2" } } } },
            { no: 2, name: "config", kind: "message", T: () => Update_Config }
        ]);
    }
    create(value?: PartialMessage<Update_Request>): Update_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Update_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Update_Request): Update_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.Vector vector */ 1:
                    message.vector = Object_Vector.internalBinaryRead(reader, reader.uint32(), options, message.vector);
                    break;
                case /* payload.v1.Update.Config config */ 2:
                    message.config = Update_Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Update_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payload.v1.Object.Vector vector = 1; */
        if (message.vector)
            Object_Vector.internalBinaryWrite(message.vector, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Update.Config config = 2; */
        if (message.config)
            Update_Config.internalBinaryWrite(message.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Update.Request
 */
export const Update_Request = new Update_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Update_MultiRequest$Type extends MessageType<Update_MultiRequest> {
    constructor() {
        super("payload.v1.Update.MultiRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Update_Request }
        ]);
    }
    create(value?: PartialMessage<Update_MultiRequest>): Update_MultiRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requests = [];
        if (value !== undefined)
            reflectionMergePartial<Update_MultiRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Update_MultiRequest): Update_MultiRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Update.Request requests */ 1:
                    message.requests.push(Update_Request.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Update_MultiRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payload.v1.Update.Request requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            Update_Request.internalBinaryWrite(message.requests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Update.MultiRequest
 */
export const Update_MultiRequest = new Update_MultiRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Update_ObjectRequest$Type extends MessageType<Update_ObjectRequest> {
    constructor() {
        super("payload.v1.Update.ObjectRequest", [
            { no: 1, name: "object", kind: "message", T: () => Object_Blob },
            { no: 2, name: "config", kind: "message", T: () => Update_Config },
            { no: 3, name: "vectorizer", kind: "message", T: () => Filter_Target }
        ]);
    }
    create(value?: PartialMessage<Update_ObjectRequest>): Update_ObjectRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Update_ObjectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Update_ObjectRequest): Update_ObjectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.Blob object */ 1:
                    message.object = Object_Blob.internalBinaryRead(reader, reader.uint32(), options, message.object);
                    break;
                case /* payload.v1.Update.Config config */ 2:
                    message.config = Update_Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                case /* payload.v1.Filter.Target vectorizer */ 3:
                    message.vectorizer = Filter_Target.internalBinaryRead(reader, reader.uint32(), options, message.vectorizer);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Update_ObjectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payload.v1.Object.Blob object = 1; */
        if (message.object)
            Object_Blob.internalBinaryWrite(message.object, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Update.Config config = 2; */
        if (message.config)
            Update_Config.internalBinaryWrite(message.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Filter.Target vectorizer = 3; */
        if (message.vectorizer)
            Filter_Target.internalBinaryWrite(message.vectorizer, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Update.ObjectRequest
 */
export const Update_ObjectRequest = new Update_ObjectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Update_MultiObjectRequest$Type extends MessageType<Update_MultiObjectRequest> {
    constructor() {
        super("payload.v1.Update.MultiObjectRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Update_ObjectRequest }
        ]);
    }
    create(value?: PartialMessage<Update_MultiObjectRequest>): Update_MultiObjectRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requests = [];
        if (value !== undefined)
            reflectionMergePartial<Update_MultiObjectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Update_MultiObjectRequest): Update_MultiObjectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Update.ObjectRequest requests */ 1:
                    message.requests.push(Update_ObjectRequest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Update_MultiObjectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payload.v1.Update.ObjectRequest requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            Update_ObjectRequest.internalBinaryWrite(message.requests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Update.MultiObjectRequest
 */
export const Update_MultiObjectRequest = new Update_MultiObjectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Update_Config$Type extends MessageType<Update_Config> {
    constructor() {
        super("payload.v1.Update.Config", [
            { no: 1, name: "skip_strict_exist_check", kind: "scalar", localName: "skip_strict_exist_check", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "filters", kind: "message", T: () => Filter_Config },
            { no: 3, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "disable_balanced_update", kind: "scalar", localName: "disable_balanced_update", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Update_Config>): Update_Config {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.skip_strict_exist_check = false;
        message.timestamp = 0n;
        message.disable_balanced_update = false;
        if (value !== undefined)
            reflectionMergePartial<Update_Config>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Update_Config): Update_Config {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool skip_strict_exist_check */ 1:
                    message.skip_strict_exist_check = reader.bool();
                    break;
                case /* payload.v1.Filter.Config filters */ 2:
                    message.filters = Filter_Config.internalBinaryRead(reader, reader.uint32(), options, message.filters);
                    break;
                case /* int64 timestamp */ 3:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                case /* bool disable_balanced_update */ 4:
                    message.disable_balanced_update = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Update_Config, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool skip_strict_exist_check = 1; */
        if (message.skip_strict_exist_check !== false)
            writer.tag(1, WireType.Varint).bool(message.skip_strict_exist_check);
        /* payload.v1.Filter.Config filters = 2; */
        if (message.filters)
            Filter_Config.internalBinaryWrite(message.filters, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).int64(message.timestamp);
        /* bool disable_balanced_update = 4; */
        if (message.disable_balanced_update !== false)
            writer.tag(4, WireType.Varint).bool(message.disable_balanced_update);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Update.Config
 */
export const Update_Config = new Update_Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Upsert$Type extends MessageType<Upsert> {
    constructor() {
        super("payload.v1.Upsert", []);
    }
    create(value?: PartialMessage<Upsert>): Upsert {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Upsert>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Upsert): Upsert {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Upsert, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Upsert
 */
export const Upsert = new Upsert$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Upsert_Request$Type extends MessageType<Upsert_Request> {
    constructor() {
        super("payload.v1.Upsert.Request", [
            { no: 1, name: "vector", kind: "message", T: () => Object_Vector, options: { "buf.validate.field": { repeated: { minItems: "2" } } } },
            { no: 2, name: "config", kind: "message", T: () => Upsert_Config }
        ]);
    }
    create(value?: PartialMessage<Upsert_Request>): Upsert_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Upsert_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Upsert_Request): Upsert_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.Vector vector */ 1:
                    message.vector = Object_Vector.internalBinaryRead(reader, reader.uint32(), options, message.vector);
                    break;
                case /* payload.v1.Upsert.Config config */ 2:
                    message.config = Upsert_Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Upsert_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payload.v1.Object.Vector vector = 1; */
        if (message.vector)
            Object_Vector.internalBinaryWrite(message.vector, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Upsert.Config config = 2; */
        if (message.config)
            Upsert_Config.internalBinaryWrite(message.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Upsert.Request
 */
export const Upsert_Request = new Upsert_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Upsert_MultiRequest$Type extends MessageType<Upsert_MultiRequest> {
    constructor() {
        super("payload.v1.Upsert.MultiRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Upsert_Request }
        ]);
    }
    create(value?: PartialMessage<Upsert_MultiRequest>): Upsert_MultiRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requests = [];
        if (value !== undefined)
            reflectionMergePartial<Upsert_MultiRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Upsert_MultiRequest): Upsert_MultiRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Upsert.Request requests */ 1:
                    message.requests.push(Upsert_Request.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Upsert_MultiRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payload.v1.Upsert.Request requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            Upsert_Request.internalBinaryWrite(message.requests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Upsert.MultiRequest
 */
export const Upsert_MultiRequest = new Upsert_MultiRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Upsert_ObjectRequest$Type extends MessageType<Upsert_ObjectRequest> {
    constructor() {
        super("payload.v1.Upsert.ObjectRequest", [
            { no: 1, name: "object", kind: "message", T: () => Object_Blob },
            { no: 2, name: "config", kind: "message", T: () => Upsert_Config },
            { no: 3, name: "vectorizer", kind: "message", T: () => Filter_Target }
        ]);
    }
    create(value?: PartialMessage<Upsert_ObjectRequest>): Upsert_ObjectRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Upsert_ObjectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Upsert_ObjectRequest): Upsert_ObjectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.Blob object */ 1:
                    message.object = Object_Blob.internalBinaryRead(reader, reader.uint32(), options, message.object);
                    break;
                case /* payload.v1.Upsert.Config config */ 2:
                    message.config = Upsert_Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                case /* payload.v1.Filter.Target vectorizer */ 3:
                    message.vectorizer = Filter_Target.internalBinaryRead(reader, reader.uint32(), options, message.vectorizer);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Upsert_ObjectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payload.v1.Object.Blob object = 1; */
        if (message.object)
            Object_Blob.internalBinaryWrite(message.object, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Upsert.Config config = 2; */
        if (message.config)
            Upsert_Config.internalBinaryWrite(message.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Filter.Target vectorizer = 3; */
        if (message.vectorizer)
            Filter_Target.internalBinaryWrite(message.vectorizer, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Upsert.ObjectRequest
 */
export const Upsert_ObjectRequest = new Upsert_ObjectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Upsert_MultiObjectRequest$Type extends MessageType<Upsert_MultiObjectRequest> {
    constructor() {
        super("payload.v1.Upsert.MultiObjectRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Upsert_ObjectRequest }
        ]);
    }
    create(value?: PartialMessage<Upsert_MultiObjectRequest>): Upsert_MultiObjectRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requests = [];
        if (value !== undefined)
            reflectionMergePartial<Upsert_MultiObjectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Upsert_MultiObjectRequest): Upsert_MultiObjectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Upsert.ObjectRequest requests */ 1:
                    message.requests.push(Upsert_ObjectRequest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Upsert_MultiObjectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payload.v1.Upsert.ObjectRequest requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            Upsert_ObjectRequest.internalBinaryWrite(message.requests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Upsert.MultiObjectRequest
 */
export const Upsert_MultiObjectRequest = new Upsert_MultiObjectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Upsert_Config$Type extends MessageType<Upsert_Config> {
    constructor() {
        super("payload.v1.Upsert.Config", [
            { no: 1, name: "skip_strict_exist_check", kind: "scalar", localName: "skip_strict_exist_check", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "filters", kind: "message", T: () => Filter_Config },
            { no: 3, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "disable_balanced_update", kind: "scalar", localName: "disable_balanced_update", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Upsert_Config>): Upsert_Config {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.skip_strict_exist_check = false;
        message.timestamp = 0n;
        message.disable_balanced_update = false;
        if (value !== undefined)
            reflectionMergePartial<Upsert_Config>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Upsert_Config): Upsert_Config {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool skip_strict_exist_check */ 1:
                    message.skip_strict_exist_check = reader.bool();
                    break;
                case /* payload.v1.Filter.Config filters */ 2:
                    message.filters = Filter_Config.internalBinaryRead(reader, reader.uint32(), options, message.filters);
                    break;
                case /* int64 timestamp */ 3:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                case /* bool disable_balanced_update */ 4:
                    message.disable_balanced_update = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Upsert_Config, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool skip_strict_exist_check = 1; */
        if (message.skip_strict_exist_check !== false)
            writer.tag(1, WireType.Varint).bool(message.skip_strict_exist_check);
        /* payload.v1.Filter.Config filters = 2; */
        if (message.filters)
            Filter_Config.internalBinaryWrite(message.filters, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).int64(message.timestamp);
        /* bool disable_balanced_update = 4; */
        if (message.disable_balanced_update !== false)
            writer.tag(4, WireType.Varint).bool(message.disable_balanced_update);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Upsert.Config
 */
export const Upsert_Config = new Upsert_Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Remove$Type extends MessageType<Remove> {
    constructor() {
        super("payload.v1.Remove", []);
    }
    create(value?: PartialMessage<Remove>): Remove {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Remove>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Remove): Remove {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Remove, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Remove
 */
export const Remove = new Remove$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Remove_Request$Type extends MessageType<Remove_Request> {
    constructor() {
        super("payload.v1.Remove.Request", [
            { no: 1, name: "id", kind: "message", T: () => Object_ID },
            { no: 2, name: "config", kind: "message", T: () => Remove_Config }
        ]);
    }
    create(value?: PartialMessage<Remove_Request>): Remove_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Remove_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Remove_Request): Remove_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.ID id */ 1:
                    message.id = Object_ID.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* payload.v1.Remove.Config config */ 2:
                    message.config = Remove_Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Remove_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payload.v1.Object.ID id = 1; */
        if (message.id)
            Object_ID.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Remove.Config config = 2; */
        if (message.config)
            Remove_Config.internalBinaryWrite(message.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Remove.Request
 */
export const Remove_Request = new Remove_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Remove_MultiRequest$Type extends MessageType<Remove_MultiRequest> {
    constructor() {
        super("payload.v1.Remove.MultiRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Remove_Request }
        ]);
    }
    create(value?: PartialMessage<Remove_MultiRequest>): Remove_MultiRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requests = [];
        if (value !== undefined)
            reflectionMergePartial<Remove_MultiRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Remove_MultiRequest): Remove_MultiRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Remove.Request requests */ 1:
                    message.requests.push(Remove_Request.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Remove_MultiRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payload.v1.Remove.Request requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            Remove_Request.internalBinaryWrite(message.requests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Remove.MultiRequest
 */
export const Remove_MultiRequest = new Remove_MultiRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Remove_TimestampRequest$Type extends MessageType<Remove_TimestampRequest> {
    constructor() {
        super("payload.v1.Remove.TimestampRequest", [
            { no: 1, name: "timestamps", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Remove_Timestamp }
        ]);
    }
    create(value?: PartialMessage<Remove_TimestampRequest>): Remove_TimestampRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timestamps = [];
        if (value !== undefined)
            reflectionMergePartial<Remove_TimestampRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Remove_TimestampRequest): Remove_TimestampRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Remove.Timestamp timestamps */ 1:
                    message.timestamps.push(Remove_Timestamp.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Remove_TimestampRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payload.v1.Remove.Timestamp timestamps = 1; */
        for (let i = 0; i < message.timestamps.length; i++)
            Remove_Timestamp.internalBinaryWrite(message.timestamps[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Remove.TimestampRequest
 */
export const Remove_TimestampRequest = new Remove_TimestampRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Remove_Timestamp$Type extends MessageType<Remove_Timestamp> {
    constructor() {
        super("payload.v1.Remove.Timestamp", [
            { no: 1, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "operator", kind: "enum", T: () => ["payload.v1.Remove.Timestamp.Operator", Remove_Timestamp_Operator] }
        ]);
    }
    create(value?: PartialMessage<Remove_Timestamp>): Remove_Timestamp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timestamp = 0n;
        message.operator = 0;
        if (value !== undefined)
            reflectionMergePartial<Remove_Timestamp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Remove_Timestamp): Remove_Timestamp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 timestamp */ 1:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                case /* payload.v1.Remove.Timestamp.Operator operator */ 2:
                    message.operator = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Remove_Timestamp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 timestamp = 1; */
        if (message.timestamp !== 0n)
            writer.tag(1, WireType.Varint).int64(message.timestamp);
        /* payload.v1.Remove.Timestamp.Operator operator = 2; */
        if (message.operator !== 0)
            writer.tag(2, WireType.Varint).int32(message.operator);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Remove.Timestamp
 */
export const Remove_Timestamp = new Remove_Timestamp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Remove_Config$Type extends MessageType<Remove_Config> {
    constructor() {
        super("payload.v1.Remove.Config", [
            { no: 1, name: "skip_strict_exist_check", kind: "scalar", localName: "skip_strict_exist_check", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Remove_Config>): Remove_Config {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.skip_strict_exist_check = false;
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<Remove_Config>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Remove_Config): Remove_Config {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool skip_strict_exist_check */ 1:
                    message.skip_strict_exist_check = reader.bool();
                    break;
                case /* int64 timestamp */ 3:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Remove_Config, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool skip_strict_exist_check = 1; */
        if (message.skip_strict_exist_check !== false)
            writer.tag(1, WireType.Varint).bool(message.skip_strict_exist_check);
        /* int64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).int64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Remove.Config
 */
export const Remove_Config = new Remove_Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object$Type extends MessageType<Object> {
    constructor() {
        super("payload.v1.Object", []);
    }
    create(value?: PartialMessage<Object>): Object {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Object>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object): Object {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Object, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object
 */
export const Object = new Object$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_VectorRequest$Type extends MessageType<Object_VectorRequest> {
    constructor() {
        super("payload.v1.Object.VectorRequest", [
            { no: 1, name: "id", kind: "message", T: () => Object_ID, options: { "buf.validate.field": { repeated: { minItems: "2" } } } },
            { no: 2, name: "filters", kind: "message", T: () => Filter_Config }
        ]);
    }
    create(value?: PartialMessage<Object_VectorRequest>): Object_VectorRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Object_VectorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object_VectorRequest): Object_VectorRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.ID id */ 1:
                    message.id = Object_ID.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* payload.v1.Filter.Config filters */ 2:
                    message.filters = Filter_Config.internalBinaryRead(reader, reader.uint32(), options, message.filters);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Object_VectorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payload.v1.Object.ID id = 1; */
        if (message.id)
            Object_ID.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Filter.Config filters = 2; */
        if (message.filters)
            Filter_Config.internalBinaryWrite(message.filters, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.VectorRequest
 */
export const Object_VectorRequest = new Object_VectorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_Distance$Type extends MessageType<Object_Distance> {
    constructor() {
        super("payload.v1.Object.Distance", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "distance", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Object_Distance>): Object_Distance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.distance = 0;
        if (value !== undefined)
            reflectionMergePartial<Object_Distance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object_Distance): Object_Distance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* float distance */ 2:
                    message.distance = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Object_Distance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* float distance = 2; */
        if (message.distance !== 0)
            writer.tag(2, WireType.Bit32).float(message.distance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.Distance
 */
export const Object_Distance = new Object_Distance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_StreamDistance$Type extends MessageType<Object_StreamDistance> {
    constructor() {
        super("payload.v1.Object.StreamDistance", [
            { no: 1, name: "distance", kind: "message", oneof: "payload", T: () => Object_Distance },
            { no: 2, name: "status", kind: "message", oneof: "payload", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<Object_StreamDistance>): Object_StreamDistance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Object_StreamDistance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object_StreamDistance): Object_StreamDistance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.Distance distance */ 1:
                    message.payload = {
                        oneofKind: "distance",
                        distance: Object_Distance.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).distance)
                    };
                    break;
                case /* google.rpc.Status status */ 2:
                    message.payload = {
                        oneofKind: "status",
                        status: Status.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).status)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Object_StreamDistance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payload.v1.Object.Distance distance = 1; */
        if (message.payload.oneofKind === "distance")
            Object_Distance.internalBinaryWrite(message.payload.distance, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.rpc.Status status = 2; */
        if (message.payload.oneofKind === "status")
            Status.internalBinaryWrite(message.payload.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.StreamDistance
 */
export const Object_StreamDistance = new Object_StreamDistance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_ID$Type extends MessageType<Object_ID> {
    constructor() {
        super("payload.v1.Object.ID", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<Object_ID>): Object_ID {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<Object_ID>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object_ID): Object_ID {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Object_ID, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.ID
 */
export const Object_ID = new Object_ID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_IDs$Type extends MessageType<Object_IDs> {
    constructor() {
        super("payload.v1.Object.IDs", [
            { no: 1, name: "ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Object_IDs>): Object_IDs {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ids = [];
        if (value !== undefined)
            reflectionMergePartial<Object_IDs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object_IDs): Object_IDs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string ids */ 1:
                    message.ids.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Object_IDs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string ids = 1; */
        for (let i = 0; i < message.ids.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.IDs
 */
export const Object_IDs = new Object_IDs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_Vector$Type extends MessageType<Object_Vector> {
    constructor() {
        super("payload.v1.Object.Vector", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1" } } } },
            { no: 2, name: "vector", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/, options: { "buf.validate.field": { repeated: { minItems: "2" } } } },
            { no: 3, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Object_Vector>): Object_Vector {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.vector = [];
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<Object_Vector>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object_Vector): Object_Vector {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* repeated float vector */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.vector.push(reader.float());
                    else
                        message.vector.push(reader.float());
                    break;
                case /* int64 timestamp */ 3:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Object_Vector, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* repeated float vector = 2; */
        if (message.vector.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.vector.length; i++)
                writer.float(message.vector[i]);
            writer.join();
        }
        /* int64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, WireType.Varint).int64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.Vector
 */
export const Object_Vector = new Object_Vector$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_GetTimestampRequest$Type extends MessageType<Object_GetTimestampRequest> {
    constructor() {
        super("payload.v1.Object.GetTimestampRequest", [
            { no: 1, name: "id", kind: "message", T: () => Object_ID, options: { "buf.validate.field": { repeated: { minItems: "2" } } } }
        ]);
    }
    create(value?: PartialMessage<Object_GetTimestampRequest>): Object_GetTimestampRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Object_GetTimestampRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object_GetTimestampRequest): Object_GetTimestampRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.ID id */ 1:
                    message.id = Object_ID.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Object_GetTimestampRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payload.v1.Object.ID id = 1; */
        if (message.id)
            Object_ID.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.GetTimestampRequest
 */
export const Object_GetTimestampRequest = new Object_GetTimestampRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_Timestamp$Type extends MessageType<Object_Timestamp> {
    constructor() {
        super("payload.v1.Object.Timestamp", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1" } } } },
            { no: 2, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Object_Timestamp>): Object_Timestamp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<Object_Timestamp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object_Timestamp): Object_Timestamp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* int64 timestamp */ 2:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Object_Timestamp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* int64 timestamp = 2; */
        if (message.timestamp !== 0n)
            writer.tag(2, WireType.Varint).int64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.Timestamp
 */
export const Object_Timestamp = new Object_Timestamp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_Vectors$Type extends MessageType<Object_Vectors> {
    constructor() {
        super("payload.v1.Object.Vectors", [
            { no: 1, name: "vectors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Object_Vector }
        ]);
    }
    create(value?: PartialMessage<Object_Vectors>): Object_Vectors {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vectors = [];
        if (value !== undefined)
            reflectionMergePartial<Object_Vectors>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object_Vectors): Object_Vectors {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Object.Vector vectors */ 1:
                    message.vectors.push(Object_Vector.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Object_Vectors, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payload.v1.Object.Vector vectors = 1; */
        for (let i = 0; i < message.vectors.length; i++)
            Object_Vector.internalBinaryWrite(message.vectors[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.Vectors
 */
export const Object_Vectors = new Object_Vectors$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_StreamVector$Type extends MessageType<Object_StreamVector> {
    constructor() {
        super("payload.v1.Object.StreamVector", [
            { no: 1, name: "vector", kind: "message", oneof: "payload", T: () => Object_Vector },
            { no: 2, name: "status", kind: "message", oneof: "payload", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<Object_StreamVector>): Object_StreamVector {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Object_StreamVector>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object_StreamVector): Object_StreamVector {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.Vector vector */ 1:
                    message.payload = {
                        oneofKind: "vector",
                        vector: Object_Vector.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).vector)
                    };
                    break;
                case /* google.rpc.Status status */ 2:
                    message.payload = {
                        oneofKind: "status",
                        status: Status.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).status)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Object_StreamVector, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payload.v1.Object.Vector vector = 1; */
        if (message.payload.oneofKind === "vector")
            Object_Vector.internalBinaryWrite(message.payload.vector, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.rpc.Status status = 2; */
        if (message.payload.oneofKind === "status")
            Status.internalBinaryWrite(message.payload.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.StreamVector
 */
export const Object_StreamVector = new Object_StreamVector$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_ReshapeVector$Type extends MessageType<Object_ReshapeVector> {
    constructor() {
        super("payload.v1.Object.ReshapeVector", [
            { no: 1, name: "object", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "shape", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Object_ReshapeVector>): Object_ReshapeVector {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.object = new Uint8Array(0);
        message.shape = [];
        if (value !== undefined)
            reflectionMergePartial<Object_ReshapeVector>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object_ReshapeVector): Object_ReshapeVector {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes object */ 1:
                    message.object = reader.bytes();
                    break;
                case /* repeated int32 shape */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.shape.push(reader.int32());
                    else
                        message.shape.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Object_ReshapeVector, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes object = 1; */
        if (message.object.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.object);
        /* repeated int32 shape = 2; */
        if (message.shape.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.shape.length; i++)
                writer.int32(message.shape[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.ReshapeVector
 */
export const Object_ReshapeVector = new Object_ReshapeVector$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_Blob$Type extends MessageType<Object_Blob> {
    constructor() {
        super("payload.v1.Object.Blob", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1" } } } },
            { no: 2, name: "object", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Object_Blob>): Object_Blob {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.object = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Object_Blob>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object_Blob): Object_Blob {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* bytes object */ 2:
                    message.object = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Object_Blob, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* bytes object = 2; */
        if (message.object.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.object);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.Blob
 */
export const Object_Blob = new Object_Blob$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_StreamBlob$Type extends MessageType<Object_StreamBlob> {
    constructor() {
        super("payload.v1.Object.StreamBlob", [
            { no: 1, name: "blob", kind: "message", oneof: "payload", T: () => Object_Blob },
            { no: 2, name: "status", kind: "message", oneof: "payload", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<Object_StreamBlob>): Object_StreamBlob {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Object_StreamBlob>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object_StreamBlob): Object_StreamBlob {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.Blob blob */ 1:
                    message.payload = {
                        oneofKind: "blob",
                        blob: Object_Blob.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).blob)
                    };
                    break;
                case /* google.rpc.Status status */ 2:
                    message.payload = {
                        oneofKind: "status",
                        status: Status.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).status)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Object_StreamBlob, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payload.v1.Object.Blob blob = 1; */
        if (message.payload.oneofKind === "blob")
            Object_Blob.internalBinaryWrite(message.payload.blob, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.rpc.Status status = 2; */
        if (message.payload.oneofKind === "status")
            Status.internalBinaryWrite(message.payload.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.StreamBlob
 */
export const Object_StreamBlob = new Object_StreamBlob$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_Location$Type extends MessageType<Object_Location> {
    constructor() {
        super("payload.v1.Object.Location", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ips", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Object_Location>): Object_Location {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.uuid = "";
        message.ips = [];
        if (value !== undefined)
            reflectionMergePartial<Object_Location>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object_Location): Object_Location {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string uuid */ 2:
                    message.uuid = reader.string();
                    break;
                case /* repeated string ips */ 3:
                    message.ips.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Object_Location, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string uuid = 2; */
        if (message.uuid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uuid);
        /* repeated string ips = 3; */
        for (let i = 0; i < message.ips.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.ips[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.Location
 */
export const Object_Location = new Object_Location$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_StreamLocation$Type extends MessageType<Object_StreamLocation> {
    constructor() {
        super("payload.v1.Object.StreamLocation", [
            { no: 1, name: "location", kind: "message", oneof: "payload", T: () => Object_Location },
            { no: 2, name: "status", kind: "message", oneof: "payload", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<Object_StreamLocation>): Object_StreamLocation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Object_StreamLocation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object_StreamLocation): Object_StreamLocation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.Location location */ 1:
                    message.payload = {
                        oneofKind: "location",
                        location: Object_Location.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).location)
                    };
                    break;
                case /* google.rpc.Status status */ 2:
                    message.payload = {
                        oneofKind: "status",
                        status: Status.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).status)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Object_StreamLocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payload.v1.Object.Location location = 1; */
        if (message.payload.oneofKind === "location")
            Object_Location.internalBinaryWrite(message.payload.location, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.rpc.Status status = 2; */
        if (message.payload.oneofKind === "status")
            Status.internalBinaryWrite(message.payload.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.StreamLocation
 */
export const Object_StreamLocation = new Object_StreamLocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_Locations$Type extends MessageType<Object_Locations> {
    constructor() {
        super("payload.v1.Object.Locations", [
            { no: 1, name: "locations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Object_Location }
        ]);
    }
    create(value?: PartialMessage<Object_Locations>): Object_Locations {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.locations = [];
        if (value !== undefined)
            reflectionMergePartial<Object_Locations>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object_Locations): Object_Locations {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Object.Location locations */ 1:
                    message.locations.push(Object_Location.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Object_Locations, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payload.v1.Object.Location locations = 1; */
        for (let i = 0; i < message.locations.length; i++)
            Object_Location.internalBinaryWrite(message.locations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.Locations
 */
export const Object_Locations = new Object_Locations$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_List$Type extends MessageType<Object_List> {
    constructor() {
        super("payload.v1.Object.List", []);
    }
    create(value?: PartialMessage<Object_List>): Object_List {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Object_List>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object_List): Object_List {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Object_List, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.List
 */
export const Object_List = new Object_List$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_List_Request$Type extends MessageType<Object_List_Request> {
    constructor() {
        super("payload.v1.Object.List.Request", []);
    }
    create(value?: PartialMessage<Object_List_Request>): Object_List_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Object_List_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object_List_Request): Object_List_Request {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Object_List_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.List.Request
 */
export const Object_List_Request = new Object_List_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_List_Response$Type extends MessageType<Object_List_Response> {
    constructor() {
        super("payload.v1.Object.List.Response", [
            { no: 1, name: "vector", kind: "message", oneof: "payload", T: () => Object_Vector },
            { no: 2, name: "status", kind: "message", oneof: "payload", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<Object_List_Response>): Object_List_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Object_List_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object_List_Response): Object_List_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.Vector vector */ 1:
                    message.payload = {
                        oneofKind: "vector",
                        vector: Object_Vector.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).vector)
                    };
                    break;
                case /* google.rpc.Status status */ 2:
                    message.payload = {
                        oneofKind: "status",
                        status: Status.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).status)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Object_List_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* payload.v1.Object.Vector vector = 1; */
        if (message.payload.oneofKind === "vector")
            Object_Vector.internalBinaryWrite(message.payload.vector, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.rpc.Status status = 2; */
        if (message.payload.oneofKind === "status")
            Status.internalBinaryWrite(message.payload.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.List.Response
 */
export const Object_List_Response = new Object_List_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Control$Type extends MessageType<Control> {
    constructor() {
        super("payload.v1.Control", []);
    }
    create(value?: PartialMessage<Control>): Control {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Control>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Control): Control {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Control, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Control
 */
export const Control = new Control$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Control_CreateIndexRequest$Type extends MessageType<Control_CreateIndexRequest> {
    constructor() {
        super("payload.v1.Control.CreateIndexRequest", [
            { no: 1, name: "pool_size", kind: "scalar", localName: "pool_size", T: 13 /*ScalarType.UINT32*/, options: { "buf.validate.field": { uint32: { gte: 0 } } } }
        ]);
    }
    create(value?: PartialMessage<Control_CreateIndexRequest>): Control_CreateIndexRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pool_size = 0;
        if (value !== undefined)
            reflectionMergePartial<Control_CreateIndexRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Control_CreateIndexRequest): Control_CreateIndexRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 pool_size */ 1:
                    message.pool_size = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Control_CreateIndexRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 pool_size = 1; */
        if (message.pool_size !== 0)
            writer.tag(1, WireType.Varint).uint32(message.pool_size);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Control.CreateIndexRequest
 */
export const Control_CreateIndexRequest = new Control_CreateIndexRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Discoverer$Type extends MessageType<Discoverer> {
    constructor() {
        super("payload.v1.Discoverer", []);
    }
    create(value?: PartialMessage<Discoverer>): Discoverer {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Discoverer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Discoverer): Discoverer {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Discoverer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Discoverer
 */
export const Discoverer = new Discoverer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Discoverer_Request$Type extends MessageType<Discoverer_Request> {
    constructor() {
        super("payload.v1.Discoverer.Request", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1" } } } },
            { no: 2, name: "namespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "node", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Discoverer_Request>): Discoverer_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.namespace = "";
        message.node = "";
        if (value !== undefined)
            reflectionMergePartial<Discoverer_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Discoverer_Request): Discoverer_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string namespace */ 2:
                    message.namespace = reader.string();
                    break;
                case /* string node */ 3:
                    message.node = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Discoverer_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string namespace = 2; */
        if (message.namespace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.namespace);
        /* string node = 3; */
        if (message.node !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.node);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Discoverer.Request
 */
export const Discoverer_Request = new Discoverer_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info$Type extends MessageType<Info> {
    constructor() {
        super("payload.v1.Info", []);
    }
    create(value?: PartialMessage<Info>): Info {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Info>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Info): Info {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Info, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info
 */
export const Info = new Info$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Index$Type extends MessageType<Info_Index> {
    constructor() {
        super("payload.v1.Info.Index", []);
    }
    create(value?: PartialMessage<Info_Index>): Info_Index {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Info_Index>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Info_Index): Info_Index {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Info_Index, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Index
 */
export const Info_Index = new Info_Index$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Index_Count$Type extends MessageType<Info_Index_Count> {
    constructor() {
        super("payload.v1.Info.Index.Count", [
            { no: 1, name: "stored", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "uncommitted", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "indexing", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "saving", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Info_Index_Count>): Info_Index_Count {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stored = 0;
        message.uncommitted = 0;
        message.indexing = false;
        message.saving = false;
        if (value !== undefined)
            reflectionMergePartial<Info_Index_Count>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Info_Index_Count): Info_Index_Count {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 stored */ 1:
                    message.stored = reader.uint32();
                    break;
                case /* uint32 uncommitted */ 2:
                    message.uncommitted = reader.uint32();
                    break;
                case /* bool indexing */ 3:
                    message.indexing = reader.bool();
                    break;
                case /* bool saving */ 4:
                    message.saving = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Info_Index_Count, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 stored = 1; */
        if (message.stored !== 0)
            writer.tag(1, WireType.Varint).uint32(message.stored);
        /* uint32 uncommitted = 2; */
        if (message.uncommitted !== 0)
            writer.tag(2, WireType.Varint).uint32(message.uncommitted);
        /* bool indexing = 3; */
        if (message.indexing !== false)
            writer.tag(3, WireType.Varint).bool(message.indexing);
        /* bool saving = 4; */
        if (message.saving !== false)
            writer.tag(4, WireType.Varint).bool(message.saving);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Index.Count
 */
export const Info_Index_Count = new Info_Index_Count$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Index_UUID$Type extends MessageType<Info_Index_UUID> {
    constructor() {
        super("payload.v1.Info.Index.UUID", []);
    }
    create(value?: PartialMessage<Info_Index_UUID>): Info_Index_UUID {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Info_Index_UUID>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Info_Index_UUID): Info_Index_UUID {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Info_Index_UUID, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Index.UUID
 */
export const Info_Index_UUID = new Info_Index_UUID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Index_UUID_Committed$Type extends MessageType<Info_Index_UUID_Committed> {
    constructor() {
        super("payload.v1.Info.Index.UUID.Committed", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Info_Index_UUID_Committed>): Info_Index_UUID_Committed {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<Info_Index_UUID_Committed>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Info_Index_UUID_Committed): Info_Index_UUID_Committed {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Info_Index_UUID_Committed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Index.UUID.Committed
 */
export const Info_Index_UUID_Committed = new Info_Index_UUID_Committed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Index_UUID_Uncommitted$Type extends MessageType<Info_Index_UUID_Uncommitted> {
    constructor() {
        super("payload.v1.Info.Index.UUID.Uncommitted", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Info_Index_UUID_Uncommitted>): Info_Index_UUID_Uncommitted {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<Info_Index_UUID_Uncommitted>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Info_Index_UUID_Uncommitted): Info_Index_UUID_Uncommitted {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Info_Index_UUID_Uncommitted, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Index.UUID.Uncommitted
 */
export const Info_Index_UUID_Uncommitted = new Info_Index_UUID_Uncommitted$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Pod$Type extends MessageType<Info_Pod> {
    constructor() {
        super("payload.v1.Info.Pod", [
            { no: 1, name: "app_name", kind: "scalar", localName: "app_name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "namespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ip", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { ipv4: true } } } },
            { no: 5, name: "cpu", kind: "message", T: () => Info_CPU },
            { no: 6, name: "memory", kind: "message", T: () => Info_Memory },
            { no: 7, name: "node", kind: "message", T: () => Info_Node }
        ]);
    }
    create(value?: PartialMessage<Info_Pod>): Info_Pod {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.app_name = "";
        message.name = "";
        message.namespace = "";
        message.ip = "";
        if (value !== undefined)
            reflectionMergePartial<Info_Pod>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Info_Pod): Info_Pod {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string app_name */ 1:
                    message.app_name = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string namespace */ 3:
                    message.namespace = reader.string();
                    break;
                case /* string ip */ 4:
                    message.ip = reader.string();
                    break;
                case /* payload.v1.Info.CPU cpu */ 5:
                    message.cpu = Info_CPU.internalBinaryRead(reader, reader.uint32(), options, message.cpu);
                    break;
                case /* payload.v1.Info.Memory memory */ 6:
                    message.memory = Info_Memory.internalBinaryRead(reader, reader.uint32(), options, message.memory);
                    break;
                case /* payload.v1.Info.Node node */ 7:
                    message.node = Info_Node.internalBinaryRead(reader, reader.uint32(), options, message.node);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Info_Pod, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string app_name = 1; */
        if (message.app_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.app_name);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string namespace = 3; */
        if (message.namespace !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.namespace);
        /* string ip = 4; */
        if (message.ip !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.ip);
        /* payload.v1.Info.CPU cpu = 5; */
        if (message.cpu)
            Info_CPU.internalBinaryWrite(message.cpu, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Info.Memory memory = 6; */
        if (message.memory)
            Info_Memory.internalBinaryWrite(message.memory, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Info.Node node = 7; */
        if (message.node)
            Info_Node.internalBinaryWrite(message.node, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Pod
 */
export const Info_Pod = new Info_Pod$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Node$Type extends MessageType<Info_Node> {
    constructor() {
        super("payload.v1.Info.Node", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "internal_addr", kind: "scalar", localName: "internal_addr", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "external_addr", kind: "scalar", localName: "external_addr", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "cpu", kind: "message", T: () => Info_CPU },
            { no: 5, name: "memory", kind: "message", T: () => Info_Memory },
            { no: 6, name: "Pods", kind: "message", localName: "Pods", jsonName: "Pods", T: () => Info_Pods }
        ]);
    }
    create(value?: PartialMessage<Info_Node>): Info_Node {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.internal_addr = "";
        message.external_addr = "";
        if (value !== undefined)
            reflectionMergePartial<Info_Node>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Info_Node): Info_Node {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string internal_addr */ 2:
                    message.internal_addr = reader.string();
                    break;
                case /* string external_addr */ 3:
                    message.external_addr = reader.string();
                    break;
                case /* payload.v1.Info.CPU cpu */ 4:
                    message.cpu = Info_CPU.internalBinaryRead(reader, reader.uint32(), options, message.cpu);
                    break;
                case /* payload.v1.Info.Memory memory */ 5:
                    message.memory = Info_Memory.internalBinaryRead(reader, reader.uint32(), options, message.memory);
                    break;
                case /* payload.v1.Info.Pods Pods = 6 [json_name = "Pods"];*/ 6:
                    message.Pods = Info_Pods.internalBinaryRead(reader, reader.uint32(), options, message.Pods);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Info_Node, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string internal_addr = 2; */
        if (message.internal_addr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.internal_addr);
        /* string external_addr = 3; */
        if (message.external_addr !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.external_addr);
        /* payload.v1.Info.CPU cpu = 4; */
        if (message.cpu)
            Info_CPU.internalBinaryWrite(message.cpu, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Info.Memory memory = 5; */
        if (message.memory)
            Info_Memory.internalBinaryWrite(message.memory, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Info.Pods Pods = 6 [json_name = "Pods"]; */
        if (message.Pods)
            Info_Pods.internalBinaryWrite(message.Pods, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Node
 */
export const Info_Node = new Info_Node$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Service$Type extends MessageType<Info_Service> {
    constructor() {
        super("payload.v1.Info.Service", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cluster_ip", kind: "scalar", localName: "cluster_ip", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "cluster_ips", kind: "scalar", localName: "cluster_ips", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ports", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Info_ServicePort },
            { no: 5, name: "labels", kind: "message", T: () => Info_Labels },
            { no: 6, name: "annotations", kind: "message", T: () => Info_Annotations }
        ]);
    }
    create(value?: PartialMessage<Info_Service>): Info_Service {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.cluster_ip = "";
        message.cluster_ips = [];
        message.ports = [];
        if (value !== undefined)
            reflectionMergePartial<Info_Service>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Info_Service): Info_Service {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string cluster_ip */ 2:
                    message.cluster_ip = reader.string();
                    break;
                case /* repeated string cluster_ips */ 3:
                    message.cluster_ips.push(reader.string());
                    break;
                case /* repeated payload.v1.Info.ServicePort ports */ 4:
                    message.ports.push(Info_ServicePort.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* payload.v1.Info.Labels labels */ 5:
                    message.labels = Info_Labels.internalBinaryRead(reader, reader.uint32(), options, message.labels);
                    break;
                case /* payload.v1.Info.Annotations annotations */ 6:
                    message.annotations = Info_Annotations.internalBinaryRead(reader, reader.uint32(), options, message.annotations);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Info_Service, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string cluster_ip = 2; */
        if (message.cluster_ip !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cluster_ip);
        /* repeated string cluster_ips = 3; */
        for (let i = 0; i < message.cluster_ips.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.cluster_ips[i]);
        /* repeated payload.v1.Info.ServicePort ports = 4; */
        for (let i = 0; i < message.ports.length; i++)
            Info_ServicePort.internalBinaryWrite(message.ports[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Info.Labels labels = 5; */
        if (message.labels)
            Info_Labels.internalBinaryWrite(message.labels, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Info.Annotations annotations = 6; */
        if (message.annotations)
            Info_Annotations.internalBinaryWrite(message.annotations, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Service
 */
export const Info_Service = new Info_Service$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_ServicePort$Type extends MessageType<Info_ServicePort> {
    constructor() {
        super("payload.v1.Info.ServicePort", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Info_ServicePort>): Info_ServicePort {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.port = 0;
        if (value !== undefined)
            reflectionMergePartial<Info_ServicePort>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Info_ServicePort): Info_ServicePort {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 port */ 2:
                    message.port = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Info_ServicePort, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int32 port = 2; */
        if (message.port !== 0)
            writer.tag(2, WireType.Varint).int32(message.port);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.ServicePort
 */
export const Info_ServicePort = new Info_ServicePort$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Labels$Type extends MessageType<Info_Labels> {
    constructor() {
        super("payload.v1.Info.Labels", [
            { no: 1, name: "labels", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<Info_Labels>): Info_Labels {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.labels = {};
        if (value !== undefined)
            reflectionMergePartial<Info_Labels>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Info_Labels): Info_Labels {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> labels */ 1:
                    this.binaryReadMap1(message.labels, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: Info_Labels["labels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Info_Labels["labels"] | undefined, val: Info_Labels["labels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field payload.v1.Info.Labels.labels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Info_Labels, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> labels = 1; */
        for (let k of globalThis.Object.keys(message.labels))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.labels[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Labels
 */
export const Info_Labels = new Info_Labels$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Annotations$Type extends MessageType<Info_Annotations> {
    constructor() {
        super("payload.v1.Info.Annotations", [
            { no: 1, name: "annotations", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<Info_Annotations>): Info_Annotations {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.annotations = {};
        if (value !== undefined)
            reflectionMergePartial<Info_Annotations>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Info_Annotations): Info_Annotations {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> annotations */ 1:
                    this.binaryReadMap1(message.annotations, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: Info_Annotations["annotations"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Info_Annotations["annotations"] | undefined, val: Info_Annotations["annotations"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field payload.v1.Info.Annotations.annotations");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Info_Annotations, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> annotations = 1; */
        for (let k of globalThis.Object.keys(message.annotations))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.annotations[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Annotations
 */
export const Info_Annotations = new Info_Annotations$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_CPU$Type extends MessageType<Info_CPU> {
    constructor() {
        super("payload.v1.Info.CPU", [
            { no: 1, name: "limit", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "request", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "usage", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Info_CPU>): Info_CPU {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.limit = 0;
        message.request = 0;
        message.usage = 0;
        if (value !== undefined)
            reflectionMergePartial<Info_CPU>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Info_CPU): Info_CPU {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double limit */ 1:
                    message.limit = reader.double();
                    break;
                case /* double request */ 2:
                    message.request = reader.double();
                    break;
                case /* double usage */ 3:
                    message.usage = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Info_CPU, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double limit = 1; */
        if (message.limit !== 0)
            writer.tag(1, WireType.Bit64).double(message.limit);
        /* double request = 2; */
        if (message.request !== 0)
            writer.tag(2, WireType.Bit64).double(message.request);
        /* double usage = 3; */
        if (message.usage !== 0)
            writer.tag(3, WireType.Bit64).double(message.usage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.CPU
 */
export const Info_CPU = new Info_CPU$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Memory$Type extends MessageType<Info_Memory> {
    constructor() {
        super("payload.v1.Info.Memory", [
            { no: 1, name: "limit", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "request", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "usage", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Info_Memory>): Info_Memory {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.limit = 0;
        message.request = 0;
        message.usage = 0;
        if (value !== undefined)
            reflectionMergePartial<Info_Memory>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Info_Memory): Info_Memory {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double limit */ 1:
                    message.limit = reader.double();
                    break;
                case /* double request */ 2:
                    message.request = reader.double();
                    break;
                case /* double usage */ 3:
                    message.usage = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Info_Memory, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double limit = 1; */
        if (message.limit !== 0)
            writer.tag(1, WireType.Bit64).double(message.limit);
        /* double request = 2; */
        if (message.request !== 0)
            writer.tag(2, WireType.Bit64).double(message.request);
        /* double usage = 3; */
        if (message.usage !== 0)
            writer.tag(3, WireType.Bit64).double(message.usage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Memory
 */
export const Info_Memory = new Info_Memory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Pods$Type extends MessageType<Info_Pods> {
    constructor() {
        super("payload.v1.Info.Pods", [
            { no: 1, name: "pods", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Info_Pod, options: { "buf.validate.field": { repeated: { minItems: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<Info_Pods>): Info_Pods {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pods = [];
        if (value !== undefined)
            reflectionMergePartial<Info_Pods>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Info_Pods): Info_Pods {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Info.Pod pods */ 1:
                    message.pods.push(Info_Pod.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Info_Pods, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payload.v1.Info.Pod pods = 1; */
        for (let i = 0; i < message.pods.length; i++)
            Info_Pod.internalBinaryWrite(message.pods[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Pods
 */
export const Info_Pods = new Info_Pods$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Nodes$Type extends MessageType<Info_Nodes> {
    constructor() {
        super("payload.v1.Info.Nodes", [
            { no: 1, name: "nodes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Info_Node, options: { "buf.validate.field": { repeated: { minItems: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<Info_Nodes>): Info_Nodes {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nodes = [];
        if (value !== undefined)
            reflectionMergePartial<Info_Nodes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Info_Nodes): Info_Nodes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Info.Node nodes */ 1:
                    message.nodes.push(Info_Node.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Info_Nodes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payload.v1.Info.Node nodes = 1; */
        for (let i = 0; i < message.nodes.length; i++)
            Info_Node.internalBinaryWrite(message.nodes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Nodes
 */
export const Info_Nodes = new Info_Nodes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Services$Type extends MessageType<Info_Services> {
    constructor() {
        super("payload.v1.Info.Services", [
            { no: 1, name: "services", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Info_Service, options: { "buf.validate.field": { repeated: { minItems: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<Info_Services>): Info_Services {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.services = [];
        if (value !== undefined)
            reflectionMergePartial<Info_Services>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Info_Services): Info_Services {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Info.Service services */ 1:
                    message.services.push(Info_Service.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Info_Services, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated payload.v1.Info.Service services = 1; */
        for (let i = 0; i < message.services.length; i++)
            Info_Service.internalBinaryWrite(message.services[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Services
 */
export const Info_Services = new Info_Services$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_IPs$Type extends MessageType<Info_IPs> {
    constructor() {
        super("payload.v1.Info.IPs", [
            { no: 1, name: "ip", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Info_IPs>): Info_IPs {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ip = [];
        if (value !== undefined)
            reflectionMergePartial<Info_IPs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Info_IPs): Info_IPs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string ip */ 1:
                    message.ip.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Info_IPs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string ip = 1; */
        for (let i = 0; i < message.ip.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.ip[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.IPs
 */
export const Info_IPs = new Info_IPs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Empty$Type extends MessageType<Empty> {
    constructor() {
        super("payload.v1.Empty", []);
    }
    create(value?: PartialMessage<Empty>): Empty {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Empty>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Empty): Empty {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Empty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Empty
 */
export const Empty = new Empty$Type();
