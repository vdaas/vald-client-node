//
// Copyright (C) 2019-2023 vdaas.org vald team <vald@vdaas.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// @generated by protoc-gen-es v1.6.0 with parameter "target=ts,keep_empty_files=true"
// @generated from file vald/v1/payload/payload.proto (package payload.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Status } from "../../../google/rpc/status_pb.js";

/**
 * Search related messages.
 *
 * @generated from message payload.v1.Search
 */
export class Search extends Message<Search> {
  constructor(data?: PartialMessage<Search>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Search";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Search {
    return new Search().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Search {
    return new Search().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Search {
    return new Search().fromJsonString(jsonString, options);
  }

  static equals(a: Search | PlainMessage<Search> | undefined, b: Search | PlainMessage<Search> | undefined): boolean {
    return proto3.util.equals(Search, a, b);
  }
}

/**
 * AggregationAlgorithm is enum of each aggregation algorithms
 *
 * @generated from enum payload.v1.Search.AggregationAlgorithm
 */
export enum Search_AggregationAlgorithm {
  /**
   * @generated from enum value: Unknown = 0;
   */
  Unknown = 0,

  /**
   * @generated from enum value: ConcurrentQueue = 1;
   */
  ConcurrentQueue = 1,

  /**
   * @generated from enum value: SortSlice = 2;
   */
  SortSlice = 2,

  /**
   * @generated from enum value: SortPoolSlice = 3;
   */
  SortPoolSlice = 3,

  /**
   * @generated from enum value: PairingHeap = 4;
   */
  PairingHeap = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(Search_AggregationAlgorithm)
proto3.util.setEnumType(Search_AggregationAlgorithm, "payload.v1.Search.AggregationAlgorithm", [
  { no: 0, name: "Unknown" },
  { no: 1, name: "ConcurrentQueue" },
  { no: 2, name: "SortSlice" },
  { no: 3, name: "SortPoolSlice" },
  { no: 4, name: "PairingHeap" },
]);

/**
 * Represent a search request.
 *
 * @generated from message payload.v1.Search.Request
 */
export class Search_Request extends Message<Search_Request> {
  /**
   * The vector to be searched.
   *
   * @generated from field: repeated float vector = 1;
   */
  vector: number[] = [];

  /**
   * The configuration of the search request.
   *
   * @generated from field: payload.v1.Search.Config config = 2;
   */
  config?: Search_Config;

  constructor(data?: PartialMessage<Search_Request>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Search.Request";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vector", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
    { no: 2, name: "config", kind: "message", T: Search_Config },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Search_Request {
    return new Search_Request().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Search_Request {
    return new Search_Request().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Search_Request {
    return new Search_Request().fromJsonString(jsonString, options);
  }

  static equals(a: Search_Request | PlainMessage<Search_Request> | undefined, b: Search_Request | PlainMessage<Search_Request> | undefined): boolean {
    return proto3.util.equals(Search_Request, a, b);
  }
}

/**
 * Represent the multiple search request.
 *
 * @generated from message payload.v1.Search.MultiRequest
 */
export class Search_MultiRequest extends Message<Search_MultiRequest> {
  /**
   * Represent the multiple search request content.
   *
   * @generated from field: repeated payload.v1.Search.Request requests = 1;
   */
  requests: Search_Request[] = [];

  constructor(data?: PartialMessage<Search_MultiRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Search.MultiRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "requests", kind: "message", T: Search_Request, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Search_MultiRequest {
    return new Search_MultiRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Search_MultiRequest {
    return new Search_MultiRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Search_MultiRequest {
    return new Search_MultiRequest().fromJsonString(jsonString, options);
  }

  static equals(a: Search_MultiRequest | PlainMessage<Search_MultiRequest> | undefined, b: Search_MultiRequest | PlainMessage<Search_MultiRequest> | undefined): boolean {
    return proto3.util.equals(Search_MultiRequest, a, b);
  }
}

/**
 * Represent a search by ID request.
 *
 * @generated from message payload.v1.Search.IDRequest
 */
export class Search_IDRequest extends Message<Search_IDRequest> {
  /**
   * The vector ID to be searched.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The configuration of the search request.
   *
   * @generated from field: payload.v1.Search.Config config = 2;
   */
  config?: Search_Config;

  constructor(data?: PartialMessage<Search_IDRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Search.IDRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "config", kind: "message", T: Search_Config },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Search_IDRequest {
    return new Search_IDRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Search_IDRequest {
    return new Search_IDRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Search_IDRequest {
    return new Search_IDRequest().fromJsonString(jsonString, options);
  }

  static equals(a: Search_IDRequest | PlainMessage<Search_IDRequest> | undefined, b: Search_IDRequest | PlainMessage<Search_IDRequest> | undefined): boolean {
    return proto3.util.equals(Search_IDRequest, a, b);
  }
}

/**
 * Represent the multiple search by ID request.
 *
 * @generated from message payload.v1.Search.MultiIDRequest
 */
export class Search_MultiIDRequest extends Message<Search_MultiIDRequest> {
  /**
   * Represent the multiple search by ID request content.
   *
   * @generated from field: repeated payload.v1.Search.IDRequest requests = 1;
   */
  requests: Search_IDRequest[] = [];

  constructor(data?: PartialMessage<Search_MultiIDRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Search.MultiIDRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "requests", kind: "message", T: Search_IDRequest, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Search_MultiIDRequest {
    return new Search_MultiIDRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Search_MultiIDRequest {
    return new Search_MultiIDRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Search_MultiIDRequest {
    return new Search_MultiIDRequest().fromJsonString(jsonString, options);
  }

  static equals(a: Search_MultiIDRequest | PlainMessage<Search_MultiIDRequest> | undefined, b: Search_MultiIDRequest | PlainMessage<Search_MultiIDRequest> | undefined): boolean {
    return proto3.util.equals(Search_MultiIDRequest, a, b);
  }
}

/**
 * Represent a search by binary object request.
 *
 * @generated from message payload.v1.Search.ObjectRequest
 */
export class Search_ObjectRequest extends Message<Search_ObjectRequest> {
  /**
   * The binary object to be searched.
   *
   * @generated from field: bytes object = 1;
   */
  object = new Uint8Array(0);

  /**
   * The configuration of the search request.
   *
   * @generated from field: payload.v1.Search.Config config = 2;
   */
  config?: Search_Config;

  /**
   * Filter configuration.
   *
   * @generated from field: payload.v1.Filter.Target vectorizer = 3;
   */
  vectorizer?: Filter_Target;

  constructor(data?: PartialMessage<Search_ObjectRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Search.ObjectRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "object", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "config", kind: "message", T: Search_Config },
    { no: 3, name: "vectorizer", kind: "message", T: Filter_Target },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Search_ObjectRequest {
    return new Search_ObjectRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Search_ObjectRequest {
    return new Search_ObjectRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Search_ObjectRequest {
    return new Search_ObjectRequest().fromJsonString(jsonString, options);
  }

  static equals(a: Search_ObjectRequest | PlainMessage<Search_ObjectRequest> | undefined, b: Search_ObjectRequest | PlainMessage<Search_ObjectRequest> | undefined): boolean {
    return proto3.util.equals(Search_ObjectRequest, a, b);
  }
}

/**
 * Represent the multiple search by binary object request.
 *
 * @generated from message payload.v1.Search.MultiObjectRequest
 */
export class Search_MultiObjectRequest extends Message<Search_MultiObjectRequest> {
  /**
   * Represent the multiple search by binary object request content.
   *
   * @generated from field: repeated payload.v1.Search.ObjectRequest requests = 1;
   */
  requests: Search_ObjectRequest[] = [];

  constructor(data?: PartialMessage<Search_MultiObjectRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Search.MultiObjectRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "requests", kind: "message", T: Search_ObjectRequest, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Search_MultiObjectRequest {
    return new Search_MultiObjectRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Search_MultiObjectRequest {
    return new Search_MultiObjectRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Search_MultiObjectRequest {
    return new Search_MultiObjectRequest().fromJsonString(jsonString, options);
  }

  static equals(a: Search_MultiObjectRequest | PlainMessage<Search_MultiObjectRequest> | undefined, b: Search_MultiObjectRequest | PlainMessage<Search_MultiObjectRequest> | undefined): boolean {
    return proto3.util.equals(Search_MultiObjectRequest, a, b);
  }
}

/**
 * Represent search configuration.
 *
 * @generated from message payload.v1.Search.Config
 */
export class Search_Config extends Message<Search_Config> {
  /**
   * Unique request ID.
   *
   * @generated from field: string request_id = 1;
   */
  requestId = "";

  /**
   * Maximum number of result to be returned.
   *
   * @generated from field: uint32 num = 2;
   */
  num = 0;

  /**
   * Search radius.
   *
   * @generated from field: float radius = 3;
   */
  radius = 0;

  /**
   * Search coefficient.
   *
   * @generated from field: float epsilon = 4;
   */
  epsilon = 0;

  /**
   * Search timeout in nanoseconds.
   *
   * @generated from field: int64 timeout = 5;
   */
  timeout = protoInt64.zero;

  /**
   * Ingress filter configurations.
   *
   * @generated from field: payload.v1.Filter.Config ingress_filters = 6;
   */
  ingressFilters?: Filter_Config;

  /**
   * Egress filter configurations.
   *
   * @generated from field: payload.v1.Filter.Config egress_filters = 7;
   */
  egressFilters?: Filter_Config;

  /**
   * Minimum number of result to be returned.
   *
   * @generated from field: uint32 min_num = 8;
   */
  minNum = 0;

  /**
   * Aggregation Algorithm
   *
   * @generated from field: payload.v1.Search.AggregationAlgorithm aggregation_algorithm = 9;
   */
  aggregationAlgorithm = Search_AggregationAlgorithm.Unknown;

  constructor(data?: PartialMessage<Search_Config>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Search.Config";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "num", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "radius", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 4, name: "epsilon", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 5, name: "timeout", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "ingress_filters", kind: "message", T: Filter_Config },
    { no: 7, name: "egress_filters", kind: "message", T: Filter_Config },
    { no: 8, name: "min_num", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 9, name: "aggregation_algorithm", kind: "enum", T: proto3.getEnumType(Search_AggregationAlgorithm) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Search_Config {
    return new Search_Config().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Search_Config {
    return new Search_Config().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Search_Config {
    return new Search_Config().fromJsonString(jsonString, options);
  }

  static equals(a: Search_Config | PlainMessage<Search_Config> | undefined, b: Search_Config | PlainMessage<Search_Config> | undefined): boolean {
    return proto3.util.equals(Search_Config, a, b);
  }
}

/**
 * Represent a search response.
 *
 * @generated from message payload.v1.Search.Response
 */
export class Search_Response extends Message<Search_Response> {
  /**
   * The unique request ID.
   *
   * @generated from field: string request_id = 1;
   */
  requestId = "";

  /**
   * Search results.
   *
   * @generated from field: repeated payload.v1.Object.Distance results = 2;
   */
  results: Object_Distance[] = [];

  constructor(data?: PartialMessage<Search_Response>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Search.Response";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "results", kind: "message", T: Object_Distance, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Search_Response {
    return new Search_Response().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Search_Response {
    return new Search_Response().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Search_Response {
    return new Search_Response().fromJsonString(jsonString, options);
  }

  static equals(a: Search_Response | PlainMessage<Search_Response> | undefined, b: Search_Response | PlainMessage<Search_Response> | undefined): boolean {
    return proto3.util.equals(Search_Response, a, b);
  }
}

/**
 * Represent multiple search responses.
 *
 * @generated from message payload.v1.Search.Responses
 */
export class Search_Responses extends Message<Search_Responses> {
  /**
   * Represent the multiple search response content.
   *
   * @generated from field: repeated payload.v1.Search.Response responses = 1;
   */
  responses: Search_Response[] = [];

  constructor(data?: PartialMessage<Search_Responses>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Search.Responses";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "responses", kind: "message", T: Search_Response, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Search_Responses {
    return new Search_Responses().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Search_Responses {
    return new Search_Responses().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Search_Responses {
    return new Search_Responses().fromJsonString(jsonString, options);
  }

  static equals(a: Search_Responses | PlainMessage<Search_Responses> | undefined, b: Search_Responses | PlainMessage<Search_Responses> | undefined): boolean {
    return proto3.util.equals(Search_Responses, a, b);
  }
}

/**
 * Represent stream search response.
 *
 * @generated from message payload.v1.Search.StreamResponse
 */
export class Search_StreamResponse extends Message<Search_StreamResponse> {
  /**
   * @generated from oneof payload.v1.Search.StreamResponse.payload
   */
  payload: {
    /**
     * Represent the search response.
     *
     * @generated from field: payload.v1.Search.Response response = 1;
     */
    value: Search_Response;
    case: "response";
  } | {
    /**
     * The RPC error status.
     *
     * @generated from field: google.rpc.Status status = 2;
     */
    value: Status;
    case: "status";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Search_StreamResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Search.StreamResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "message", T: Search_Response, oneof: "payload" },
    { no: 2, name: "status", kind: "message", T: Status, oneof: "payload" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Search_StreamResponse {
    return new Search_StreamResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Search_StreamResponse {
    return new Search_StreamResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Search_StreamResponse {
    return new Search_StreamResponse().fromJsonString(jsonString, options);
  }

  static equals(a: Search_StreamResponse | PlainMessage<Search_StreamResponse> | undefined, b: Search_StreamResponse | PlainMessage<Search_StreamResponse> | undefined): boolean {
    return proto3.util.equals(Search_StreamResponse, a, b);
  }
}

/**
 * Filter related messages.
 *
 * @generated from message payload.v1.Filter
 */
export class Filter extends Message<Filter> {
  constructor(data?: PartialMessage<Filter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Filter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Filter {
    return new Filter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Filter {
    return new Filter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Filter {
    return new Filter().fromJsonString(jsonString, options);
  }

  static equals(a: Filter | PlainMessage<Filter> | undefined, b: Filter | PlainMessage<Filter> | undefined): boolean {
    return proto3.util.equals(Filter, a, b);
  }
}

/**
 * Represent the target filter server.
 *
 * @generated from message payload.v1.Filter.Target
 */
export class Filter_Target extends Message<Filter_Target> {
  /**
   * The target hostname.
   *
   * @generated from field: string host = 1;
   */
  host = "";

  /**
   * The target port.
   *
   * @generated from field: uint32 port = 2;
   */
  port = 0;

  constructor(data?: PartialMessage<Filter_Target>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Filter.Target";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "host", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "port", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Filter_Target {
    return new Filter_Target().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Filter_Target {
    return new Filter_Target().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Filter_Target {
    return new Filter_Target().fromJsonString(jsonString, options);
  }

  static equals(a: Filter_Target | PlainMessage<Filter_Target> | undefined, b: Filter_Target | PlainMessage<Filter_Target> | undefined): boolean {
    return proto3.util.equals(Filter_Target, a, b);
  }
}

/**
 * Represent filter configuration.
 *
 * @generated from message payload.v1.Filter.Config
 */
export class Filter_Config extends Message<Filter_Config> {
  /**
   * Represent the filter target configuration.
   *
   * @generated from field: repeated payload.v1.Filter.Target targets = 1;
   */
  targets: Filter_Target[] = [];

  constructor(data?: PartialMessage<Filter_Config>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Filter.Config";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "targets", kind: "message", T: Filter_Target, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Filter_Config {
    return new Filter_Config().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Filter_Config {
    return new Filter_Config().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Filter_Config {
    return new Filter_Config().fromJsonString(jsonString, options);
  }

  static equals(a: Filter_Config | PlainMessage<Filter_Config> | undefined, b: Filter_Config | PlainMessage<Filter_Config> | undefined): boolean {
    return proto3.util.equals(Filter_Config, a, b);
  }
}

/**
 * Insert related messages.
 *
 * @generated from message payload.v1.Insert
 */
export class Insert extends Message<Insert> {
  constructor(data?: PartialMessage<Insert>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Insert";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Insert {
    return new Insert().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Insert {
    return new Insert().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Insert {
    return new Insert().fromJsonString(jsonString, options);
  }

  static equals(a: Insert | PlainMessage<Insert> | undefined, b: Insert | PlainMessage<Insert> | undefined): boolean {
    return proto3.util.equals(Insert, a, b);
  }
}

/**
 * Represent the insert request.
 *
 * @generated from message payload.v1.Insert.Request
 */
export class Insert_Request extends Message<Insert_Request> {
  /**
   * The vector to be inserted.
   *
   * @generated from field: payload.v1.Object.Vector vector = 1;
   */
  vector?: Object_Vector;

  /**
   * The configuration of the insert request.
   *
   * @generated from field: payload.v1.Insert.Config config = 2;
   */
  config?: Insert_Config;

  constructor(data?: PartialMessage<Insert_Request>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Insert.Request";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vector", kind: "message", T: Object_Vector },
    { no: 2, name: "config", kind: "message", T: Insert_Config },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Insert_Request {
    return new Insert_Request().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Insert_Request {
    return new Insert_Request().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Insert_Request {
    return new Insert_Request().fromJsonString(jsonString, options);
  }

  static equals(a: Insert_Request | PlainMessage<Insert_Request> | undefined, b: Insert_Request | PlainMessage<Insert_Request> | undefined): boolean {
    return proto3.util.equals(Insert_Request, a, b);
  }
}

/**
 * Represent the multiple insert request.
 *
 * @generated from message payload.v1.Insert.MultiRequest
 */
export class Insert_MultiRequest extends Message<Insert_MultiRequest> {
  /**
   * Represent multiple insert request content.
   *
   * @generated from field: repeated payload.v1.Insert.Request requests = 1;
   */
  requests: Insert_Request[] = [];

  constructor(data?: PartialMessage<Insert_MultiRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Insert.MultiRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "requests", kind: "message", T: Insert_Request, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Insert_MultiRequest {
    return new Insert_MultiRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Insert_MultiRequest {
    return new Insert_MultiRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Insert_MultiRequest {
    return new Insert_MultiRequest().fromJsonString(jsonString, options);
  }

  static equals(a: Insert_MultiRequest | PlainMessage<Insert_MultiRequest> | undefined, b: Insert_MultiRequest | PlainMessage<Insert_MultiRequest> | undefined): boolean {
    return proto3.util.equals(Insert_MultiRequest, a, b);
  }
}

/**
 * Represent the insert by binary object request.
 *
 * @generated from message payload.v1.Insert.ObjectRequest
 */
export class Insert_ObjectRequest extends Message<Insert_ObjectRequest> {
  /**
   * The binary object to be inserted.
   *
   * @generated from field: payload.v1.Object.Blob object = 1;
   */
  object?: Object_Blob;

  /**
   * The configuration of the insert request.
   *
   * @generated from field: payload.v1.Insert.Config config = 2;
   */
  config?: Insert_Config;

  /**
   * Filter configurations.
   *
   * @generated from field: payload.v1.Filter.Target vectorizer = 3;
   */
  vectorizer?: Filter_Target;

  constructor(data?: PartialMessage<Insert_ObjectRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Insert.ObjectRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "object", kind: "message", T: Object_Blob },
    { no: 2, name: "config", kind: "message", T: Insert_Config },
    { no: 3, name: "vectorizer", kind: "message", T: Filter_Target },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Insert_ObjectRequest {
    return new Insert_ObjectRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Insert_ObjectRequest {
    return new Insert_ObjectRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Insert_ObjectRequest {
    return new Insert_ObjectRequest().fromJsonString(jsonString, options);
  }

  static equals(a: Insert_ObjectRequest | PlainMessage<Insert_ObjectRequest> | undefined, b: Insert_ObjectRequest | PlainMessage<Insert_ObjectRequest> | undefined): boolean {
    return proto3.util.equals(Insert_ObjectRequest, a, b);
  }
}

/**
 * Represent the multiple insert by binary object request.
 *
 * @generated from message payload.v1.Insert.MultiObjectRequest
 */
export class Insert_MultiObjectRequest extends Message<Insert_MultiObjectRequest> {
  /**
   * Represent multiple insert by object content.
   *
   * @generated from field: repeated payload.v1.Insert.ObjectRequest requests = 1;
   */
  requests: Insert_ObjectRequest[] = [];

  constructor(data?: PartialMessage<Insert_MultiObjectRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Insert.MultiObjectRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "requests", kind: "message", T: Insert_ObjectRequest, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Insert_MultiObjectRequest {
    return new Insert_MultiObjectRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Insert_MultiObjectRequest {
    return new Insert_MultiObjectRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Insert_MultiObjectRequest {
    return new Insert_MultiObjectRequest().fromJsonString(jsonString, options);
  }

  static equals(a: Insert_MultiObjectRequest | PlainMessage<Insert_MultiObjectRequest> | undefined, b: Insert_MultiObjectRequest | PlainMessage<Insert_MultiObjectRequest> | undefined): boolean {
    return proto3.util.equals(Insert_MultiObjectRequest, a, b);
  }
}

/**
 * Represent insert configurations.
 *
 * @generated from message payload.v1.Insert.Config
 */
export class Insert_Config extends Message<Insert_Config> {
  /**
   * A flag to skip exist check during insert operation.
   *
   * @generated from field: bool skip_strict_exist_check = 1;
   */
  skipStrictExistCheck = false;

  /**
   * Filter configurations.
   *
   * @generated from field: payload.v1.Filter.Config filters = 2;
   */
  filters?: Filter_Config;

  /**
   * Insert timestamp.
   *
   * @generated from field: int64 timestamp = 3;
   */
  timestamp = protoInt64.zero;

  constructor(data?: PartialMessage<Insert_Config>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Insert.Config";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "skip_strict_exist_check", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "filters", kind: "message", T: Filter_Config },
    { no: 3, name: "timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Insert_Config {
    return new Insert_Config().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Insert_Config {
    return new Insert_Config().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Insert_Config {
    return new Insert_Config().fromJsonString(jsonString, options);
  }

  static equals(a: Insert_Config | PlainMessage<Insert_Config> | undefined, b: Insert_Config | PlainMessage<Insert_Config> | undefined): boolean {
    return proto3.util.equals(Insert_Config, a, b);
  }
}

/**
 * Update related messages
 *
 * @generated from message payload.v1.Update
 */
export class Update extends Message<Update> {
  constructor(data?: PartialMessage<Update>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Update";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Update {
    return new Update().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Update {
    return new Update().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Update {
    return new Update().fromJsonString(jsonString, options);
  }

  static equals(a: Update | PlainMessage<Update> | undefined, b: Update | PlainMessage<Update> | undefined): boolean {
    return proto3.util.equals(Update, a, b);
  }
}

/**
 * Represent the update request.
 *
 * @generated from message payload.v1.Update.Request
 */
export class Update_Request extends Message<Update_Request> {
  /**
   * The vector to be updated.
   *
   * @generated from field: payload.v1.Object.Vector vector = 1;
   */
  vector?: Object_Vector;

  /**
   * The configuration of the update request.
   *
   * @generated from field: payload.v1.Update.Config config = 2;
   */
  config?: Update_Config;

  constructor(data?: PartialMessage<Update_Request>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Update.Request";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vector", kind: "message", T: Object_Vector },
    { no: 2, name: "config", kind: "message", T: Update_Config },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Update_Request {
    return new Update_Request().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Update_Request {
    return new Update_Request().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Update_Request {
    return new Update_Request().fromJsonString(jsonString, options);
  }

  static equals(a: Update_Request | PlainMessage<Update_Request> | undefined, b: Update_Request | PlainMessage<Update_Request> | undefined): boolean {
    return proto3.util.equals(Update_Request, a, b);
  }
}

/**
 * Represent the multiple update request.
 *
 * @generated from message payload.v1.Update.MultiRequest
 */
export class Update_MultiRequest extends Message<Update_MultiRequest> {
  /**
   * Represent the multiple update request content.
   *
   * @generated from field: repeated payload.v1.Update.Request requests = 1;
   */
  requests: Update_Request[] = [];

  constructor(data?: PartialMessage<Update_MultiRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Update.MultiRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "requests", kind: "message", T: Update_Request, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Update_MultiRequest {
    return new Update_MultiRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Update_MultiRequest {
    return new Update_MultiRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Update_MultiRequest {
    return new Update_MultiRequest().fromJsonString(jsonString, options);
  }

  static equals(a: Update_MultiRequest | PlainMessage<Update_MultiRequest> | undefined, b: Update_MultiRequest | PlainMessage<Update_MultiRequest> | undefined): boolean {
    return proto3.util.equals(Update_MultiRequest, a, b);
  }
}

/**
 * Represent the update binary object request.
 *
 * @generated from message payload.v1.Update.ObjectRequest
 */
export class Update_ObjectRequest extends Message<Update_ObjectRequest> {
  /**
   * The binary object to be updated.
   *
   * @generated from field: payload.v1.Object.Blob object = 1;
   */
  object?: Object_Blob;

  /**
   * The configuration of the update request.
   *
   * @generated from field: payload.v1.Update.Config config = 2;
   */
  config?: Update_Config;

  /**
   * Filter target.
   *
   * @generated from field: payload.v1.Filter.Target vectorizer = 3;
   */
  vectorizer?: Filter_Target;

  constructor(data?: PartialMessage<Update_ObjectRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Update.ObjectRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "object", kind: "message", T: Object_Blob },
    { no: 2, name: "config", kind: "message", T: Update_Config },
    { no: 3, name: "vectorizer", kind: "message", T: Filter_Target },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Update_ObjectRequest {
    return new Update_ObjectRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Update_ObjectRequest {
    return new Update_ObjectRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Update_ObjectRequest {
    return new Update_ObjectRequest().fromJsonString(jsonString, options);
  }

  static equals(a: Update_ObjectRequest | PlainMessage<Update_ObjectRequest> | undefined, b: Update_ObjectRequest | PlainMessage<Update_ObjectRequest> | undefined): boolean {
    return proto3.util.equals(Update_ObjectRequest, a, b);
  }
}

/**
 * Represent the multiple update binary object request.
 *
 * @generated from message payload.v1.Update.MultiObjectRequest
 */
export class Update_MultiObjectRequest extends Message<Update_MultiObjectRequest> {
  /**
   * Represent the multiple update object request content.
   *
   * @generated from field: repeated payload.v1.Update.ObjectRequest requests = 1;
   */
  requests: Update_ObjectRequest[] = [];

  constructor(data?: PartialMessage<Update_MultiObjectRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Update.MultiObjectRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "requests", kind: "message", T: Update_ObjectRequest, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Update_MultiObjectRequest {
    return new Update_MultiObjectRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Update_MultiObjectRequest {
    return new Update_MultiObjectRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Update_MultiObjectRequest {
    return new Update_MultiObjectRequest().fromJsonString(jsonString, options);
  }

  static equals(a: Update_MultiObjectRequest | PlainMessage<Update_MultiObjectRequest> | undefined, b: Update_MultiObjectRequest | PlainMessage<Update_MultiObjectRequest> | undefined): boolean {
    return proto3.util.equals(Update_MultiObjectRequest, a, b);
  }
}

/**
 * Represent the update configuration.
 *
 * @generated from message payload.v1.Update.Config
 */
export class Update_Config extends Message<Update_Config> {
  /**
   * A flag to skip exist check during update operation.
   *
   * @generated from field: bool skip_strict_exist_check = 1;
   */
  skipStrictExistCheck = false;

  /**
   * Filter configuration.
   *
   * @generated from field: payload.v1.Filter.Config filters = 2;
   */
  filters?: Filter_Config;

  /**
   * Update timestamp.
   *
   * @generated from field: int64 timestamp = 3;
   */
  timestamp = protoInt64.zero;

  /**
   * A flag to disable balanced update (split remove -> insert operation)
   * during update operation.
   *
   * @generated from field: bool disable_balanced_update = 4;
   */
  disableBalancedUpdate = false;

  constructor(data?: PartialMessage<Update_Config>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Update.Config";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "skip_strict_exist_check", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "filters", kind: "message", T: Filter_Config },
    { no: 3, name: "timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "disable_balanced_update", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Update_Config {
    return new Update_Config().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Update_Config {
    return new Update_Config().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Update_Config {
    return new Update_Config().fromJsonString(jsonString, options);
  }

  static equals(a: Update_Config | PlainMessage<Update_Config> | undefined, b: Update_Config | PlainMessage<Update_Config> | undefined): boolean {
    return proto3.util.equals(Update_Config, a, b);
  }
}

/**
 * Upsert related messages.
 *
 * @generated from message payload.v1.Upsert
 */
export class Upsert extends Message<Upsert> {
  constructor(data?: PartialMessage<Upsert>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Upsert";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Upsert {
    return new Upsert().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Upsert {
    return new Upsert().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Upsert {
    return new Upsert().fromJsonString(jsonString, options);
  }

  static equals(a: Upsert | PlainMessage<Upsert> | undefined, b: Upsert | PlainMessage<Upsert> | undefined): boolean {
    return proto3.util.equals(Upsert, a, b);
  }
}

/**
 * Represent the upsert request.
 *
 * @generated from message payload.v1.Upsert.Request
 */
export class Upsert_Request extends Message<Upsert_Request> {
  /**
   * The vector to be upserted.
   *
   * @generated from field: payload.v1.Object.Vector vector = 1;
   */
  vector?: Object_Vector;

  /**
   * The configuration of the upsert request.
   *
   * @generated from field: payload.v1.Upsert.Config config = 2;
   */
  config?: Upsert_Config;

  constructor(data?: PartialMessage<Upsert_Request>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Upsert.Request";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vector", kind: "message", T: Object_Vector },
    { no: 2, name: "config", kind: "message", T: Upsert_Config },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Upsert_Request {
    return new Upsert_Request().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Upsert_Request {
    return new Upsert_Request().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Upsert_Request {
    return new Upsert_Request().fromJsonString(jsonString, options);
  }

  static equals(a: Upsert_Request | PlainMessage<Upsert_Request> | undefined, b: Upsert_Request | PlainMessage<Upsert_Request> | undefined): boolean {
    return proto3.util.equals(Upsert_Request, a, b);
  }
}

/**
 * Represent mthe ultiple upsert request.
 *
 * @generated from message payload.v1.Upsert.MultiRequest
 */
export class Upsert_MultiRequest extends Message<Upsert_MultiRequest> {
  /**
   * Represent the multiple upsert request content.
   *
   * @generated from field: repeated payload.v1.Upsert.Request requests = 1;
   */
  requests: Upsert_Request[] = [];

  constructor(data?: PartialMessage<Upsert_MultiRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Upsert.MultiRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "requests", kind: "message", T: Upsert_Request, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Upsert_MultiRequest {
    return new Upsert_MultiRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Upsert_MultiRequest {
    return new Upsert_MultiRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Upsert_MultiRequest {
    return new Upsert_MultiRequest().fromJsonString(jsonString, options);
  }

  static equals(a: Upsert_MultiRequest | PlainMessage<Upsert_MultiRequest> | undefined, b: Upsert_MultiRequest | PlainMessage<Upsert_MultiRequest> | undefined): boolean {
    return proto3.util.equals(Upsert_MultiRequest, a, b);
  }
}

/**
 * Represent the upsert binary object request.
 *
 * @generated from message payload.v1.Upsert.ObjectRequest
 */
export class Upsert_ObjectRequest extends Message<Upsert_ObjectRequest> {
  /**
   * The binary object to be upserted.
   *
   * @generated from field: payload.v1.Object.Blob object = 1;
   */
  object?: Object_Blob;

  /**
   * The configuration of the upsert request.
   *
   * @generated from field: payload.v1.Upsert.Config config = 2;
   */
  config?: Upsert_Config;

  /**
   * Filter target.
   *
   * @generated from field: payload.v1.Filter.Target vectorizer = 3;
   */
  vectorizer?: Filter_Target;

  constructor(data?: PartialMessage<Upsert_ObjectRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Upsert.ObjectRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "object", kind: "message", T: Object_Blob },
    { no: 2, name: "config", kind: "message", T: Upsert_Config },
    { no: 3, name: "vectorizer", kind: "message", T: Filter_Target },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Upsert_ObjectRequest {
    return new Upsert_ObjectRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Upsert_ObjectRequest {
    return new Upsert_ObjectRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Upsert_ObjectRequest {
    return new Upsert_ObjectRequest().fromJsonString(jsonString, options);
  }

  static equals(a: Upsert_ObjectRequest | PlainMessage<Upsert_ObjectRequest> | undefined, b: Upsert_ObjectRequest | PlainMessage<Upsert_ObjectRequest> | undefined): boolean {
    return proto3.util.equals(Upsert_ObjectRequest, a, b);
  }
}

/**
 * Represent the multiple upsert binary object request.
 *
 * @generated from message payload.v1.Upsert.MultiObjectRequest
 */
export class Upsert_MultiObjectRequest extends Message<Upsert_MultiObjectRequest> {
  /**
   * Represent the multiple upsert object request content.
   *
   * @generated from field: repeated payload.v1.Upsert.ObjectRequest requests = 1;
   */
  requests: Upsert_ObjectRequest[] = [];

  constructor(data?: PartialMessage<Upsert_MultiObjectRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Upsert.MultiObjectRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "requests", kind: "message", T: Upsert_ObjectRequest, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Upsert_MultiObjectRequest {
    return new Upsert_MultiObjectRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Upsert_MultiObjectRequest {
    return new Upsert_MultiObjectRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Upsert_MultiObjectRequest {
    return new Upsert_MultiObjectRequest().fromJsonString(jsonString, options);
  }

  static equals(a: Upsert_MultiObjectRequest | PlainMessage<Upsert_MultiObjectRequest> | undefined, b: Upsert_MultiObjectRequest | PlainMessage<Upsert_MultiObjectRequest> | undefined): boolean {
    return proto3.util.equals(Upsert_MultiObjectRequest, a, b);
  }
}

/**
 * Represent the upsert configuration.
 *
 * @generated from message payload.v1.Upsert.Config
 */
export class Upsert_Config extends Message<Upsert_Config> {
  /**
   * A flag to skip exist check during upsert operation.
   *
   * @generated from field: bool skip_strict_exist_check = 1;
   */
  skipStrictExistCheck = false;

  /**
   * Filter configuration.
   *
   * @generated from field: payload.v1.Filter.Config filters = 2;
   */
  filters?: Filter_Config;

  /**
   * Upsert timestamp.
   *
   * @generated from field: int64 timestamp = 3;
   */
  timestamp = protoInt64.zero;

  /**
   * A flag to disable balanced update (split remove -> insert operation)
   * during update operation.
   *
   * @generated from field: bool disable_balanced_update = 4;
   */
  disableBalancedUpdate = false;

  constructor(data?: PartialMessage<Upsert_Config>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Upsert.Config";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "skip_strict_exist_check", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "filters", kind: "message", T: Filter_Config },
    { no: 3, name: "timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "disable_balanced_update", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Upsert_Config {
    return new Upsert_Config().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Upsert_Config {
    return new Upsert_Config().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Upsert_Config {
    return new Upsert_Config().fromJsonString(jsonString, options);
  }

  static equals(a: Upsert_Config | PlainMessage<Upsert_Config> | undefined, b: Upsert_Config | PlainMessage<Upsert_Config> | undefined): boolean {
    return proto3.util.equals(Upsert_Config, a, b);
  }
}

/**
 * Remove related messages.
 *
 * @generated from message payload.v1.Remove
 */
export class Remove extends Message<Remove> {
  constructor(data?: PartialMessage<Remove>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Remove";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Remove {
    return new Remove().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Remove {
    return new Remove().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Remove {
    return new Remove().fromJsonString(jsonString, options);
  }

  static equals(a: Remove | PlainMessage<Remove> | undefined, b: Remove | PlainMessage<Remove> | undefined): boolean {
    return proto3.util.equals(Remove, a, b);
  }
}

/**
 * Represent the remove request.
 *
 * @generated from message payload.v1.Remove.Request
 */
export class Remove_Request extends Message<Remove_Request> {
  /**
   * The object ID to be removed.
   *
   * @generated from field: payload.v1.Object.ID id = 1;
   */
  id?: Object_ID;

  /**
   * The configuration of the remove request.
   *
   * @generated from field: payload.v1.Remove.Config config = 2;
   */
  config?: Remove_Config;

  constructor(data?: PartialMessage<Remove_Request>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Remove.Request";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: Object_ID },
    { no: 2, name: "config", kind: "message", T: Remove_Config },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Remove_Request {
    return new Remove_Request().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Remove_Request {
    return new Remove_Request().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Remove_Request {
    return new Remove_Request().fromJsonString(jsonString, options);
  }

  static equals(a: Remove_Request | PlainMessage<Remove_Request> | undefined, b: Remove_Request | PlainMessage<Remove_Request> | undefined): boolean {
    return proto3.util.equals(Remove_Request, a, b);
  }
}

/**
 * Represent the multiple remove request.
 *
 * @generated from message payload.v1.Remove.MultiRequest
 */
export class Remove_MultiRequest extends Message<Remove_MultiRequest> {
  /**
   * Represent the multiple remove request content.
   *
   * @generated from field: repeated payload.v1.Remove.Request requests = 1;
   */
  requests: Remove_Request[] = [];

  constructor(data?: PartialMessage<Remove_MultiRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Remove.MultiRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "requests", kind: "message", T: Remove_Request, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Remove_MultiRequest {
    return new Remove_MultiRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Remove_MultiRequest {
    return new Remove_MultiRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Remove_MultiRequest {
    return new Remove_MultiRequest().fromJsonString(jsonString, options);
  }

  static equals(a: Remove_MultiRequest | PlainMessage<Remove_MultiRequest> | undefined, b: Remove_MultiRequest | PlainMessage<Remove_MultiRequest> | undefined): boolean {
    return proto3.util.equals(Remove_MultiRequest, a, b);
  }
}

/**
 * Represent the remove request based on timestamp.
 *
 * @generated from message payload.v1.Remove.TimestampRequest
 */
export class Remove_TimestampRequest extends Message<Remove_TimestampRequest> {
  /**
   * The timestamp comparison list. If more than one is specified, the `AND` search is applied.
   *
   * @generated from field: repeated payload.v1.Remove.Timestamp timestamps = 1;
   */
  timestamps: Remove_Timestamp[] = [];

  constructor(data?: PartialMessage<Remove_TimestampRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Remove.TimestampRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamps", kind: "message", T: Remove_Timestamp, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Remove_TimestampRequest {
    return new Remove_TimestampRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Remove_TimestampRequest {
    return new Remove_TimestampRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Remove_TimestampRequest {
    return new Remove_TimestampRequest().fromJsonString(jsonString, options);
  }

  static equals(a: Remove_TimestampRequest | PlainMessage<Remove_TimestampRequest> | undefined, b: Remove_TimestampRequest | PlainMessage<Remove_TimestampRequest> | undefined): boolean {
    return proto3.util.equals(Remove_TimestampRequest, a, b);
  }
}

/**
 * Represent the timestamp comparison.
 *
 * @generated from message payload.v1.Remove.Timestamp
 */
export class Remove_Timestamp extends Message<Remove_Timestamp> {
  /**
   * The timestamp.
   *
   * @generated from field: int64 timestamp = 1;
   */
  timestamp = protoInt64.zero;

  /**
   * The conditional operator.
   *
   * @generated from field: payload.v1.Remove.Timestamp.Operator operator = 2;
   */
  operator = Remove_Timestamp_Operator.Eq;

  constructor(data?: PartialMessage<Remove_Timestamp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Remove.Timestamp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "operator", kind: "enum", T: proto3.getEnumType(Remove_Timestamp_Operator) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Remove_Timestamp {
    return new Remove_Timestamp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Remove_Timestamp {
    return new Remove_Timestamp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Remove_Timestamp {
    return new Remove_Timestamp().fromJsonString(jsonString, options);
  }

  static equals(a: Remove_Timestamp | PlainMessage<Remove_Timestamp> | undefined, b: Remove_Timestamp | PlainMessage<Remove_Timestamp> | undefined): boolean {
    return proto3.util.equals(Remove_Timestamp, a, b);
  }
}

/**
 * Operator is enum of each conditional operator.
 *
 * @generated from enum payload.v1.Remove.Timestamp.Operator
 */
export enum Remove_Timestamp_Operator {
  /**
   * The timestamp is equal to the specified value in the request.
   *
   * @generated from enum value: Eq = 0;
   */
  Eq = 0,

  /**
   * The timestamp is not equal to the specified value in the request.
   *
   * @generated from enum value: Ne = 1;
   */
  Ne = 1,

  /**
   * The timestamp is greater than or equal to the specified value in the request.
   *
   * @generated from enum value: Ge = 2;
   */
  Ge = 2,

  /**
   * The timestamp is greater than the specified value in the request.
   *
   * @generated from enum value: Gt = 3;
   */
  Gt = 3,

  /**
   * The timestamp is less than or equal to the specified value in the request.
   *
   * @generated from enum value: Le = 4;
   */
  Le = 4,

  /**
   * The timestamp is less than the specified value in the request.
   *
   * @generated from enum value: Lt = 5;
   */
  Lt = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(Remove_Timestamp_Operator)
proto3.util.setEnumType(Remove_Timestamp_Operator, "payload.v1.Remove.Timestamp.Operator", [
  { no: 0, name: "Eq" },
  { no: 1, name: "Ne" },
  { no: 2, name: "Ge" },
  { no: 3, name: "Gt" },
  { no: 4, name: "Le" },
  { no: 5, name: "Lt" },
]);

/**
 * Represent the remove configuration.
 *
 * @generated from message payload.v1.Remove.Config
 */
export class Remove_Config extends Message<Remove_Config> {
  /**
   * A flag to skip exist check during upsert operation.
   *
   * @generated from field: bool skip_strict_exist_check = 1;
   */
  skipStrictExistCheck = false;

  /**
   * Remove timestamp.
   *
   * @generated from field: int64 timestamp = 3;
   */
  timestamp = protoInt64.zero;

  constructor(data?: PartialMessage<Remove_Config>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Remove.Config";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "skip_strict_exist_check", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Remove_Config {
    return new Remove_Config().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Remove_Config {
    return new Remove_Config().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Remove_Config {
    return new Remove_Config().fromJsonString(jsonString, options);
  }

  static equals(a: Remove_Config | PlainMessage<Remove_Config> | undefined, b: Remove_Config | PlainMessage<Remove_Config> | undefined): boolean {
    return proto3.util.equals(Remove_Config, a, b);
  }
}

/**
 * Common messages.
 *
 * @generated from message payload.v1.Object
 */
export class Object$ extends Message<Object$> {
  constructor(data?: PartialMessage<Object$>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Object";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object$ {
    return new Object$().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object$ {
    return new Object$().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object$ {
    return new Object$().fromJsonString(jsonString, options);
  }

  static equals(a: Object$ | PlainMessage<Object$> | undefined, b: Object$ | PlainMessage<Object$> | undefined): boolean {
    return proto3.util.equals(Object$, a, b);
  }
}

/**
 * Represent a request to fetch raw vector.
 *
 * @generated from message payload.v1.Object.VectorRequest
 */
export class Object_VectorRequest extends Message<Object_VectorRequest> {
  /**
   * The vector ID to be fetched.
   *
   * @generated from field: payload.v1.Object.ID id = 1;
   */
  id?: Object_ID;

  /**
   * Filter configurations.
   *
   * @generated from field: payload.v1.Filter.Config filters = 2;
   */
  filters?: Filter_Config;

  constructor(data?: PartialMessage<Object_VectorRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Object.VectorRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: Object_ID },
    { no: 2, name: "filters", kind: "message", T: Filter_Config },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object_VectorRequest {
    return new Object_VectorRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object_VectorRequest {
    return new Object_VectorRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object_VectorRequest {
    return new Object_VectorRequest().fromJsonString(jsonString, options);
  }

  static equals(a: Object_VectorRequest | PlainMessage<Object_VectorRequest> | undefined, b: Object_VectorRequest | PlainMessage<Object_VectorRequest> | undefined): boolean {
    return proto3.util.equals(Object_VectorRequest, a, b);
  }
}

/**
 * Represent the ID and distance pair.
 *
 * @generated from message payload.v1.Object.Distance
 */
export class Object_Distance extends Message<Object_Distance> {
  /**
   * The vector ID.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The distance.
   *
   * @generated from field: float distance = 2;
   */
  distance = 0;

  constructor(data?: PartialMessage<Object_Distance>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Object.Distance";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "distance", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object_Distance {
    return new Object_Distance().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object_Distance {
    return new Object_Distance().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object_Distance {
    return new Object_Distance().fromJsonString(jsonString, options);
  }

  static equals(a: Object_Distance | PlainMessage<Object_Distance> | undefined, b: Object_Distance | PlainMessage<Object_Distance> | undefined): boolean {
    return proto3.util.equals(Object_Distance, a, b);
  }
}

/**
 * Represent stream response of distances.
 *
 * @generated from message payload.v1.Object.StreamDistance
 */
export class Object_StreamDistance extends Message<Object_StreamDistance> {
  /**
   * @generated from oneof payload.v1.Object.StreamDistance.payload
   */
  payload: {
    /**
     * The distance.
     *
     * @generated from field: payload.v1.Object.Distance distance = 1;
     */
    value: Object_Distance;
    case: "distance";
  } | {
    /**
     * The RPC error status.
     *
     * @generated from field: google.rpc.Status status = 2;
     */
    value: Status;
    case: "status";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Object_StreamDistance>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Object.StreamDistance";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "distance", kind: "message", T: Object_Distance, oneof: "payload" },
    { no: 2, name: "status", kind: "message", T: Status, oneof: "payload" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object_StreamDistance {
    return new Object_StreamDistance().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object_StreamDistance {
    return new Object_StreamDistance().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object_StreamDistance {
    return new Object_StreamDistance().fromJsonString(jsonString, options);
  }

  static equals(a: Object_StreamDistance | PlainMessage<Object_StreamDistance> | undefined, b: Object_StreamDistance | PlainMessage<Object_StreamDistance> | undefined): boolean {
    return proto3.util.equals(Object_StreamDistance, a, b);
  }
}

/**
 * Represent the vector ID.
 *
 * @generated from message payload.v1.Object.ID
 */
export class Object_ID extends Message<Object_ID> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<Object_ID>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Object.ID";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object_ID {
    return new Object_ID().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object_ID {
    return new Object_ID().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object_ID {
    return new Object_ID().fromJsonString(jsonString, options);
  }

  static equals(a: Object_ID | PlainMessage<Object_ID> | undefined, b: Object_ID | PlainMessage<Object_ID> | undefined): boolean {
    return proto3.util.equals(Object_ID, a, b);
  }
}

/**
 * Represent multiple vector IDs.
 *
 * @generated from message payload.v1.Object.IDs
 */
export class Object_IDs extends Message<Object_IDs> {
  /**
   * @generated from field: repeated string ids = 1;
   */
  ids: string[] = [];

  constructor(data?: PartialMessage<Object_IDs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Object.IDs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object_IDs {
    return new Object_IDs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object_IDs {
    return new Object_IDs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object_IDs {
    return new Object_IDs().fromJsonString(jsonString, options);
  }

  static equals(a: Object_IDs | PlainMessage<Object_IDs> | undefined, b: Object_IDs | PlainMessage<Object_IDs> | undefined): boolean {
    return proto3.util.equals(Object_IDs, a, b);
  }
}

/**
 * Represent a vector.
 *
 * @generated from message payload.v1.Object.Vector
 */
export class Object_Vector extends Message<Object_Vector> {
  /**
   * The vector ID.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The vector.
   *
   * @generated from field: repeated float vector = 2;
   */
  vector: number[] = [];

  /**
   * timestamp represents when this vector inserted.
   *
   * @generated from field: int64 timestamp = 3;
   */
  timestamp = protoInt64.zero;

  constructor(data?: PartialMessage<Object_Vector>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Object.Vector";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "vector", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
    { no: 3, name: "timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object_Vector {
    return new Object_Vector().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object_Vector {
    return new Object_Vector().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object_Vector {
    return new Object_Vector().fromJsonString(jsonString, options);
  }

  static equals(a: Object_Vector | PlainMessage<Object_Vector> | undefined, b: Object_Vector | PlainMessage<Object_Vector> | undefined): boolean {
    return proto3.util.equals(Object_Vector, a, b);
  }
}

/**
 * Represent a request to fetch vector meta data.
 *
 * @generated from message payload.v1.Object.GetTimestampRequest
 */
export class Object_GetTimestampRequest extends Message<Object_GetTimestampRequest> {
  /**
   * The vector ID to be fetched.
   *
   * @generated from field: payload.v1.Object.ID id = 1;
   */
  id?: Object_ID;

  constructor(data?: PartialMessage<Object_GetTimestampRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Object.GetTimestampRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: Object_ID },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object_GetTimestampRequest {
    return new Object_GetTimestampRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object_GetTimestampRequest {
    return new Object_GetTimestampRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object_GetTimestampRequest {
    return new Object_GetTimestampRequest().fromJsonString(jsonString, options);
  }

  static equals(a: Object_GetTimestampRequest | PlainMessage<Object_GetTimestampRequest> | undefined, b: Object_GetTimestampRequest | PlainMessage<Object_GetTimestampRequest> | undefined): boolean {
    return proto3.util.equals(Object_GetTimestampRequest, a, b);
  }
}

/**
 * Represent a vector meta data.
 *
 * @generated from message payload.v1.Object.Timestamp
 */
export class Object_Timestamp extends Message<Object_Timestamp> {
  /**
   * The vector ID.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * timestamp represents when this vector inserted.
   *
   * @generated from field: int64 timestamp = 2;
   */
  timestamp = protoInt64.zero;

  constructor(data?: PartialMessage<Object_Timestamp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Object.Timestamp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object_Timestamp {
    return new Object_Timestamp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object_Timestamp {
    return new Object_Timestamp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object_Timestamp {
    return new Object_Timestamp().fromJsonString(jsonString, options);
  }

  static equals(a: Object_Timestamp | PlainMessage<Object_Timestamp> | undefined, b: Object_Timestamp | PlainMessage<Object_Timestamp> | undefined): boolean {
    return proto3.util.equals(Object_Timestamp, a, b);
  }
}

/**
 * Represent multiple vectors.
 *
 * @generated from message payload.v1.Object.Vectors
 */
export class Object_Vectors extends Message<Object_Vectors> {
  /**
   * @generated from field: repeated payload.v1.Object.Vector vectors = 1;
   */
  vectors: Object_Vector[] = [];

  constructor(data?: PartialMessage<Object_Vectors>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Object.Vectors";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vectors", kind: "message", T: Object_Vector, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object_Vectors {
    return new Object_Vectors().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object_Vectors {
    return new Object_Vectors().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object_Vectors {
    return new Object_Vectors().fromJsonString(jsonString, options);
  }

  static equals(a: Object_Vectors | PlainMessage<Object_Vectors> | undefined, b: Object_Vectors | PlainMessage<Object_Vectors> | undefined): boolean {
    return proto3.util.equals(Object_Vectors, a, b);
  }
}

/**
 * Represent stream response of the vector.
 *
 * @generated from message payload.v1.Object.StreamVector
 */
export class Object_StreamVector extends Message<Object_StreamVector> {
  /**
   * @generated from oneof payload.v1.Object.StreamVector.payload
   */
  payload: {
    /**
     * The vector.
     *
     * @generated from field: payload.v1.Object.Vector vector = 1;
     */
    value: Object_Vector;
    case: "vector";
  } | {
    /**
     * The RPC error status.
     *
     * @generated from field: google.rpc.Status status = 2;
     */
    value: Status;
    case: "status";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Object_StreamVector>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Object.StreamVector";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vector", kind: "message", T: Object_Vector, oneof: "payload" },
    { no: 2, name: "status", kind: "message", T: Status, oneof: "payload" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object_StreamVector {
    return new Object_StreamVector().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object_StreamVector {
    return new Object_StreamVector().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object_StreamVector {
    return new Object_StreamVector().fromJsonString(jsonString, options);
  }

  static equals(a: Object_StreamVector | PlainMessage<Object_StreamVector> | undefined, b: Object_StreamVector | PlainMessage<Object_StreamVector> | undefined): boolean {
    return proto3.util.equals(Object_StreamVector, a, b);
  }
}

/**
 * Represent reshape vector.
 *
 * @generated from message payload.v1.Object.ReshapeVector
 */
export class Object_ReshapeVector extends Message<Object_ReshapeVector> {
  /**
   * The binary object.
   *
   * @generated from field: bytes object = 1;
   */
  object = new Uint8Array(0);

  /**
   * The new shape.
   *
   * @generated from field: repeated int32 shape = 2;
   */
  shape: number[] = [];

  constructor(data?: PartialMessage<Object_ReshapeVector>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Object.ReshapeVector";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "object", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "shape", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object_ReshapeVector {
    return new Object_ReshapeVector().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object_ReshapeVector {
    return new Object_ReshapeVector().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object_ReshapeVector {
    return new Object_ReshapeVector().fromJsonString(jsonString, options);
  }

  static equals(a: Object_ReshapeVector | PlainMessage<Object_ReshapeVector> | undefined, b: Object_ReshapeVector | PlainMessage<Object_ReshapeVector> | undefined): boolean {
    return proto3.util.equals(Object_ReshapeVector, a, b);
  }
}

/**
 * Represent the binary object.
 *
 * @generated from message payload.v1.Object.Blob
 */
export class Object_Blob extends Message<Object_Blob> {
  /**
   * The object ID.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The binary object.
   *
   * @generated from field: bytes object = 2;
   */
  object = new Uint8Array(0);

  constructor(data?: PartialMessage<Object_Blob>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Object.Blob";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "object", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object_Blob {
    return new Object_Blob().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object_Blob {
    return new Object_Blob().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object_Blob {
    return new Object_Blob().fromJsonString(jsonString, options);
  }

  static equals(a: Object_Blob | PlainMessage<Object_Blob> | undefined, b: Object_Blob | PlainMessage<Object_Blob> | undefined): boolean {
    return proto3.util.equals(Object_Blob, a, b);
  }
}

/**
 * Represent stream response of binary objects.
 *
 * @generated from message payload.v1.Object.StreamBlob
 */
export class Object_StreamBlob extends Message<Object_StreamBlob> {
  /**
   * @generated from oneof payload.v1.Object.StreamBlob.payload
   */
  payload: {
    /**
     * The binary object.
     *
     * @generated from field: payload.v1.Object.Blob blob = 1;
     */
    value: Object_Blob;
    case: "blob";
  } | {
    /**
     * The RPC error status.
     *
     * @generated from field: google.rpc.Status status = 2;
     */
    value: Status;
    case: "status";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Object_StreamBlob>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Object.StreamBlob";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "blob", kind: "message", T: Object_Blob, oneof: "payload" },
    { no: 2, name: "status", kind: "message", T: Status, oneof: "payload" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object_StreamBlob {
    return new Object_StreamBlob().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object_StreamBlob {
    return new Object_StreamBlob().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object_StreamBlob {
    return new Object_StreamBlob().fromJsonString(jsonString, options);
  }

  static equals(a: Object_StreamBlob | PlainMessage<Object_StreamBlob> | undefined, b: Object_StreamBlob | PlainMessage<Object_StreamBlob> | undefined): boolean {
    return proto3.util.equals(Object_StreamBlob, a, b);
  }
}

/**
 * Represent the vector location.
 *
 * @generated from message payload.v1.Object.Location
 */
export class Object_Location extends Message<Object_Location> {
  /**
   * The name of the location.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The UUID of the vector.
   *
   * @generated from field: string uuid = 2;
   */
  uuid = "";

  /**
   * The IP list.
   *
   * @generated from field: repeated string ips = 3;
   */
  ips: string[] = [];

  constructor(data?: PartialMessage<Object_Location>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Object.Location";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ips", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object_Location {
    return new Object_Location().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object_Location {
    return new Object_Location().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object_Location {
    return new Object_Location().fromJsonString(jsonString, options);
  }

  static equals(a: Object_Location | PlainMessage<Object_Location> | undefined, b: Object_Location | PlainMessage<Object_Location> | undefined): boolean {
    return proto3.util.equals(Object_Location, a, b);
  }
}

/**
 * Represent the stream response of the vector location.
 *
 * @generated from message payload.v1.Object.StreamLocation
 */
export class Object_StreamLocation extends Message<Object_StreamLocation> {
  /**
   * @generated from oneof payload.v1.Object.StreamLocation.payload
   */
  payload: {
    /**
     * The vector location.
     *
     * @generated from field: payload.v1.Object.Location location = 1;
     */
    value: Object_Location;
    case: "location";
  } | {
    /**
     * The RPC error status.
     *
     * @generated from field: google.rpc.Status status = 2;
     */
    value: Status;
    case: "status";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Object_StreamLocation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Object.StreamLocation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "location", kind: "message", T: Object_Location, oneof: "payload" },
    { no: 2, name: "status", kind: "message", T: Status, oneof: "payload" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object_StreamLocation {
    return new Object_StreamLocation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object_StreamLocation {
    return new Object_StreamLocation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object_StreamLocation {
    return new Object_StreamLocation().fromJsonString(jsonString, options);
  }

  static equals(a: Object_StreamLocation | PlainMessage<Object_StreamLocation> | undefined, b: Object_StreamLocation | PlainMessage<Object_StreamLocation> | undefined): boolean {
    return proto3.util.equals(Object_StreamLocation, a, b);
  }
}

/**
 * Represent multiple vector locations.
 *
 * @generated from message payload.v1.Object.Locations
 */
export class Object_Locations extends Message<Object_Locations> {
  /**
   * @generated from field: repeated payload.v1.Object.Location locations = 1;
   */
  locations: Object_Location[] = [];

  constructor(data?: PartialMessage<Object_Locations>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Object.Locations";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "locations", kind: "message", T: Object_Location, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object_Locations {
    return new Object_Locations().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object_Locations {
    return new Object_Locations().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object_Locations {
    return new Object_Locations().fromJsonString(jsonString, options);
  }

  static equals(a: Object_Locations | PlainMessage<Object_Locations> | undefined, b: Object_Locations | PlainMessage<Object_Locations> | undefined): boolean {
    return proto3.util.equals(Object_Locations, a, b);
  }
}

/**
 * Represent the list object vector stream request and response.
 *
 * @generated from message payload.v1.Object.List
 */
export class Object_List extends Message<Object_List> {
  constructor(data?: PartialMessage<Object_List>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Object.List";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object_List {
    return new Object_List().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object_List {
    return new Object_List().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object_List {
    return new Object_List().fromJsonString(jsonString, options);
  }

  static equals(a: Object_List | PlainMessage<Object_List> | undefined, b: Object_List | PlainMessage<Object_List> | undefined): boolean {
    return proto3.util.equals(Object_List, a, b);
  }
}

/**
 * @generated from message payload.v1.Object.List.Request
 */
export class Object_List_Request extends Message<Object_List_Request> {
  constructor(data?: PartialMessage<Object_List_Request>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Object.List.Request";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object_List_Request {
    return new Object_List_Request().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object_List_Request {
    return new Object_List_Request().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object_List_Request {
    return new Object_List_Request().fromJsonString(jsonString, options);
  }

  static equals(a: Object_List_Request | PlainMessage<Object_List_Request> | undefined, b: Object_List_Request | PlainMessage<Object_List_Request> | undefined): boolean {
    return proto3.util.equals(Object_List_Request, a, b);
  }
}

/**
 * @generated from message payload.v1.Object.List.Response
 */
export class Object_List_Response extends Message<Object_List_Response> {
  /**
   * @generated from oneof payload.v1.Object.List.Response.payload
   */
  payload: {
    /**
     * The vector
     *
     * @generated from field: payload.v1.Object.Vector vector = 1;
     */
    value: Object_Vector;
    case: "vector";
  } | {
    /**
     * The RPC error status.
     *
     * @generated from field: google.rpc.Status status = 2;
     */
    value: Status;
    case: "status";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Object_List_Response>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Object.List.Response";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vector", kind: "message", T: Object_Vector, oneof: "payload" },
    { no: 2, name: "status", kind: "message", T: Status, oneof: "payload" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object_List_Response {
    return new Object_List_Response().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object_List_Response {
    return new Object_List_Response().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object_List_Response {
    return new Object_List_Response().fromJsonString(jsonString, options);
  }

  static equals(a: Object_List_Response | PlainMessage<Object_List_Response> | undefined, b: Object_List_Response | PlainMessage<Object_List_Response> | undefined): boolean {
    return proto3.util.equals(Object_List_Response, a, b);
  }
}

/**
 * Control related messages.
 *
 * @generated from message payload.v1.Control
 */
export class Control extends Message<Control> {
  constructor(data?: PartialMessage<Control>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Control";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Control {
    return new Control().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Control {
    return new Control().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Control {
    return new Control().fromJsonString(jsonString, options);
  }

  static equals(a: Control | PlainMessage<Control> | undefined, b: Control | PlainMessage<Control> | undefined): boolean {
    return proto3.util.equals(Control, a, b);
  }
}

/**
 * Represent the create index request.
 *
 * @generated from message payload.v1.Control.CreateIndexRequest
 */
export class Control_CreateIndexRequest extends Message<Control_CreateIndexRequest> {
  /**
   * The pool size of the create index operation.
   *
   * @generated from field: uint32 pool_size = 1;
   */
  poolSize = 0;

  constructor(data?: PartialMessage<Control_CreateIndexRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Control.CreateIndexRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pool_size", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Control_CreateIndexRequest {
    return new Control_CreateIndexRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Control_CreateIndexRequest {
    return new Control_CreateIndexRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Control_CreateIndexRequest {
    return new Control_CreateIndexRequest().fromJsonString(jsonString, options);
  }

  static equals(a: Control_CreateIndexRequest | PlainMessage<Control_CreateIndexRequest> | undefined, b: Control_CreateIndexRequest | PlainMessage<Control_CreateIndexRequest> | undefined): boolean {
    return proto3.util.equals(Control_CreateIndexRequest, a, b);
  }
}

/**
 * Discoverer related messages.
 *
 * @generated from message payload.v1.Discoverer
 */
export class Discoverer extends Message<Discoverer> {
  constructor(data?: PartialMessage<Discoverer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Discoverer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Discoverer {
    return new Discoverer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Discoverer {
    return new Discoverer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Discoverer {
    return new Discoverer().fromJsonString(jsonString, options);
  }

  static equals(a: Discoverer | PlainMessage<Discoverer> | undefined, b: Discoverer | PlainMessage<Discoverer> | undefined): boolean {
    return proto3.util.equals(Discoverer, a, b);
  }
}

/**
 * Represent the dicoverer request.
 *
 * @generated from message payload.v1.Discoverer.Request
 */
export class Discoverer_Request extends Message<Discoverer_Request> {
  /**
   * The agent name to be discovered.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The namespace to be discovered.
   *
   * @generated from field: string namespace = 2;
   */
  namespace = "";

  /**
   * The node to be discovered.
   *
   * @generated from field: string node = 3;
   */
  node = "";

  constructor(data?: PartialMessage<Discoverer_Request>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Discoverer.Request";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "node", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Discoverer_Request {
    return new Discoverer_Request().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Discoverer_Request {
    return new Discoverer_Request().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Discoverer_Request {
    return new Discoverer_Request().fromJsonString(jsonString, options);
  }

  static equals(a: Discoverer_Request | PlainMessage<Discoverer_Request> | undefined, b: Discoverer_Request | PlainMessage<Discoverer_Request> | undefined): boolean {
    return proto3.util.equals(Discoverer_Request, a, b);
  }
}

/**
 * Info related messages.
 *
 * @generated from message payload.v1.Info
 */
export class Info extends Message<Info> {
  constructor(data?: PartialMessage<Info>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Info";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Info {
    return new Info().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Info {
    return new Info().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Info {
    return new Info().fromJsonString(jsonString, options);
  }

  static equals(a: Info | PlainMessage<Info> | undefined, b: Info | PlainMessage<Info> | undefined): boolean {
    return proto3.util.equals(Info, a, b);
  }
}

/**
 * Represent the index information messages.
 *
 * @generated from message payload.v1.Info.Index
 */
export class Info_Index extends Message<Info_Index> {
  constructor(data?: PartialMessage<Info_Index>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Info.Index";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Info_Index {
    return new Info_Index().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Info_Index {
    return new Info_Index().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Info_Index {
    return new Info_Index().fromJsonString(jsonString, options);
  }

  static equals(a: Info_Index | PlainMessage<Info_Index> | undefined, b: Info_Index | PlainMessage<Info_Index> | undefined): boolean {
    return proto3.util.equals(Info_Index, a, b);
  }
}

/**
 * Represent the index count message.
 *
 * @generated from message payload.v1.Info.Index.Count
 */
export class Info_Index_Count extends Message<Info_Index_Count> {
  /**
   * The stored index count.
   *
   * @generated from field: uint32 stored = 1;
   */
  stored = 0;

  /**
   * The uncommitted index count.
   *
   * @generated from field: uint32 uncommitted = 2;
   */
  uncommitted = 0;

  /**
   * The indexing index count.
   *
   * @generated from field: bool indexing = 3;
   */
  indexing = false;

  /**
   * The saving index count.
   *
   * @generated from field: bool saving = 4;
   */
  saving = false;

  constructor(data?: PartialMessage<Info_Index_Count>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Info.Index.Count";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stored", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "uncommitted", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "indexing", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "saving", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Info_Index_Count {
    return new Info_Index_Count().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Info_Index_Count {
    return new Info_Index_Count().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Info_Index_Count {
    return new Info_Index_Count().fromJsonString(jsonString, options);
  }

  static equals(a: Info_Index_Count | PlainMessage<Info_Index_Count> | undefined, b: Info_Index_Count | PlainMessage<Info_Index_Count> | undefined): boolean {
    return proto3.util.equals(Info_Index_Count, a, b);
  }
}

/**
 * Represent the UUID message.
 *
 * @generated from message payload.v1.Info.Index.UUID
 */
export class Info_Index_UUID extends Message<Info_Index_UUID> {
  constructor(data?: PartialMessage<Info_Index_UUID>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Info.Index.UUID";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Info_Index_UUID {
    return new Info_Index_UUID().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Info_Index_UUID {
    return new Info_Index_UUID().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Info_Index_UUID {
    return new Info_Index_UUID().fromJsonString(jsonString, options);
  }

  static equals(a: Info_Index_UUID | PlainMessage<Info_Index_UUID> | undefined, b: Info_Index_UUID | PlainMessage<Info_Index_UUID> | undefined): boolean {
    return proto3.util.equals(Info_Index_UUID, a, b);
  }
}

/**
 * The committed UUID.
 *
 * @generated from message payload.v1.Info.Index.UUID.Committed
 */
export class Info_Index_UUID_Committed extends Message<Info_Index_UUID_Committed> {
  /**
   * @generated from field: string uuid = 1;
   */
  uuid = "";

  constructor(data?: PartialMessage<Info_Index_UUID_Committed>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Info.Index.UUID.Committed";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Info_Index_UUID_Committed {
    return new Info_Index_UUID_Committed().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Info_Index_UUID_Committed {
    return new Info_Index_UUID_Committed().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Info_Index_UUID_Committed {
    return new Info_Index_UUID_Committed().fromJsonString(jsonString, options);
  }

  static equals(a: Info_Index_UUID_Committed | PlainMessage<Info_Index_UUID_Committed> | undefined, b: Info_Index_UUID_Committed | PlainMessage<Info_Index_UUID_Committed> | undefined): boolean {
    return proto3.util.equals(Info_Index_UUID_Committed, a, b);
  }
}

/**
 * The uncommitted UUID.
 *
 * @generated from message payload.v1.Info.Index.UUID.Uncommitted
 */
export class Info_Index_UUID_Uncommitted extends Message<Info_Index_UUID_Uncommitted> {
  /**
   * @generated from field: string uuid = 1;
   */
  uuid = "";

  constructor(data?: PartialMessage<Info_Index_UUID_Uncommitted>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Info.Index.UUID.Uncommitted";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Info_Index_UUID_Uncommitted {
    return new Info_Index_UUID_Uncommitted().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Info_Index_UUID_Uncommitted {
    return new Info_Index_UUID_Uncommitted().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Info_Index_UUID_Uncommitted {
    return new Info_Index_UUID_Uncommitted().fromJsonString(jsonString, options);
  }

  static equals(a: Info_Index_UUID_Uncommitted | PlainMessage<Info_Index_UUID_Uncommitted> | undefined, b: Info_Index_UUID_Uncommitted | PlainMessage<Info_Index_UUID_Uncommitted> | undefined): boolean {
    return proto3.util.equals(Info_Index_UUID_Uncommitted, a, b);
  }
}

/**
 * Represent the pod information message.
 *
 * @generated from message payload.v1.Info.Pod
 */
export class Info_Pod extends Message<Info_Pod> {
  /**
   * The app name of the pod on the label.
   *
   * @generated from field: string app_name = 1;
   */
  appName = "";

  /**
   * The name of the pod.
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * The namespace of the pod.
   *
   * @generated from field: string namespace = 3;
   */
  namespace = "";

  /**
   * The IP of the pod.
   *
   * @generated from field: string ip = 4;
   */
  ip = "";

  /**
   * The CPU information of the pod.
   *
   * @generated from field: payload.v1.Info.CPU cpu = 5;
   */
  cpu?: Info_CPU;

  /**
   * The memory information of the pod.
   *
   * @generated from field: payload.v1.Info.Memory memory = 6;
   */
  memory?: Info_Memory;

  /**
   * The node information of the pod.
   *
   * @generated from field: payload.v1.Info.Node node = 7;
   */
  node?: Info_Node;

  constructor(data?: PartialMessage<Info_Pod>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Info.Pod";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "app_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "ip", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "cpu", kind: "message", T: Info_CPU },
    { no: 6, name: "memory", kind: "message", T: Info_Memory },
    { no: 7, name: "node", kind: "message", T: Info_Node },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Info_Pod {
    return new Info_Pod().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Info_Pod {
    return new Info_Pod().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Info_Pod {
    return new Info_Pod().fromJsonString(jsonString, options);
  }

  static equals(a: Info_Pod | PlainMessage<Info_Pod> | undefined, b: Info_Pod | PlainMessage<Info_Pod> | undefined): boolean {
    return proto3.util.equals(Info_Pod, a, b);
  }
}

/**
 * Represent the node information message.
 *
 * @generated from message payload.v1.Info.Node
 */
export class Info_Node extends Message<Info_Node> {
  /**
   * The name of the node.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The internal IP address of the node.
   *
   * @generated from field: string internal_addr = 2;
   */
  internalAddr = "";

  /**
   * The external IP address of the node.
   *
   * @generated from field: string external_addr = 3;
   */
  externalAddr = "";

  /**
   * The CPU information of the node.
   *
   * @generated from field: payload.v1.Info.CPU cpu = 4;
   */
  cpu?: Info_CPU;

  /**
   * The memory information of the node.
   *
   * @generated from field: payload.v1.Info.Memory memory = 5;
   */
  memory?: Info_Memory;

  /**
   * The pod information of the node.
   *
   * @generated from field: payload.v1.Info.Pods Pods = 6;
   */
  Pods?: Info_Pods;

  constructor(data?: PartialMessage<Info_Node>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Info.Node";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "internal_addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "external_addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "cpu", kind: "message", T: Info_CPU },
    { no: 5, name: "memory", kind: "message", T: Info_Memory },
    { no: 6, name: "Pods", kind: "message", T: Info_Pods },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Info_Node {
    return new Info_Node().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Info_Node {
    return new Info_Node().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Info_Node {
    return new Info_Node().fromJsonString(jsonString, options);
  }

  static equals(a: Info_Node | PlainMessage<Info_Node> | undefined, b: Info_Node | PlainMessage<Info_Node> | undefined): boolean {
    return proto3.util.equals(Info_Node, a, b);
  }
}

/**
 * Represent the service information message.
 *
 * @generated from message payload.v1.Info.Service
 */
export class Info_Service extends Message<Info_Service> {
  /**
   * The name of the svc.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The cluster ip of the svc.
   *
   * @generated from field: string cluster_ip = 2;
   */
  clusterIp = "";

  /**
   * The cluster ips of the svc.
   *
   * @generated from field: repeated string cluster_ips = 3;
   */
  clusterIps: string[] = [];

  /**
   * The port of the svc.
   *
   * @generated from field: repeated payload.v1.Info.ServicePort ports = 4;
   */
  ports: Info_ServicePort[] = [];

  /**
   * The labels of the service.
   *
   * @generated from field: payload.v1.Info.Labels labels = 5;
   */
  labels?: Info_Labels;

  /**
   * The annotations of the service.
   *
   * @generated from field: payload.v1.Info.Annotations annotations = 6;
   */
  annotations?: Info_Annotations;

  constructor(data?: PartialMessage<Info_Service>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Info.Service";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cluster_ip", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_ips", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "ports", kind: "message", T: Info_ServicePort, repeated: true },
    { no: 5, name: "labels", kind: "message", T: Info_Labels },
    { no: 6, name: "annotations", kind: "message", T: Info_Annotations },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Info_Service {
    return new Info_Service().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Info_Service {
    return new Info_Service().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Info_Service {
    return new Info_Service().fromJsonString(jsonString, options);
  }

  static equals(a: Info_Service | PlainMessage<Info_Service> | undefined, b: Info_Service | PlainMessage<Info_Service> | undefined): boolean {
    return proto3.util.equals(Info_Service, a, b);
  }
}

/**
 * Represets the service port information message.
 *
 * @generated from message payload.v1.Info.ServicePort
 */
export class Info_ServicePort extends Message<Info_ServicePort> {
  /**
   * The name of the port.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The port number
   *
   * @generated from field: int32 port = 2;
   */
  port = 0;

  constructor(data?: PartialMessage<Info_ServicePort>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Info.ServicePort";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "port", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Info_ServicePort {
    return new Info_ServicePort().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Info_ServicePort {
    return new Info_ServicePort().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Info_ServicePort {
    return new Info_ServicePort().fromJsonString(jsonString, options);
  }

  static equals(a: Info_ServicePort | PlainMessage<Info_ServicePort> | undefined, b: Info_ServicePort | PlainMessage<Info_ServicePort> | undefined): boolean {
    return proto3.util.equals(Info_ServicePort, a, b);
  }
}

/**
 * Represent the kubernetes labels.
 *
 * @generated from message payload.v1.Info.Labels
 */
export class Info_Labels extends Message<Info_Labels> {
  /**
   * @generated from field: map<string, string> labels = 1;
   */
  labels: { [key: string]: string } = {};

  constructor(data?: PartialMessage<Info_Labels>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Info.Labels";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Info_Labels {
    return new Info_Labels().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Info_Labels {
    return new Info_Labels().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Info_Labels {
    return new Info_Labels().fromJsonString(jsonString, options);
  }

  static equals(a: Info_Labels | PlainMessage<Info_Labels> | undefined, b: Info_Labels | PlainMessage<Info_Labels> | undefined): boolean {
    return proto3.util.equals(Info_Labels, a, b);
  }
}

/**
 * Represent the kubernetes annotations.
 *
 * @generated from message payload.v1.Info.Annotations
 */
export class Info_Annotations extends Message<Info_Annotations> {
  /**
   * @generated from field: map<string, string> annotations = 1;
   */
  annotations: { [key: string]: string } = {};

  constructor(data?: PartialMessage<Info_Annotations>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Info.Annotations";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "annotations", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Info_Annotations {
    return new Info_Annotations().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Info_Annotations {
    return new Info_Annotations().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Info_Annotations {
    return new Info_Annotations().fromJsonString(jsonString, options);
  }

  static equals(a: Info_Annotations | PlainMessage<Info_Annotations> | undefined, b: Info_Annotations | PlainMessage<Info_Annotations> | undefined): boolean {
    return proto3.util.equals(Info_Annotations, a, b);
  }
}

/**
 * Represent the CPU information message.
 *
 * @generated from message payload.v1.Info.CPU
 */
export class Info_CPU extends Message<Info_CPU> {
  /**
   * The CPU resource limit.
   *
   * @generated from field: double limit = 1;
   */
  limit = 0;

  /**
   * The CPU resource requested.
   *
   * @generated from field: double request = 2;
   */
  request = 0;

  /**
   * The CPU usage.
   *
   * @generated from field: double usage = 3;
   */
  usage = 0;

  constructor(data?: PartialMessage<Info_CPU>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Info.CPU";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "limit", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "request", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "usage", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Info_CPU {
    return new Info_CPU().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Info_CPU {
    return new Info_CPU().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Info_CPU {
    return new Info_CPU().fromJsonString(jsonString, options);
  }

  static equals(a: Info_CPU | PlainMessage<Info_CPU> | undefined, b: Info_CPU | PlainMessage<Info_CPU> | undefined): boolean {
    return proto3.util.equals(Info_CPU, a, b);
  }
}

/**
 * Represent the memory information message.
 *
 * @generated from message payload.v1.Info.Memory
 */
export class Info_Memory extends Message<Info_Memory> {
  /**
   * The memory limit.
   *
   * @generated from field: double limit = 1;
   */
  limit = 0;

  /**
   * The memory requested.
   *
   * @generated from field: double request = 2;
   */
  request = 0;

  /**
   * The memory usage.
   *
   * @generated from field: double usage = 3;
   */
  usage = 0;

  constructor(data?: PartialMessage<Info_Memory>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Info.Memory";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "limit", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "request", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "usage", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Info_Memory {
    return new Info_Memory().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Info_Memory {
    return new Info_Memory().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Info_Memory {
    return new Info_Memory().fromJsonString(jsonString, options);
  }

  static equals(a: Info_Memory | PlainMessage<Info_Memory> | undefined, b: Info_Memory | PlainMessage<Info_Memory> | undefined): boolean {
    return proto3.util.equals(Info_Memory, a, b);
  }
}

/**
 * Represent the multiple pod information message.
 *
 * @generated from message payload.v1.Info.Pods
 */
export class Info_Pods extends Message<Info_Pods> {
  /**
   * The multiple pod information.
   *
   * @generated from field: repeated payload.v1.Info.Pod pods = 1;
   */
  pods: Info_Pod[] = [];

  constructor(data?: PartialMessage<Info_Pods>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Info.Pods";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pods", kind: "message", T: Info_Pod, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Info_Pods {
    return new Info_Pods().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Info_Pods {
    return new Info_Pods().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Info_Pods {
    return new Info_Pods().fromJsonString(jsonString, options);
  }

  static equals(a: Info_Pods | PlainMessage<Info_Pods> | undefined, b: Info_Pods | PlainMessage<Info_Pods> | undefined): boolean {
    return proto3.util.equals(Info_Pods, a, b);
  }
}

/**
 * Represent the multiple node information message.
 *
 * @generated from message payload.v1.Info.Nodes
 */
export class Info_Nodes extends Message<Info_Nodes> {
  /**
   * The multiple node information.
   *
   * @generated from field: repeated payload.v1.Info.Node nodes = 1;
   */
  nodes: Info_Node[] = [];

  constructor(data?: PartialMessage<Info_Nodes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Info.Nodes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nodes", kind: "message", T: Info_Node, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Info_Nodes {
    return new Info_Nodes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Info_Nodes {
    return new Info_Nodes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Info_Nodes {
    return new Info_Nodes().fromJsonString(jsonString, options);
  }

  static equals(a: Info_Nodes | PlainMessage<Info_Nodes> | undefined, b: Info_Nodes | PlainMessage<Info_Nodes> | undefined): boolean {
    return proto3.util.equals(Info_Nodes, a, b);
  }
}

/**
 * Represent the multiple service information message.
 *
 * @generated from message payload.v1.Info.Services
 */
export class Info_Services extends Message<Info_Services> {
  /**
   * The multiple service information.
   *
   * @generated from field: repeated payload.v1.Info.Service services = 1;
   */
  services: Info_Service[] = [];

  constructor(data?: PartialMessage<Info_Services>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Info.Services";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "services", kind: "message", T: Info_Service, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Info_Services {
    return new Info_Services().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Info_Services {
    return new Info_Services().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Info_Services {
    return new Info_Services().fromJsonString(jsonString, options);
  }

  static equals(a: Info_Services | PlainMessage<Info_Services> | undefined, b: Info_Services | PlainMessage<Info_Services> | undefined): boolean {
    return proto3.util.equals(Info_Services, a, b);
  }
}

/**
 * Represent the multiple IP message.
 *
 * @generated from message payload.v1.Info.IPs
 */
export class Info_IPs extends Message<Info_IPs> {
  /**
   * @generated from field: repeated string ip = 1;
   */
  ip: string[] = [];

  constructor(data?: PartialMessage<Info_IPs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Info.IPs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ip", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Info_IPs {
    return new Info_IPs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Info_IPs {
    return new Info_IPs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Info_IPs {
    return new Info_IPs().fromJsonString(jsonString, options);
  }

  static equals(a: Info_IPs | PlainMessage<Info_IPs> | undefined, b: Info_IPs | PlainMessage<Info_IPs> | undefined): boolean {
    return proto3.util.equals(Info_IPs, a, b);
  }
}

/**
 * Represent an empty message.
 *
 * @generated from message payload.v1.Empty
 */
export class Empty extends Message<Empty> {
  constructor(data?: PartialMessage<Empty>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "payload.v1.Empty";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Empty {
    return new Empty().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Empty {
    return new Empty().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Empty {
    return new Empty().fromJsonString(jsonString, options);
  }

  static equals(a: Empty | PlainMessage<Empty> | undefined, b: Empty | PlainMessage<Empty> | undefined): boolean {
    return proto3.util.equals(Empty, a, b);
  }
}

