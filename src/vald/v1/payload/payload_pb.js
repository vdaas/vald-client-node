/* eslint-disable */
// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix,client_grpc1,generate_dependencies,keep_enum_prefix,ts_nocheck,use_proto_field_name,output_javascript,output_legacy_commonjs,eslint_disable
// @generated from protobuf file "vald/v1/payload/payload.proto" (package "payload.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
//
//
// Copyright (C) 2019-2025 vdaas.org vald team <vald@vdaas.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Empty = exports.Meta_KeyValue = exports.Meta_Value = exports.Meta_Key = exports.Meta = exports.Mirror_Targets = exports.Mirror_Target = exports.Mirror = exports.Info_IPs = exports.Info_Services = exports.Info_Nodes = exports.Info_Pods = exports.Info_Memory = exports.Info_CPU = exports.Info_Annotations = exports.Info_Labels = exports.Info_ServicePort = exports.Info_Service = exports.Info_Node = exports.Info_Pod = exports.Info_CgroupStats = exports.Info_ResourceStats = exports.Info_Index_PropertyDetail = exports.Info_Index_Property = exports.Info_Index_StatisticsDetail = exports.Info_Index_Statistics = exports.Info_Index_UUID_Uncommitted = exports.Info_Index_UUID_Committed = exports.Info_Index_UUID = exports.Info_Index_Detail = exports.Info_Index_Count = exports.Info_Index = exports.Info = exports.Discoverer_Request = exports.Discoverer = exports.Control_CreateIndexRequest = exports.Control = exports.Object_List_Response = exports.Object_List_Request = exports.Object_List = exports.Object_Locations = exports.Object_StreamLocation = exports.Object_Location = exports.Object_StreamBlob = exports.Object_Blob = exports.Object_ReshapeVector = exports.Object_StreamVector = exports.Object_Vectors = exports.Object_Timestamp = exports.Object_TimestampRequest = exports.Object_Vector = exports.Object_IDs = exports.Object_ID = exports.Object_StreamDistance = exports.Object_Distance = exports.Object_VectorRequest = exports.Object = exports.Flush_Request = exports.Flush = exports.Remove_Config = exports.Remove_Timestamp = exports.Remove_TimestampRequest = exports.Remove_MultiRequest = exports.Remove_Request = exports.Remove = exports.Upsert_Config = exports.Upsert_MultiObjectRequest = exports.Upsert_ObjectRequest = exports.Upsert_MultiRequest = exports.Upsert_Request = exports.Upsert = exports.Update_Config = exports.Update_TimestampRequest = exports.Update_MultiObjectRequest = exports.Update_ObjectRequest = exports.Update_MultiRequest = exports.Update_Request = exports.Update = exports.Insert_Config = exports.Insert_MultiObjectRequest = exports.Insert_ObjectRequest = exports.Insert_MultiRequest = exports.Insert_Request = exports.Insert = exports.Filter_Config = exports.Filter_Target = exports.Filter = exports.Search_StreamResponse = exports.Search_Responses = exports.Search_Response = exports.Search_Config = exports.Search_MultiObjectRequest = exports.Search_ObjectRequest = exports.Search_MultiIDRequest = exports.Search_IDRequest = exports.Search_MultiRequest = exports.Search_Request = exports.Search = exports.Remove_Timestamp_Operator = exports.Search_AggregationAlgorithm = void 0;
/* eslint-disable */
// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix,client_grpc1,generate_dependencies,keep_enum_prefix,ts_nocheck,use_proto_field_name,output_javascript,output_legacy_commonjs,eslint_disable
// @generated from protobuf file "vald/v1/payload/payload.proto" (package "payload.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
//
//
// Copyright (C) 2019-2025 vdaas.org vald team <vald@vdaas.org>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
const runtime_1 = require("@protobuf-ts/runtime");
const runtime_2 = require("@protobuf-ts/runtime");
const runtime_3 = require("@protobuf-ts/runtime");
const runtime_4 = require("@protobuf-ts/runtime");
const any_pb_1 = require("../../../google/protobuf/any_pb");
const status_pb_1 = require("../../../google/rpc/status_pb");
const wrappers_pb_1 = require("../../../google/protobuf/wrappers_pb");
/**
 * AggregationAlgorithm is enum of each aggregation algorithms
 *
 * @generated from protobuf enum payload.v1.Search.AggregationAlgorithm
 */
var Search_AggregationAlgorithm;
(function (Search_AggregationAlgorithm) {
    /**
     * @generated from protobuf enum value: Unknown = 0;
     */
    Search_AggregationAlgorithm[Search_AggregationAlgorithm["Unknown"] = 0] = "Unknown";
    /**
     * @generated from protobuf enum value: ConcurrentQueue = 1;
     */
    Search_AggregationAlgorithm[Search_AggregationAlgorithm["ConcurrentQueue"] = 1] = "ConcurrentQueue";
    /**
     * @generated from protobuf enum value: SortSlice = 2;
     */
    Search_AggregationAlgorithm[Search_AggregationAlgorithm["SortSlice"] = 2] = "SortSlice";
    /**
     * @generated from protobuf enum value: SortPoolSlice = 3;
     */
    Search_AggregationAlgorithm[Search_AggregationAlgorithm["SortPoolSlice"] = 3] = "SortPoolSlice";
    /**
     * @generated from protobuf enum value: PairingHeap = 4;
     */
    Search_AggregationAlgorithm[Search_AggregationAlgorithm["PairingHeap"] = 4] = "PairingHeap";
})(Search_AggregationAlgorithm = exports.Search_AggregationAlgorithm || (exports.Search_AggregationAlgorithm = {}));
/**
 * Operator is enum of each conditional operator.
 *
 * @generated from protobuf enum payload.v1.Remove.Timestamp.Operator
 */
var Remove_Timestamp_Operator;
(function (Remove_Timestamp_Operator) {
    /**
     * The timestamp is equal to the specified value in the request.
     *
     * @generated from protobuf enum value: Eq = 0;
     */
    Remove_Timestamp_Operator[Remove_Timestamp_Operator["Eq"] = 0] = "Eq";
    /**
     * The timestamp is not equal to the specified value in the request.
     *
     * @generated from protobuf enum value: Ne = 1;
     */
    Remove_Timestamp_Operator[Remove_Timestamp_Operator["Ne"] = 1] = "Ne";
    /**
     * The timestamp is greater than or equal to the specified value in the
     * request.
     *
     * @generated from protobuf enum value: Ge = 2;
     */
    Remove_Timestamp_Operator[Remove_Timestamp_Operator["Ge"] = 2] = "Ge";
    /**
     * The timestamp is greater than the specified value in the request.
     *
     * @generated from protobuf enum value: Gt = 3;
     */
    Remove_Timestamp_Operator[Remove_Timestamp_Operator["Gt"] = 3] = "Gt";
    /**
     * The timestamp is less than or equal to the specified value in the
     * request.
     *
     * @generated from protobuf enum value: Le = 4;
     */
    Remove_Timestamp_Operator[Remove_Timestamp_Operator["Le"] = 4] = "Le";
    /**
     * The timestamp is less than the specified value in the request.
     *
     * @generated from protobuf enum value: Lt = 5;
     */
    Remove_Timestamp_Operator[Remove_Timestamp_Operator["Lt"] = 5] = "Lt";
})(Remove_Timestamp_Operator = exports.Remove_Timestamp_Operator || (exports.Remove_Timestamp_Operator = {}));
// @generated message type with reflection information, may provide speed optimized methods
class Search$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Search", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Search
 */
exports.Search = new Search$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Search_Request$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Search.Request", [
            { no: 1, name: "vector", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/, options: { "buf.validate.field": { repeated: { minItems: "2" } } } },
            { no: 2, name: "config", kind: "message", T: () => exports.Search_Config }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.vector = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated float vector */ 1:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.vector.push(reader.float());
                    else
                        message.vector.push(reader.float());
                    break;
                case /* payload.v1.Search.Config config */ 2:
                    message.config = exports.Search_Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated float vector = 1; */
        if (message.vector.length) {
            writer.tag(1, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.vector.length; i++)
                writer.float(message.vector[i]);
            writer.join();
        }
        /* payload.v1.Search.Config config = 2; */
        if (message.config)
            exports.Search_Config.internalBinaryWrite(message.config, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Search.Request
 */
exports.Search_Request = new Search_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Search_MultiRequest$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Search.MultiRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Search_Request }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.requests = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Search.Request requests */ 1:
                    message.requests.push(exports.Search_Request.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated payload.v1.Search.Request requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            exports.Search_Request.internalBinaryWrite(message.requests[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Search.MultiRequest
 */
exports.Search_MultiRequest = new Search_MultiRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Search_IDRequest$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Search.IDRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "config", kind: "message", T: () => exports.Search_Config }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = "";
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* payload.v1.Search.Config config */ 2:
                    message.config = exports.Search_Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.id);
        /* payload.v1.Search.Config config = 2; */
        if (message.config)
            exports.Search_Config.internalBinaryWrite(message.config, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Search.IDRequest
 */
exports.Search_IDRequest = new Search_IDRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Search_MultiIDRequest$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Search.MultiIDRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Search_IDRequest }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.requests = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Search.IDRequest requests */ 1:
                    message.requests.push(exports.Search_IDRequest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated payload.v1.Search.IDRequest requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            exports.Search_IDRequest.internalBinaryWrite(message.requests[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Search.MultiIDRequest
 */
exports.Search_MultiIDRequest = new Search_MultiIDRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Search_ObjectRequest$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Search.ObjectRequest", [
            { no: 1, name: "object", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "config", kind: "message", T: () => exports.Search_Config },
            { no: 3, name: "vectorizer", kind: "message", T: () => exports.Filter_Target }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.object = new Uint8Array(0);
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes object */ 1:
                    message.object = reader.bytes();
                    break;
                case /* payload.v1.Search.Config config */ 2:
                    message.config = exports.Search_Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                case /* payload.v1.Filter.Target vectorizer */ 3:
                    message.vectorizer = exports.Filter_Target.internalBinaryRead(reader, reader.uint32(), options, message.vectorizer);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes object = 1; */
        if (message.object.length)
            writer.tag(1, runtime_1.WireType.LengthDelimited).bytes(message.object);
        /* payload.v1.Search.Config config = 2; */
        if (message.config)
            exports.Search_Config.internalBinaryWrite(message.config, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Filter.Target vectorizer = 3; */
        if (message.vectorizer)
            exports.Filter_Target.internalBinaryWrite(message.vectorizer, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Search.ObjectRequest
 */
exports.Search_ObjectRequest = new Search_ObjectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Search_MultiObjectRequest$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Search.MultiObjectRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Search_ObjectRequest }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.requests = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Search.ObjectRequest requests */ 1:
                    message.requests.push(exports.Search_ObjectRequest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated payload.v1.Search.ObjectRequest requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            exports.Search_ObjectRequest.internalBinaryWrite(message.requests[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Search.MultiObjectRequest
 */
exports.Search_MultiObjectRequest = new Search_MultiObjectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Search_Config$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Search.Config", [
            { no: 1, name: "request_id", kind: "scalar", localName: "request_id", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "num", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "buf.validate.field": { uint32: { gte: 1 } } } },
            { no: 3, name: "radius", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "epsilon", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "timeout", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "ingress_filters", kind: "message", localName: "ingress_filters", T: () => exports.Filter_Config },
            { no: 7, name: "egress_filters", kind: "message", localName: "egress_filters", T: () => exports.Filter_Config },
            { no: 8, name: "min_num", kind: "scalar", localName: "min_num", T: 13 /*ScalarType.UINT32*/, options: { "buf.validate.field": { uint32: { gte: 0 } } } },
            { no: 9, name: "aggregation_algorithm", kind: "enum", localName: "aggregation_algorithm", T: () => ["payload.v1.Search.AggregationAlgorithm", Search_AggregationAlgorithm] },
            { no: 10, name: "ratio", kind: "message", T: () => wrappers_pb_1.FloatValue },
            { no: 11, name: "nprobe", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.request_id = "";
        message.num = 0;
        message.radius = 0;
        message.epsilon = 0;
        message.timeout = 0n;
        message.min_num = 0;
        message.aggregation_algorithm = 0;
        message.nprobe = 0;
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string request_id */ 1:
                    message.request_id = reader.string();
                    break;
                case /* uint32 num */ 2:
                    message.num = reader.uint32();
                    break;
                case /* float radius */ 3:
                    message.radius = reader.float();
                    break;
                case /* float epsilon */ 4:
                    message.epsilon = reader.float();
                    break;
                case /* int64 timeout */ 5:
                    message.timeout = reader.int64().toBigInt();
                    break;
                case /* payload.v1.Filter.Config ingress_filters */ 6:
                    message.ingress_filters = exports.Filter_Config.internalBinaryRead(reader, reader.uint32(), options, message.ingress_filters);
                    break;
                case /* payload.v1.Filter.Config egress_filters */ 7:
                    message.egress_filters = exports.Filter_Config.internalBinaryRead(reader, reader.uint32(), options, message.egress_filters);
                    break;
                case /* uint32 min_num */ 8:
                    message.min_num = reader.uint32();
                    break;
                case /* payload.v1.Search.AggregationAlgorithm aggregation_algorithm */ 9:
                    message.aggregation_algorithm = reader.int32();
                    break;
                case /* google.protobuf.FloatValue ratio */ 10:
                    message.ratio = wrappers_pb_1.FloatValue.internalBinaryRead(reader, reader.uint32(), options, message.ratio);
                    break;
                case /* uint32 nprobe */ 11:
                    message.nprobe = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string request_id = 1; */
        if (message.request_id !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.request_id);
        /* uint32 num = 2; */
        if (message.num !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.num);
        /* float radius = 3; */
        if (message.radius !== 0)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.radius);
        /* float epsilon = 4; */
        if (message.epsilon !== 0)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.epsilon);
        /* int64 timeout = 5; */
        if (message.timeout !== 0n)
            writer.tag(5, runtime_1.WireType.Varint).int64(message.timeout);
        /* payload.v1.Filter.Config ingress_filters = 6; */
        if (message.ingress_filters)
            exports.Filter_Config.internalBinaryWrite(message.ingress_filters, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Filter.Config egress_filters = 7; */
        if (message.egress_filters)
            exports.Filter_Config.internalBinaryWrite(message.egress_filters, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 min_num = 8; */
        if (message.min_num !== 0)
            writer.tag(8, runtime_1.WireType.Varint).uint32(message.min_num);
        /* payload.v1.Search.AggregationAlgorithm aggregation_algorithm = 9; */
        if (message.aggregation_algorithm !== 0)
            writer.tag(9, runtime_1.WireType.Varint).int32(message.aggregation_algorithm);
        /* google.protobuf.FloatValue ratio = 10; */
        if (message.ratio)
            wrappers_pb_1.FloatValue.internalBinaryWrite(message.ratio, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 nprobe = 11; */
        if (message.nprobe !== 0)
            writer.tag(11, runtime_1.WireType.Varint).uint32(message.nprobe);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Search.Config
 */
exports.Search_Config = new Search_Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Search_Response$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Search.Response", [
            { no: 1, name: "request_id", kind: "scalar", localName: "request_id", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "results", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Object_Distance }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.request_id = "";
        message.results = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string request_id */ 1:
                    message.request_id = reader.string();
                    break;
                case /* repeated payload.v1.Object.Distance results */ 2:
                    message.results.push(exports.Object_Distance.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string request_id = 1; */
        if (message.request_id !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.request_id);
        /* repeated payload.v1.Object.Distance results = 2; */
        for (let i = 0; i < message.results.length; i++)
            exports.Object_Distance.internalBinaryWrite(message.results[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Search.Response
 */
exports.Search_Response = new Search_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Search_Responses$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Search.Responses", [
            { no: 1, name: "responses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Search_Response }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.responses = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Search.Response responses */ 1:
                    message.responses.push(exports.Search_Response.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated payload.v1.Search.Response responses = 1; */
        for (let i = 0; i < message.responses.length; i++)
            exports.Search_Response.internalBinaryWrite(message.responses[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Search.Responses
 */
exports.Search_Responses = new Search_Responses$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Search_StreamResponse$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Search.StreamResponse", [
            { no: 1, name: "response", kind: "message", oneof: "payload", T: () => exports.Search_Response },
            { no: 2, name: "status", kind: "message", oneof: "payload", T: () => status_pb_1.Status }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Search.Response response */ 1:
                    message.payload = {
                        oneofKind: "response",
                        response: exports.Search_Response.internalBinaryRead(reader, reader.uint32(), options, message.payload.response)
                    };
                    break;
                case /* google.rpc.Status status */ 2:
                    message.payload = {
                        oneofKind: "status",
                        status: status_pb_1.Status.internalBinaryRead(reader, reader.uint32(), options, message.payload.status)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* payload.v1.Search.Response response = 1; */
        if (message.payload.oneofKind === "response")
            exports.Search_Response.internalBinaryWrite(message.payload.response, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.rpc.Status status = 2; */
        if (message.payload.oneofKind === "status")
            status_pb_1.Status.internalBinaryWrite(message.payload.status, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Search.StreamResponse
 */
exports.Search_StreamResponse = new Search_StreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Filter$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Filter", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Filter
 */
exports.Filter = new Filter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Filter_Target$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Filter.Target", [
            { no: 1, name: "host", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.host = "";
        message.port = 0;
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string host */ 1:
                    message.host = reader.string();
                    break;
                case /* uint32 port */ 2:
                    message.port = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string host = 1; */
        if (message.host !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.host);
        /* uint32 port = 2; */
        if (message.port !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.port);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Filter.Target
 */
exports.Filter_Target = new Filter_Target$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Filter_Config$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Filter.Config", [
            { no: 1, name: "targets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Filter_Target }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.targets = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Filter.Target targets */ 1:
                    message.targets.push(exports.Filter_Target.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated payload.v1.Filter.Target targets = 1; */
        for (let i = 0; i < message.targets.length; i++)
            exports.Filter_Target.internalBinaryWrite(message.targets[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Filter.Config
 */
exports.Filter_Config = new Filter_Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Insert$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Insert", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Insert
 */
exports.Insert = new Insert$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Insert_Request$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Insert.Request", [
            { no: 1, name: "vector", kind: "message", T: () => exports.Object_Vector, options: { "buf.validate.field": { repeated: { minItems: "2" } } } },
            { no: 2, name: "config", kind: "message", T: () => exports.Insert_Config }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.Vector vector */ 1:
                    message.vector = exports.Object_Vector.internalBinaryRead(reader, reader.uint32(), options, message.vector);
                    break;
                case /* payload.v1.Insert.Config config */ 2:
                    message.config = exports.Insert_Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* payload.v1.Object.Vector vector = 1; */
        if (message.vector)
            exports.Object_Vector.internalBinaryWrite(message.vector, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Insert.Config config = 2; */
        if (message.config)
            exports.Insert_Config.internalBinaryWrite(message.config, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Insert.Request
 */
exports.Insert_Request = new Insert_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Insert_MultiRequest$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Insert.MultiRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Insert_Request }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.requests = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Insert.Request requests */ 1:
                    message.requests.push(exports.Insert_Request.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated payload.v1.Insert.Request requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            exports.Insert_Request.internalBinaryWrite(message.requests[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Insert.MultiRequest
 */
exports.Insert_MultiRequest = new Insert_MultiRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Insert_ObjectRequest$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Insert.ObjectRequest", [
            { no: 1, name: "object", kind: "message", T: () => exports.Object_Blob },
            { no: 2, name: "config", kind: "message", T: () => exports.Insert_Config },
            { no: 3, name: "vectorizer", kind: "message", T: () => exports.Filter_Target }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.Blob object */ 1:
                    message.object = exports.Object_Blob.internalBinaryRead(reader, reader.uint32(), options, message.object);
                    break;
                case /* payload.v1.Insert.Config config */ 2:
                    message.config = exports.Insert_Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                case /* payload.v1.Filter.Target vectorizer */ 3:
                    message.vectorizer = exports.Filter_Target.internalBinaryRead(reader, reader.uint32(), options, message.vectorizer);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* payload.v1.Object.Blob object = 1; */
        if (message.object)
            exports.Object_Blob.internalBinaryWrite(message.object, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Insert.Config config = 2; */
        if (message.config)
            exports.Insert_Config.internalBinaryWrite(message.config, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Filter.Target vectorizer = 3; */
        if (message.vectorizer)
            exports.Filter_Target.internalBinaryWrite(message.vectorizer, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Insert.ObjectRequest
 */
exports.Insert_ObjectRequest = new Insert_ObjectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Insert_MultiObjectRequest$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Insert.MultiObjectRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Insert_ObjectRequest }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.requests = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Insert.ObjectRequest requests */ 1:
                    message.requests.push(exports.Insert_ObjectRequest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated payload.v1.Insert.ObjectRequest requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            exports.Insert_ObjectRequest.internalBinaryWrite(message.requests[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Insert.MultiObjectRequest
 */
exports.Insert_MultiObjectRequest = new Insert_MultiObjectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Insert_Config$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Insert.Config", [
            { no: 1, name: "skip_strict_exist_check", kind: "scalar", localName: "skip_strict_exist_check", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "filters", kind: "message", T: () => exports.Filter_Config },
            { no: 3, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.skip_strict_exist_check = false;
        message.timestamp = 0n;
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool skip_strict_exist_check */ 1:
                    message.skip_strict_exist_check = reader.bool();
                    break;
                case /* payload.v1.Filter.Config filters */ 2:
                    message.filters = exports.Filter_Config.internalBinaryRead(reader, reader.uint32(), options, message.filters);
                    break;
                case /* int64 timestamp */ 3:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool skip_strict_exist_check = 1; */
        if (message.skip_strict_exist_check !== false)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.skip_strict_exist_check);
        /* payload.v1.Filter.Config filters = 2; */
        if (message.filters)
            exports.Filter_Config.internalBinaryWrite(message.filters, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* int64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, runtime_1.WireType.Varint).int64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Insert.Config
 */
exports.Insert_Config = new Insert_Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Update$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Update", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Update
 */
exports.Update = new Update$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Update_Request$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Update.Request", [
            { no: 1, name: "vector", kind: "message", T: () => exports.Object_Vector, options: { "buf.validate.field": { repeated: { minItems: "2" } } } },
            { no: 2, name: "config", kind: "message", T: () => exports.Update_Config }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.Vector vector */ 1:
                    message.vector = exports.Object_Vector.internalBinaryRead(reader, reader.uint32(), options, message.vector);
                    break;
                case /* payload.v1.Update.Config config */ 2:
                    message.config = exports.Update_Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* payload.v1.Object.Vector vector = 1; */
        if (message.vector)
            exports.Object_Vector.internalBinaryWrite(message.vector, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Update.Config config = 2; */
        if (message.config)
            exports.Update_Config.internalBinaryWrite(message.config, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Update.Request
 */
exports.Update_Request = new Update_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Update_MultiRequest$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Update.MultiRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Update_Request }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.requests = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Update.Request requests */ 1:
                    message.requests.push(exports.Update_Request.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated payload.v1.Update.Request requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            exports.Update_Request.internalBinaryWrite(message.requests[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Update.MultiRequest
 */
exports.Update_MultiRequest = new Update_MultiRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Update_ObjectRequest$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Update.ObjectRequest", [
            { no: 1, name: "object", kind: "message", T: () => exports.Object_Blob },
            { no: 2, name: "config", kind: "message", T: () => exports.Update_Config },
            { no: 3, name: "vectorizer", kind: "message", T: () => exports.Filter_Target }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.Blob object */ 1:
                    message.object = exports.Object_Blob.internalBinaryRead(reader, reader.uint32(), options, message.object);
                    break;
                case /* payload.v1.Update.Config config */ 2:
                    message.config = exports.Update_Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                case /* payload.v1.Filter.Target vectorizer */ 3:
                    message.vectorizer = exports.Filter_Target.internalBinaryRead(reader, reader.uint32(), options, message.vectorizer);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* payload.v1.Object.Blob object = 1; */
        if (message.object)
            exports.Object_Blob.internalBinaryWrite(message.object, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Update.Config config = 2; */
        if (message.config)
            exports.Update_Config.internalBinaryWrite(message.config, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Filter.Target vectorizer = 3; */
        if (message.vectorizer)
            exports.Filter_Target.internalBinaryWrite(message.vectorizer, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Update.ObjectRequest
 */
exports.Update_ObjectRequest = new Update_ObjectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Update_MultiObjectRequest$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Update.MultiObjectRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Update_ObjectRequest }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.requests = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Update.ObjectRequest requests */ 1:
                    message.requests.push(exports.Update_ObjectRequest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated payload.v1.Update.ObjectRequest requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            exports.Update_ObjectRequest.internalBinaryWrite(message.requests[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Update.MultiObjectRequest
 */
exports.Update_MultiObjectRequest = new Update_MultiObjectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Update_TimestampRequest$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Update.TimestampRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1" } } } },
            { no: 2, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "force", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = "";
        message.timestamp = 0n;
        message.force = false;
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* int64 timestamp */ 2:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                case /* bool force */ 3:
                    message.force = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.id);
        /* int64 timestamp = 2; */
        if (message.timestamp !== 0n)
            writer.tag(2, runtime_1.WireType.Varint).int64(message.timestamp);
        /* bool force = 3; */
        if (message.force !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.force);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Update.TimestampRequest
 */
exports.Update_TimestampRequest = new Update_TimestampRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Update_Config$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Update.Config", [
            { no: 1, name: "skip_strict_exist_check", kind: "scalar", localName: "skip_strict_exist_check", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "filters", kind: "message", T: () => exports.Filter_Config },
            { no: 3, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "disable_balanced_update", kind: "scalar", localName: "disable_balanced_update", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.skip_strict_exist_check = false;
        message.timestamp = 0n;
        message.disable_balanced_update = false;
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool skip_strict_exist_check */ 1:
                    message.skip_strict_exist_check = reader.bool();
                    break;
                case /* payload.v1.Filter.Config filters */ 2:
                    message.filters = exports.Filter_Config.internalBinaryRead(reader, reader.uint32(), options, message.filters);
                    break;
                case /* int64 timestamp */ 3:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                case /* bool disable_balanced_update */ 4:
                    message.disable_balanced_update = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool skip_strict_exist_check = 1; */
        if (message.skip_strict_exist_check !== false)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.skip_strict_exist_check);
        /* payload.v1.Filter.Config filters = 2; */
        if (message.filters)
            exports.Filter_Config.internalBinaryWrite(message.filters, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* int64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, runtime_1.WireType.Varint).int64(message.timestamp);
        /* bool disable_balanced_update = 4; */
        if (message.disable_balanced_update !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.disable_balanced_update);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Update.Config
 */
exports.Update_Config = new Update_Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Upsert$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Upsert", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Upsert
 */
exports.Upsert = new Upsert$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Upsert_Request$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Upsert.Request", [
            { no: 1, name: "vector", kind: "message", T: () => exports.Object_Vector, options: { "buf.validate.field": { repeated: { minItems: "2" } } } },
            { no: 2, name: "config", kind: "message", T: () => exports.Upsert_Config }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.Vector vector */ 1:
                    message.vector = exports.Object_Vector.internalBinaryRead(reader, reader.uint32(), options, message.vector);
                    break;
                case /* payload.v1.Upsert.Config config */ 2:
                    message.config = exports.Upsert_Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* payload.v1.Object.Vector vector = 1; */
        if (message.vector)
            exports.Object_Vector.internalBinaryWrite(message.vector, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Upsert.Config config = 2; */
        if (message.config)
            exports.Upsert_Config.internalBinaryWrite(message.config, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Upsert.Request
 */
exports.Upsert_Request = new Upsert_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Upsert_MultiRequest$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Upsert.MultiRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Upsert_Request }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.requests = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Upsert.Request requests */ 1:
                    message.requests.push(exports.Upsert_Request.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated payload.v1.Upsert.Request requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            exports.Upsert_Request.internalBinaryWrite(message.requests[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Upsert.MultiRequest
 */
exports.Upsert_MultiRequest = new Upsert_MultiRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Upsert_ObjectRequest$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Upsert.ObjectRequest", [
            { no: 1, name: "object", kind: "message", T: () => exports.Object_Blob },
            { no: 2, name: "config", kind: "message", T: () => exports.Upsert_Config },
            { no: 3, name: "vectorizer", kind: "message", T: () => exports.Filter_Target }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.Blob object */ 1:
                    message.object = exports.Object_Blob.internalBinaryRead(reader, reader.uint32(), options, message.object);
                    break;
                case /* payload.v1.Upsert.Config config */ 2:
                    message.config = exports.Upsert_Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                case /* payload.v1.Filter.Target vectorizer */ 3:
                    message.vectorizer = exports.Filter_Target.internalBinaryRead(reader, reader.uint32(), options, message.vectorizer);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* payload.v1.Object.Blob object = 1; */
        if (message.object)
            exports.Object_Blob.internalBinaryWrite(message.object, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Upsert.Config config = 2; */
        if (message.config)
            exports.Upsert_Config.internalBinaryWrite(message.config, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Filter.Target vectorizer = 3; */
        if (message.vectorizer)
            exports.Filter_Target.internalBinaryWrite(message.vectorizer, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Upsert.ObjectRequest
 */
exports.Upsert_ObjectRequest = new Upsert_ObjectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Upsert_MultiObjectRequest$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Upsert.MultiObjectRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Upsert_ObjectRequest }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.requests = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Upsert.ObjectRequest requests */ 1:
                    message.requests.push(exports.Upsert_ObjectRequest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated payload.v1.Upsert.ObjectRequest requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            exports.Upsert_ObjectRequest.internalBinaryWrite(message.requests[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Upsert.MultiObjectRequest
 */
exports.Upsert_MultiObjectRequest = new Upsert_MultiObjectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Upsert_Config$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Upsert.Config", [
            { no: 1, name: "skip_strict_exist_check", kind: "scalar", localName: "skip_strict_exist_check", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "filters", kind: "message", T: () => exports.Filter_Config },
            { no: 3, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "disable_balanced_update", kind: "scalar", localName: "disable_balanced_update", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.skip_strict_exist_check = false;
        message.timestamp = 0n;
        message.disable_balanced_update = false;
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool skip_strict_exist_check */ 1:
                    message.skip_strict_exist_check = reader.bool();
                    break;
                case /* payload.v1.Filter.Config filters */ 2:
                    message.filters = exports.Filter_Config.internalBinaryRead(reader, reader.uint32(), options, message.filters);
                    break;
                case /* int64 timestamp */ 3:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                case /* bool disable_balanced_update */ 4:
                    message.disable_balanced_update = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool skip_strict_exist_check = 1; */
        if (message.skip_strict_exist_check !== false)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.skip_strict_exist_check);
        /* payload.v1.Filter.Config filters = 2; */
        if (message.filters)
            exports.Filter_Config.internalBinaryWrite(message.filters, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* int64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, runtime_1.WireType.Varint).int64(message.timestamp);
        /* bool disable_balanced_update = 4; */
        if (message.disable_balanced_update !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.disable_balanced_update);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Upsert.Config
 */
exports.Upsert_Config = new Upsert_Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Remove$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Remove", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Remove
 */
exports.Remove = new Remove$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Remove_Request$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Remove.Request", [
            { no: 1, name: "id", kind: "message", T: () => exports.Object_ID },
            { no: 2, name: "config", kind: "message", T: () => exports.Remove_Config }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.ID id */ 1:
                    message.id = exports.Object_ID.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* payload.v1.Remove.Config config */ 2:
                    message.config = exports.Remove_Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* payload.v1.Object.ID id = 1; */
        if (message.id)
            exports.Object_ID.internalBinaryWrite(message.id, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Remove.Config config = 2; */
        if (message.config)
            exports.Remove_Config.internalBinaryWrite(message.config, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Remove.Request
 */
exports.Remove_Request = new Remove_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Remove_MultiRequest$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Remove.MultiRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Remove_Request }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.requests = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Remove.Request requests */ 1:
                    message.requests.push(exports.Remove_Request.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated payload.v1.Remove.Request requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            exports.Remove_Request.internalBinaryWrite(message.requests[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Remove.MultiRequest
 */
exports.Remove_MultiRequest = new Remove_MultiRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Remove_TimestampRequest$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Remove.TimestampRequest", [
            { no: 1, name: "timestamps", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Remove_Timestamp }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.timestamps = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Remove.Timestamp timestamps */ 1:
                    message.timestamps.push(exports.Remove_Timestamp.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated payload.v1.Remove.Timestamp timestamps = 1; */
        for (let i = 0; i < message.timestamps.length; i++)
            exports.Remove_Timestamp.internalBinaryWrite(message.timestamps[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Remove.TimestampRequest
 */
exports.Remove_TimestampRequest = new Remove_TimestampRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Remove_Timestamp$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Remove.Timestamp", [
            { no: 1, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "operator", kind: "enum", T: () => ["payload.v1.Remove.Timestamp.Operator", Remove_Timestamp_Operator] }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.timestamp = 0n;
        message.operator = 0;
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 timestamp */ 1:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                case /* payload.v1.Remove.Timestamp.Operator operator */ 2:
                    message.operator = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int64 timestamp = 1; */
        if (message.timestamp !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).int64(message.timestamp);
        /* payload.v1.Remove.Timestamp.Operator operator = 2; */
        if (message.operator !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.operator);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Remove.Timestamp
 */
exports.Remove_Timestamp = new Remove_Timestamp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Remove_Config$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Remove.Config", [
            { no: 1, name: "skip_strict_exist_check", kind: "scalar", localName: "skip_strict_exist_check", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.skip_strict_exist_check = false;
        message.timestamp = 0n;
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool skip_strict_exist_check */ 1:
                    message.skip_strict_exist_check = reader.bool();
                    break;
                case /* int64 timestamp */ 3:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool skip_strict_exist_check = 1; */
        if (message.skip_strict_exist_check !== false)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.skip_strict_exist_check);
        /* int64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, runtime_1.WireType.Varint).int64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Remove.Config
 */
exports.Remove_Config = new Remove_Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Flush$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Flush", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Flush
 */
exports.Flush = new Flush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Flush_Request$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Flush.Request", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Flush.Request
 */
exports.Flush_Request = new Flush_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Object", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object
 */
exports.Object = new Object$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_VectorRequest$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Object.VectorRequest", [
            { no: 1, name: "id", kind: "message", T: () => exports.Object_ID, options: { "buf.validate.field": { repeated: { minItems: "2" } } } },
            { no: 2, name: "filters", kind: "message", T: () => exports.Filter_Config }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.ID id */ 1:
                    message.id = exports.Object_ID.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* payload.v1.Filter.Config filters */ 2:
                    message.filters = exports.Filter_Config.internalBinaryRead(reader, reader.uint32(), options, message.filters);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* payload.v1.Object.ID id = 1; */
        if (message.id)
            exports.Object_ID.internalBinaryWrite(message.id, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Filter.Config filters = 2; */
        if (message.filters)
            exports.Filter_Config.internalBinaryWrite(message.filters, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.VectorRequest
 */
exports.Object_VectorRequest = new Object_VectorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_Distance$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Object.Distance", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "distance", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = "";
        message.distance = 0;
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* float distance */ 2:
                    message.distance = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.id);
        /* float distance = 2; */
        if (message.distance !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.distance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.Distance
 */
exports.Object_Distance = new Object_Distance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_StreamDistance$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Object.StreamDistance", [
            { no: 1, name: "distance", kind: "message", oneof: "payload", T: () => exports.Object_Distance },
            { no: 2, name: "status", kind: "message", oneof: "payload", T: () => status_pb_1.Status }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.Distance distance */ 1:
                    message.payload = {
                        oneofKind: "distance",
                        distance: exports.Object_Distance.internalBinaryRead(reader, reader.uint32(), options, message.payload.distance)
                    };
                    break;
                case /* google.rpc.Status status */ 2:
                    message.payload = {
                        oneofKind: "status",
                        status: status_pb_1.Status.internalBinaryRead(reader, reader.uint32(), options, message.payload.status)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* payload.v1.Object.Distance distance = 1; */
        if (message.payload.oneofKind === "distance")
            exports.Object_Distance.internalBinaryWrite(message.payload.distance, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.rpc.Status status = 2; */
        if (message.payload.oneofKind === "status")
            status_pb_1.Status.internalBinaryWrite(message.payload.status, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.StreamDistance
 */
exports.Object_StreamDistance = new Object_StreamDistance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_ID$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Object.ID", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1" } } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = "";
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.ID
 */
exports.Object_ID = new Object_ID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_IDs$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Object.IDs", [
            { no: 1, name: "ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.ids = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string ids */ 1:
                    message.ids.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated string ids = 1; */
        for (let i = 0; i < message.ids.length; i++)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.IDs
 */
exports.Object_IDs = new Object_IDs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_Vector$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Object.Vector", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1" } } } },
            { no: 2, name: "vector", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/, options: { "buf.validate.field": { repeated: { minItems: "2" } } } },
            { no: 3, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = "";
        message.vector = [];
        message.timestamp = 0n;
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* repeated float vector */ 2:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.vector.push(reader.float());
                    else
                        message.vector.push(reader.float());
                    break;
                case /* int64 timestamp */ 3:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.id);
        /* repeated float vector = 2; */
        if (message.vector.length) {
            writer.tag(2, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.vector.length; i++)
                writer.float(message.vector[i]);
            writer.join();
        }
        /* int64 timestamp = 3; */
        if (message.timestamp !== 0n)
            writer.tag(3, runtime_1.WireType.Varint).int64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.Vector
 */
exports.Object_Vector = new Object_Vector$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_TimestampRequest$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Object.TimestampRequest", [
            { no: 1, name: "id", kind: "message", T: () => exports.Object_ID, options: { "buf.validate.field": { repeated: { minItems: "2" } } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.ID id */ 1:
                    message.id = exports.Object_ID.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* payload.v1.Object.ID id = 1; */
        if (message.id)
            exports.Object_ID.internalBinaryWrite(message.id, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.TimestampRequest
 */
exports.Object_TimestampRequest = new Object_TimestampRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_Timestamp$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Object.Timestamp", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1" } } } },
            { no: 2, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = "";
        message.timestamp = 0n;
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* int64 timestamp */ 2:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.id);
        /* int64 timestamp = 2; */
        if (message.timestamp !== 0n)
            writer.tag(2, runtime_1.WireType.Varint).int64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.Timestamp
 */
exports.Object_Timestamp = new Object_Timestamp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_Vectors$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Object.Vectors", [
            { no: 1, name: "vectors", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Object_Vector }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.vectors = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Object.Vector vectors */ 1:
                    message.vectors.push(exports.Object_Vector.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated payload.v1.Object.Vector vectors = 1; */
        for (let i = 0; i < message.vectors.length; i++)
            exports.Object_Vector.internalBinaryWrite(message.vectors[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.Vectors
 */
exports.Object_Vectors = new Object_Vectors$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_StreamVector$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Object.StreamVector", [
            { no: 1, name: "vector", kind: "message", oneof: "payload", T: () => exports.Object_Vector },
            { no: 2, name: "status", kind: "message", oneof: "payload", T: () => status_pb_1.Status }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.Vector vector */ 1:
                    message.payload = {
                        oneofKind: "vector",
                        vector: exports.Object_Vector.internalBinaryRead(reader, reader.uint32(), options, message.payload.vector)
                    };
                    break;
                case /* google.rpc.Status status */ 2:
                    message.payload = {
                        oneofKind: "status",
                        status: status_pb_1.Status.internalBinaryRead(reader, reader.uint32(), options, message.payload.status)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* payload.v1.Object.Vector vector = 1; */
        if (message.payload.oneofKind === "vector")
            exports.Object_Vector.internalBinaryWrite(message.payload.vector, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.rpc.Status status = 2; */
        if (message.payload.oneofKind === "status")
            status_pb_1.Status.internalBinaryWrite(message.payload.status, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.StreamVector
 */
exports.Object_StreamVector = new Object_StreamVector$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_ReshapeVector$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Object.ReshapeVector", [
            { no: 1, name: "object", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "shape", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.object = new Uint8Array(0);
        message.shape = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes object */ 1:
                    message.object = reader.bytes();
                    break;
                case /* repeated int32 shape */ 2:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.shape.push(reader.int32());
                    else
                        message.shape.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes object = 1; */
        if (message.object.length)
            writer.tag(1, runtime_1.WireType.LengthDelimited).bytes(message.object);
        /* repeated int32 shape = 2; */
        if (message.shape.length) {
            writer.tag(2, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.shape.length; i++)
                writer.int32(message.shape[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.ReshapeVector
 */
exports.Object_ReshapeVector = new Object_ReshapeVector$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_Blob$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Object.Blob", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1" } } } },
            { no: 2, name: "object", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.id = "";
        message.object = new Uint8Array(0);
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* bytes object */ 2:
                    message.object = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.id);
        /* bytes object = 2; */
        if (message.object.length)
            writer.tag(2, runtime_1.WireType.LengthDelimited).bytes(message.object);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.Blob
 */
exports.Object_Blob = new Object_Blob$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_StreamBlob$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Object.StreamBlob", [
            { no: 1, name: "blob", kind: "message", oneof: "payload", T: () => exports.Object_Blob },
            { no: 2, name: "status", kind: "message", oneof: "payload", T: () => status_pb_1.Status }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.Blob blob */ 1:
                    message.payload = {
                        oneofKind: "blob",
                        blob: exports.Object_Blob.internalBinaryRead(reader, reader.uint32(), options, message.payload.blob)
                    };
                    break;
                case /* google.rpc.Status status */ 2:
                    message.payload = {
                        oneofKind: "status",
                        status: status_pb_1.Status.internalBinaryRead(reader, reader.uint32(), options, message.payload.status)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* payload.v1.Object.Blob blob = 1; */
        if (message.payload.oneofKind === "blob")
            exports.Object_Blob.internalBinaryWrite(message.payload.blob, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.rpc.Status status = 2; */
        if (message.payload.oneofKind === "status")
            status_pb_1.Status.internalBinaryWrite(message.payload.status, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.StreamBlob
 */
exports.Object_StreamBlob = new Object_StreamBlob$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_Location$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Object.Location", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ips", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.name = "";
        message.uuid = "";
        message.ips = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string uuid */ 2:
                    message.uuid = reader.string();
                    break;
                case /* repeated string ips */ 3:
                    message.ips.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string uuid = 2; */
        if (message.uuid !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.uuid);
        /* repeated string ips = 3; */
        for (let i = 0; i < message.ips.length; i++)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.ips[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.Location
 */
exports.Object_Location = new Object_Location$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_StreamLocation$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Object.StreamLocation", [
            { no: 1, name: "location", kind: "message", oneof: "payload", T: () => exports.Object_Location },
            { no: 2, name: "status", kind: "message", oneof: "payload", T: () => status_pb_1.Status }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.Location location */ 1:
                    message.payload = {
                        oneofKind: "location",
                        location: exports.Object_Location.internalBinaryRead(reader, reader.uint32(), options, message.payload.location)
                    };
                    break;
                case /* google.rpc.Status status */ 2:
                    message.payload = {
                        oneofKind: "status",
                        status: status_pb_1.Status.internalBinaryRead(reader, reader.uint32(), options, message.payload.status)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* payload.v1.Object.Location location = 1; */
        if (message.payload.oneofKind === "location")
            exports.Object_Location.internalBinaryWrite(message.payload.location, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.rpc.Status status = 2; */
        if (message.payload.oneofKind === "status")
            status_pb_1.Status.internalBinaryWrite(message.payload.status, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.StreamLocation
 */
exports.Object_StreamLocation = new Object_StreamLocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_Locations$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Object.Locations", [
            { no: 1, name: "locations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Object_Location }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.locations = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Object.Location locations */ 1:
                    message.locations.push(exports.Object_Location.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated payload.v1.Object.Location locations = 1; */
        for (let i = 0; i < message.locations.length; i++)
            exports.Object_Location.internalBinaryWrite(message.locations[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.Locations
 */
exports.Object_Locations = new Object_Locations$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_List$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Object.List", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.List
 */
exports.Object_List = new Object_List$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_List_Request$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Object.List.Request", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.List.Request
 */
exports.Object_List_Request = new Object_List_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object_List_Response$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Object.List.Response", [
            { no: 1, name: "vector", kind: "message", oneof: "payload", T: () => exports.Object_Vector },
            { no: 2, name: "status", kind: "message", oneof: "payload", T: () => status_pb_1.Status }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Object.Vector vector */ 1:
                    message.payload = {
                        oneofKind: "vector",
                        vector: exports.Object_Vector.internalBinaryRead(reader, reader.uint32(), options, message.payload.vector)
                    };
                    break;
                case /* google.rpc.Status status */ 2:
                    message.payload = {
                        oneofKind: "status",
                        status: status_pb_1.Status.internalBinaryRead(reader, reader.uint32(), options, message.payload.status)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* payload.v1.Object.Vector vector = 1; */
        if (message.payload.oneofKind === "vector")
            exports.Object_Vector.internalBinaryWrite(message.payload.vector, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.rpc.Status status = 2; */
        if (message.payload.oneofKind === "status")
            status_pb_1.Status.internalBinaryWrite(message.payload.status, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Object.List.Response
 */
exports.Object_List_Response = new Object_List_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Control$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Control", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Control
 */
exports.Control = new Control$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Control_CreateIndexRequest$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Control.CreateIndexRequest", [
            { no: 1, name: "pool_size", kind: "scalar", localName: "pool_size", T: 13 /*ScalarType.UINT32*/, options: { "buf.validate.field": { uint32: { gte: 0 } } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.pool_size = 0;
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 pool_size */ 1:
                    message.pool_size = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 pool_size = 1; */
        if (message.pool_size !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.pool_size);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Control.CreateIndexRequest
 */
exports.Control_CreateIndexRequest = new Control_CreateIndexRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Discoverer$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Discoverer", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Discoverer
 */
exports.Discoverer = new Discoverer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Discoverer_Request$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Discoverer.Request", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1" } } } },
            { no: 2, name: "namespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "node", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.name = "";
        message.namespace = "";
        message.node = "";
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string namespace */ 2:
                    message.namespace = reader.string();
                    break;
                case /* string node */ 3:
                    message.node = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string namespace = 2; */
        if (message.namespace !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.namespace);
        /* string node = 3; */
        if (message.node !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.node);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Discoverer.Request
 */
exports.Discoverer_Request = new Discoverer_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info
 */
exports.Info = new Info$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Index$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.Index", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Index
 */
exports.Info_Index = new Info_Index$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Index_Count$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.Index.Count", [
            { no: 1, name: "stored", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "uncommitted", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "indexing", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "saving", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.stored = 0;
        message.uncommitted = 0;
        message.indexing = false;
        message.saving = false;
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 stored */ 1:
                    message.stored = reader.uint32();
                    break;
                case /* uint32 uncommitted */ 2:
                    message.uncommitted = reader.uint32();
                    break;
                case /* bool indexing */ 3:
                    message.indexing = reader.bool();
                    break;
                case /* bool saving */ 4:
                    message.saving = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 stored = 1; */
        if (message.stored !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.stored);
        /* uint32 uncommitted = 2; */
        if (message.uncommitted !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.uncommitted);
        /* bool indexing = 3; */
        if (message.indexing !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.indexing);
        /* bool saving = 4; */
        if (message.saving !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.saving);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Index.Count
 */
exports.Info_Index_Count = new Info_Index_Count$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Index_Detail$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.Index.Detail", [
            { no: 1, name: "counts", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => exports.Info_Index_Count } },
            { no: 2, name: "replica", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "live_agents", kind: "scalar", localName: "live_agents", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.counts = {};
        message.replica = 0;
        message.live_agents = 0;
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, payload.v1.Info.Index.Count> counts */ 1:
                    this.binaryReadMap1(message.counts, reader, options);
                    break;
                case /* uint32 replica */ 2:
                    message.replica = reader.uint32();
                    break;
                case /* uint32 live_agents */ 3:
                    message.live_agents = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    binaryReadMap1(map, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = exports.Info_Index_Count.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for payload.v1.Info.Index.Detail.counts");
            }
        }
        map[key ?? ""] = val ?? exports.Info_Index_Count.create();
    }
    internalBinaryWrite(message, writer, options) {
        /* map<string, payload.v1.Info.Index.Count> counts = 1; */
        for (let k of globalThis.Object.keys(message.counts)) {
            writer.tag(1, runtime_1.WireType.LengthDelimited).fork().tag(1, runtime_1.WireType.LengthDelimited).string(k);
            writer.tag(2, runtime_1.WireType.LengthDelimited).fork();
            exports.Info_Index_Count.internalBinaryWrite(message.counts[k], writer, options);
            writer.join().join();
        }
        /* uint32 replica = 2; */
        if (message.replica !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.replica);
        /* uint32 live_agents = 3; */
        if (message.live_agents !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.live_agents);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Index.Detail
 */
exports.Info_Index_Detail = new Info_Index_Detail$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Index_UUID$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.Index.UUID", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Index.UUID
 */
exports.Info_Index_UUID = new Info_Index_UUID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Index_UUID_Committed$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.Index.UUID.Committed", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.uuid = "";
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Index.UUID.Committed
 */
exports.Info_Index_UUID_Committed = new Info_Index_UUID_Committed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Index_UUID_Uncommitted$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.Index.UUID.Uncommitted", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.uuid = "";
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Index.UUID.Uncommitted
 */
exports.Info_Index_UUID_Uncommitted = new Info_Index_UUID_Uncommitted$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Index_Statistics$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.Index.Statistics", [
            { no: 1, name: "valid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "median_indegree", kind: "scalar", localName: "median_indegree", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "median_outdegree", kind: "scalar", localName: "median_outdegree", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "max_number_of_indegree", kind: "scalar", localName: "max_number_of_indegree", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "max_number_of_outdegree", kind: "scalar", localName: "max_number_of_outdegree", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "min_number_of_indegree", kind: "scalar", localName: "min_number_of_indegree", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "min_number_of_outdegree", kind: "scalar", localName: "min_number_of_outdegree", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "mode_indegree", kind: "scalar", localName: "mode_indegree", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "mode_outdegree", kind: "scalar", localName: "mode_outdegree", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "nodes_skipped_for_10_edges", kind: "scalar", localName: "nodes_skipped_for_10_edges", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "nodes_skipped_for_indegree_distance", kind: "scalar", localName: "nodes_skipped_for_indegree_distance", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "number_of_edges", kind: "scalar", localName: "number_of_edges", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "number_of_indexed_objects", kind: "scalar", localName: "number_of_indexed_objects", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "number_of_nodes", kind: "scalar", localName: "number_of_nodes", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "number_of_nodes_without_edges", kind: "scalar", localName: "number_of_nodes_without_edges", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 16, name: "number_of_nodes_without_indegree", kind: "scalar", localName: "number_of_nodes_without_indegree", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 17, name: "number_of_objects", kind: "scalar", localName: "number_of_objects", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 18, name: "number_of_removed_objects", kind: "scalar", localName: "number_of_removed_objects", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 19, name: "size_of_object_repository", kind: "scalar", localName: "size_of_object_repository", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 20, name: "size_of_refinement_object_repository", kind: "scalar", localName: "size_of_refinement_object_repository", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 21, name: "variance_of_indegree", kind: "scalar", localName: "variance_of_indegree", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 22, name: "variance_of_outdegree", kind: "scalar", localName: "variance_of_outdegree", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 23, name: "mean_edge_length", kind: "scalar", localName: "mean_edge_length", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 24, name: "mean_edge_length_for_10_edges", kind: "scalar", localName: "mean_edge_length_for_10_edges", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 25, name: "mean_indegree_distance_for_10_edges", kind: "scalar", localName: "mean_indegree_distance_for_10_edges", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 26, name: "mean_number_of_edges_per_node", kind: "scalar", localName: "mean_number_of_edges_per_node", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 27, name: "c1_indegree", kind: "scalar", localName: "c1_indegree", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 28, name: "c5_indegree", kind: "scalar", localName: "c5_indegree", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 29, name: "c95_outdegree", kind: "scalar", localName: "c95_outdegree", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 30, name: "c99_outdegree", kind: "scalar", localName: "c99_outdegree", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 31, name: "indegree_count", kind: "scalar", localName: "indegree_count", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 32, name: "outdegree_histogram", kind: "scalar", localName: "outdegree_histogram", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 33, name: "indegree_histogram", kind: "scalar", localName: "indegree_histogram", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.valid = false;
        message.median_indegree = 0;
        message.median_outdegree = 0;
        message.max_number_of_indegree = 0n;
        message.max_number_of_outdegree = 0n;
        message.min_number_of_indegree = 0n;
        message.min_number_of_outdegree = 0n;
        message.mode_indegree = 0n;
        message.mode_outdegree = 0n;
        message.nodes_skipped_for_10_edges = 0n;
        message.nodes_skipped_for_indegree_distance = 0n;
        message.number_of_edges = 0n;
        message.number_of_indexed_objects = 0n;
        message.number_of_nodes = 0n;
        message.number_of_nodes_without_edges = 0n;
        message.number_of_nodes_without_indegree = 0n;
        message.number_of_objects = 0n;
        message.number_of_removed_objects = 0n;
        message.size_of_object_repository = 0n;
        message.size_of_refinement_object_repository = 0n;
        message.variance_of_indegree = 0;
        message.variance_of_outdegree = 0;
        message.mean_edge_length = 0;
        message.mean_edge_length_for_10_edges = 0;
        message.mean_indegree_distance_for_10_edges = 0;
        message.mean_number_of_edges_per_node = 0;
        message.c1_indegree = 0;
        message.c5_indegree = 0;
        message.c95_outdegree = 0;
        message.c99_outdegree = 0;
        message.indegree_count = [];
        message.outdegree_histogram = [];
        message.indegree_histogram = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool valid */ 1:
                    message.valid = reader.bool();
                    break;
                case /* int32 median_indegree */ 2:
                    message.median_indegree = reader.int32();
                    break;
                case /* int32 median_outdegree */ 3:
                    message.median_outdegree = reader.int32();
                    break;
                case /* uint64 max_number_of_indegree */ 4:
                    message.max_number_of_indegree = reader.uint64().toBigInt();
                    break;
                case /* uint64 max_number_of_outdegree */ 5:
                    message.max_number_of_outdegree = reader.uint64().toBigInt();
                    break;
                case /* uint64 min_number_of_indegree */ 6:
                    message.min_number_of_indegree = reader.uint64().toBigInt();
                    break;
                case /* uint64 min_number_of_outdegree */ 7:
                    message.min_number_of_outdegree = reader.uint64().toBigInt();
                    break;
                case /* uint64 mode_indegree */ 8:
                    message.mode_indegree = reader.uint64().toBigInt();
                    break;
                case /* uint64 mode_outdegree */ 9:
                    message.mode_outdegree = reader.uint64().toBigInt();
                    break;
                case /* uint64 nodes_skipped_for_10_edges */ 10:
                    message.nodes_skipped_for_10_edges = reader.uint64().toBigInt();
                    break;
                case /* uint64 nodes_skipped_for_indegree_distance */ 11:
                    message.nodes_skipped_for_indegree_distance = reader.uint64().toBigInt();
                    break;
                case /* uint64 number_of_edges */ 12:
                    message.number_of_edges = reader.uint64().toBigInt();
                    break;
                case /* uint64 number_of_indexed_objects */ 13:
                    message.number_of_indexed_objects = reader.uint64().toBigInt();
                    break;
                case /* uint64 number_of_nodes */ 14:
                    message.number_of_nodes = reader.uint64().toBigInt();
                    break;
                case /* uint64 number_of_nodes_without_edges */ 15:
                    message.number_of_nodes_without_edges = reader.uint64().toBigInt();
                    break;
                case /* uint64 number_of_nodes_without_indegree */ 16:
                    message.number_of_nodes_without_indegree = reader.uint64().toBigInt();
                    break;
                case /* uint64 number_of_objects */ 17:
                    message.number_of_objects = reader.uint64().toBigInt();
                    break;
                case /* uint64 number_of_removed_objects */ 18:
                    message.number_of_removed_objects = reader.uint64().toBigInt();
                    break;
                case /* uint64 size_of_object_repository */ 19:
                    message.size_of_object_repository = reader.uint64().toBigInt();
                    break;
                case /* uint64 size_of_refinement_object_repository */ 20:
                    message.size_of_refinement_object_repository = reader.uint64().toBigInt();
                    break;
                case /* double variance_of_indegree */ 21:
                    message.variance_of_indegree = reader.double();
                    break;
                case /* double variance_of_outdegree */ 22:
                    message.variance_of_outdegree = reader.double();
                    break;
                case /* double mean_edge_length */ 23:
                    message.mean_edge_length = reader.double();
                    break;
                case /* double mean_edge_length_for_10_edges */ 24:
                    message.mean_edge_length_for_10_edges = reader.double();
                    break;
                case /* double mean_indegree_distance_for_10_edges */ 25:
                    message.mean_indegree_distance_for_10_edges = reader.double();
                    break;
                case /* double mean_number_of_edges_per_node */ 26:
                    message.mean_number_of_edges_per_node = reader.double();
                    break;
                case /* double c1_indegree */ 27:
                    message.c1_indegree = reader.double();
                    break;
                case /* double c5_indegree */ 28:
                    message.c5_indegree = reader.double();
                    break;
                case /* double c95_outdegree */ 29:
                    message.c95_outdegree = reader.double();
                    break;
                case /* double c99_outdegree */ 30:
                    message.c99_outdegree = reader.double();
                    break;
                case /* repeated int64 indegree_count */ 31:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.indegree_count.push(reader.int64().toBigInt());
                    else
                        message.indegree_count.push(reader.int64().toBigInt());
                    break;
                case /* repeated uint64 outdegree_histogram */ 32:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.outdegree_histogram.push(reader.uint64().toBigInt());
                    else
                        message.outdegree_histogram.push(reader.uint64().toBigInt());
                    break;
                case /* repeated uint64 indegree_histogram */ 33:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.indegree_histogram.push(reader.uint64().toBigInt());
                    else
                        message.indegree_histogram.push(reader.uint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool valid = 1; */
        if (message.valid !== false)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.valid);
        /* int32 median_indegree = 2; */
        if (message.median_indegree !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.median_indegree);
        /* int32 median_outdegree = 3; */
        if (message.median_outdegree !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.median_outdegree);
        /* uint64 max_number_of_indegree = 4; */
        if (message.max_number_of_indegree !== 0n)
            writer.tag(4, runtime_1.WireType.Varint).uint64(message.max_number_of_indegree);
        /* uint64 max_number_of_outdegree = 5; */
        if (message.max_number_of_outdegree !== 0n)
            writer.tag(5, runtime_1.WireType.Varint).uint64(message.max_number_of_outdegree);
        /* uint64 min_number_of_indegree = 6; */
        if (message.min_number_of_indegree !== 0n)
            writer.tag(6, runtime_1.WireType.Varint).uint64(message.min_number_of_indegree);
        /* uint64 min_number_of_outdegree = 7; */
        if (message.min_number_of_outdegree !== 0n)
            writer.tag(7, runtime_1.WireType.Varint).uint64(message.min_number_of_outdegree);
        /* uint64 mode_indegree = 8; */
        if (message.mode_indegree !== 0n)
            writer.tag(8, runtime_1.WireType.Varint).uint64(message.mode_indegree);
        /* uint64 mode_outdegree = 9; */
        if (message.mode_outdegree !== 0n)
            writer.tag(9, runtime_1.WireType.Varint).uint64(message.mode_outdegree);
        /* uint64 nodes_skipped_for_10_edges = 10; */
        if (message.nodes_skipped_for_10_edges !== 0n)
            writer.tag(10, runtime_1.WireType.Varint).uint64(message.nodes_skipped_for_10_edges);
        /* uint64 nodes_skipped_for_indegree_distance = 11; */
        if (message.nodes_skipped_for_indegree_distance !== 0n)
            writer.tag(11, runtime_1.WireType.Varint).uint64(message.nodes_skipped_for_indegree_distance);
        /* uint64 number_of_edges = 12; */
        if (message.number_of_edges !== 0n)
            writer.tag(12, runtime_1.WireType.Varint).uint64(message.number_of_edges);
        /* uint64 number_of_indexed_objects = 13; */
        if (message.number_of_indexed_objects !== 0n)
            writer.tag(13, runtime_1.WireType.Varint).uint64(message.number_of_indexed_objects);
        /* uint64 number_of_nodes = 14; */
        if (message.number_of_nodes !== 0n)
            writer.tag(14, runtime_1.WireType.Varint).uint64(message.number_of_nodes);
        /* uint64 number_of_nodes_without_edges = 15; */
        if (message.number_of_nodes_without_edges !== 0n)
            writer.tag(15, runtime_1.WireType.Varint).uint64(message.number_of_nodes_without_edges);
        /* uint64 number_of_nodes_without_indegree = 16; */
        if (message.number_of_nodes_without_indegree !== 0n)
            writer.tag(16, runtime_1.WireType.Varint).uint64(message.number_of_nodes_without_indegree);
        /* uint64 number_of_objects = 17; */
        if (message.number_of_objects !== 0n)
            writer.tag(17, runtime_1.WireType.Varint).uint64(message.number_of_objects);
        /* uint64 number_of_removed_objects = 18; */
        if (message.number_of_removed_objects !== 0n)
            writer.tag(18, runtime_1.WireType.Varint).uint64(message.number_of_removed_objects);
        /* uint64 size_of_object_repository = 19; */
        if (message.size_of_object_repository !== 0n)
            writer.tag(19, runtime_1.WireType.Varint).uint64(message.size_of_object_repository);
        /* uint64 size_of_refinement_object_repository = 20; */
        if (message.size_of_refinement_object_repository !== 0n)
            writer.tag(20, runtime_1.WireType.Varint).uint64(message.size_of_refinement_object_repository);
        /* double variance_of_indegree = 21; */
        if (message.variance_of_indegree !== 0)
            writer.tag(21, runtime_1.WireType.Bit64).double(message.variance_of_indegree);
        /* double variance_of_outdegree = 22; */
        if (message.variance_of_outdegree !== 0)
            writer.tag(22, runtime_1.WireType.Bit64).double(message.variance_of_outdegree);
        /* double mean_edge_length = 23; */
        if (message.mean_edge_length !== 0)
            writer.tag(23, runtime_1.WireType.Bit64).double(message.mean_edge_length);
        /* double mean_edge_length_for_10_edges = 24; */
        if (message.mean_edge_length_for_10_edges !== 0)
            writer.tag(24, runtime_1.WireType.Bit64).double(message.mean_edge_length_for_10_edges);
        /* double mean_indegree_distance_for_10_edges = 25; */
        if (message.mean_indegree_distance_for_10_edges !== 0)
            writer.tag(25, runtime_1.WireType.Bit64).double(message.mean_indegree_distance_for_10_edges);
        /* double mean_number_of_edges_per_node = 26; */
        if (message.mean_number_of_edges_per_node !== 0)
            writer.tag(26, runtime_1.WireType.Bit64).double(message.mean_number_of_edges_per_node);
        /* double c1_indegree = 27; */
        if (message.c1_indegree !== 0)
            writer.tag(27, runtime_1.WireType.Bit64).double(message.c1_indegree);
        /* double c5_indegree = 28; */
        if (message.c5_indegree !== 0)
            writer.tag(28, runtime_1.WireType.Bit64).double(message.c5_indegree);
        /* double c95_outdegree = 29; */
        if (message.c95_outdegree !== 0)
            writer.tag(29, runtime_1.WireType.Bit64).double(message.c95_outdegree);
        /* double c99_outdegree = 30; */
        if (message.c99_outdegree !== 0)
            writer.tag(30, runtime_1.WireType.Bit64).double(message.c99_outdegree);
        /* repeated int64 indegree_count = 31; */
        if (message.indegree_count.length) {
            writer.tag(31, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.indegree_count.length; i++)
                writer.int64(message.indegree_count[i]);
            writer.join();
        }
        /* repeated uint64 outdegree_histogram = 32; */
        if (message.outdegree_histogram.length) {
            writer.tag(32, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.outdegree_histogram.length; i++)
                writer.uint64(message.outdegree_histogram[i]);
            writer.join();
        }
        /* repeated uint64 indegree_histogram = 33; */
        if (message.indegree_histogram.length) {
            writer.tag(33, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.indegree_histogram.length; i++)
                writer.uint64(message.indegree_histogram[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Index.Statistics
 */
exports.Info_Index_Statistics = new Info_Index_Statistics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Index_StatisticsDetail$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.Index.StatisticsDetail", [
            { no: 1, name: "details", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => exports.Info_Index_Statistics } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.details = {};
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, payload.v1.Info.Index.Statistics> details */ 1:
                    this.binaryReadMap1(message.details, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    binaryReadMap1(map, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = exports.Info_Index_Statistics.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for payload.v1.Info.Index.StatisticsDetail.details");
            }
        }
        map[key ?? ""] = val ?? exports.Info_Index_Statistics.create();
    }
    internalBinaryWrite(message, writer, options) {
        /* map<string, payload.v1.Info.Index.Statistics> details = 1; */
        for (let k of globalThis.Object.keys(message.details)) {
            writer.tag(1, runtime_1.WireType.LengthDelimited).fork().tag(1, runtime_1.WireType.LengthDelimited).string(k);
            writer.tag(2, runtime_1.WireType.LengthDelimited).fork();
            exports.Info_Index_Statistics.internalBinaryWrite(message.details[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Index.StatisticsDetail
 */
exports.Info_Index_StatisticsDetail = new Info_Index_StatisticsDetail$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Index_Property$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.Index.Property", [
            { no: 1, name: "dimension", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "thread_pool_size", kind: "scalar", localName: "thread_pool_size", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "object_type", kind: "scalar", localName: "object_type", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "distance_type", kind: "scalar", localName: "distance_type", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "index_type", kind: "scalar", localName: "index_type", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "database_type", kind: "scalar", localName: "database_type", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "object_alignment", kind: "scalar", localName: "object_alignment", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "path_adjustment_interval", kind: "scalar", localName: "path_adjustment_interval", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "graph_shared_memory_size", kind: "scalar", localName: "graph_shared_memory_size", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "tree_shared_memory_size", kind: "scalar", localName: "tree_shared_memory_size", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "object_shared_memory_size", kind: "scalar", localName: "object_shared_memory_size", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "prefetch_offset", kind: "scalar", localName: "prefetch_offset", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "prefetch_size", kind: "scalar", localName: "prefetch_size", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "accuracy_table", kind: "scalar", localName: "accuracy_table", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "search_type", kind: "scalar", localName: "search_type", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "max_magnitude", kind: "scalar", localName: "max_magnitude", T: 2 /*ScalarType.FLOAT*/ },
            { no: 17, name: "n_of_neighbors_for_insertion_order", kind: "scalar", localName: "n_of_neighbors_for_insertion_order", T: 5 /*ScalarType.INT32*/ },
            { no: 18, name: "epsilon_for_insertion_order", kind: "scalar", localName: "epsilon_for_insertion_order", T: 2 /*ScalarType.FLOAT*/ },
            { no: 19, name: "refinement_object_type", kind: "scalar", localName: "refinement_object_type", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "truncation_threshold", kind: "scalar", localName: "truncation_threshold", T: 5 /*ScalarType.INT32*/ },
            { no: 21, name: "edge_size_for_creation", kind: "scalar", localName: "edge_size_for_creation", T: 5 /*ScalarType.INT32*/ },
            { no: 22, name: "edge_size_for_search", kind: "scalar", localName: "edge_size_for_search", T: 5 /*ScalarType.INT32*/ },
            { no: 23, name: "edge_size_limit_for_creation", kind: "scalar", localName: "edge_size_limit_for_creation", T: 5 /*ScalarType.INT32*/ },
            { no: 24, name: "insertion_radius_coefficient", kind: "scalar", localName: "insertion_radius_coefficient", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 25, name: "seed_size", kind: "scalar", localName: "seed_size", T: 5 /*ScalarType.INT32*/ },
            { no: 26, name: "seed_type", kind: "scalar", localName: "seed_type", T: 9 /*ScalarType.STRING*/ },
            { no: 27, name: "truncation_thread_pool_size", kind: "scalar", localName: "truncation_thread_pool_size", T: 5 /*ScalarType.INT32*/ },
            { no: 28, name: "batch_size_for_creation", kind: "scalar", localName: "batch_size_for_creation", T: 5 /*ScalarType.INT32*/ },
            { no: 29, name: "graph_type", kind: "scalar", localName: "graph_type", T: 9 /*ScalarType.STRING*/ },
            { no: 30, name: "dynamic_edge_size_base", kind: "scalar", localName: "dynamic_edge_size_base", T: 5 /*ScalarType.INT32*/ },
            { no: 31, name: "dynamic_edge_size_rate", kind: "scalar", localName: "dynamic_edge_size_rate", T: 5 /*ScalarType.INT32*/ },
            { no: 32, name: "build_time_limit", kind: "scalar", localName: "build_time_limit", T: 2 /*ScalarType.FLOAT*/ },
            { no: 33, name: "outgoing_edge", kind: "scalar", localName: "outgoing_edge", T: 5 /*ScalarType.INT32*/ },
            { no: 34, name: "incoming_edge", kind: "scalar", localName: "incoming_edge", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.dimension = 0;
        message.thread_pool_size = 0;
        message.object_type = "";
        message.distance_type = "";
        message.index_type = "";
        message.database_type = "";
        message.object_alignment = "";
        message.path_adjustment_interval = 0;
        message.graph_shared_memory_size = 0;
        message.tree_shared_memory_size = 0;
        message.object_shared_memory_size = 0;
        message.prefetch_offset = 0;
        message.prefetch_size = 0;
        message.accuracy_table = "";
        message.search_type = "";
        message.max_magnitude = 0;
        message.n_of_neighbors_for_insertion_order = 0;
        message.epsilon_for_insertion_order = 0;
        message.refinement_object_type = "";
        message.truncation_threshold = 0;
        message.edge_size_for_creation = 0;
        message.edge_size_for_search = 0;
        message.edge_size_limit_for_creation = 0;
        message.insertion_radius_coefficient = 0;
        message.seed_size = 0;
        message.seed_type = "";
        message.truncation_thread_pool_size = 0;
        message.batch_size_for_creation = 0;
        message.graph_type = "";
        message.dynamic_edge_size_base = 0;
        message.dynamic_edge_size_rate = 0;
        message.build_time_limit = 0;
        message.outgoing_edge = 0;
        message.incoming_edge = 0;
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 dimension */ 1:
                    message.dimension = reader.int32();
                    break;
                case /* int32 thread_pool_size */ 2:
                    message.thread_pool_size = reader.int32();
                    break;
                case /* string object_type */ 3:
                    message.object_type = reader.string();
                    break;
                case /* string distance_type */ 4:
                    message.distance_type = reader.string();
                    break;
                case /* string index_type */ 5:
                    message.index_type = reader.string();
                    break;
                case /* string database_type */ 6:
                    message.database_type = reader.string();
                    break;
                case /* string object_alignment */ 7:
                    message.object_alignment = reader.string();
                    break;
                case /* int32 path_adjustment_interval */ 8:
                    message.path_adjustment_interval = reader.int32();
                    break;
                case /* int32 graph_shared_memory_size */ 9:
                    message.graph_shared_memory_size = reader.int32();
                    break;
                case /* int32 tree_shared_memory_size */ 10:
                    message.tree_shared_memory_size = reader.int32();
                    break;
                case /* int32 object_shared_memory_size */ 11:
                    message.object_shared_memory_size = reader.int32();
                    break;
                case /* int32 prefetch_offset */ 12:
                    message.prefetch_offset = reader.int32();
                    break;
                case /* int32 prefetch_size */ 13:
                    message.prefetch_size = reader.int32();
                    break;
                case /* string accuracy_table */ 14:
                    message.accuracy_table = reader.string();
                    break;
                case /* string search_type */ 15:
                    message.search_type = reader.string();
                    break;
                case /* float max_magnitude */ 16:
                    message.max_magnitude = reader.float();
                    break;
                case /* int32 n_of_neighbors_for_insertion_order */ 17:
                    message.n_of_neighbors_for_insertion_order = reader.int32();
                    break;
                case /* float epsilon_for_insertion_order */ 18:
                    message.epsilon_for_insertion_order = reader.float();
                    break;
                case /* string refinement_object_type */ 19:
                    message.refinement_object_type = reader.string();
                    break;
                case /* int32 truncation_threshold */ 20:
                    message.truncation_threshold = reader.int32();
                    break;
                case /* int32 edge_size_for_creation */ 21:
                    message.edge_size_for_creation = reader.int32();
                    break;
                case /* int32 edge_size_for_search */ 22:
                    message.edge_size_for_search = reader.int32();
                    break;
                case /* int32 edge_size_limit_for_creation */ 23:
                    message.edge_size_limit_for_creation = reader.int32();
                    break;
                case /* double insertion_radius_coefficient */ 24:
                    message.insertion_radius_coefficient = reader.double();
                    break;
                case /* int32 seed_size */ 25:
                    message.seed_size = reader.int32();
                    break;
                case /* string seed_type */ 26:
                    message.seed_type = reader.string();
                    break;
                case /* int32 truncation_thread_pool_size */ 27:
                    message.truncation_thread_pool_size = reader.int32();
                    break;
                case /* int32 batch_size_for_creation */ 28:
                    message.batch_size_for_creation = reader.int32();
                    break;
                case /* string graph_type */ 29:
                    message.graph_type = reader.string();
                    break;
                case /* int32 dynamic_edge_size_base */ 30:
                    message.dynamic_edge_size_base = reader.int32();
                    break;
                case /* int32 dynamic_edge_size_rate */ 31:
                    message.dynamic_edge_size_rate = reader.int32();
                    break;
                case /* float build_time_limit */ 32:
                    message.build_time_limit = reader.float();
                    break;
                case /* int32 outgoing_edge */ 33:
                    message.outgoing_edge = reader.int32();
                    break;
                case /* int32 incoming_edge */ 34:
                    message.incoming_edge = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int32 dimension = 1; */
        if (message.dimension !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.dimension);
        /* int32 thread_pool_size = 2; */
        if (message.thread_pool_size !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.thread_pool_size);
        /* string object_type = 3; */
        if (message.object_type !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.object_type);
        /* string distance_type = 4; */
        if (message.distance_type !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.distance_type);
        /* string index_type = 5; */
        if (message.index_type !== "")
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.index_type);
        /* string database_type = 6; */
        if (message.database_type !== "")
            writer.tag(6, runtime_1.WireType.LengthDelimited).string(message.database_type);
        /* string object_alignment = 7; */
        if (message.object_alignment !== "")
            writer.tag(7, runtime_1.WireType.LengthDelimited).string(message.object_alignment);
        /* int32 path_adjustment_interval = 8; */
        if (message.path_adjustment_interval !== 0)
            writer.tag(8, runtime_1.WireType.Varint).int32(message.path_adjustment_interval);
        /* int32 graph_shared_memory_size = 9; */
        if (message.graph_shared_memory_size !== 0)
            writer.tag(9, runtime_1.WireType.Varint).int32(message.graph_shared_memory_size);
        /* int32 tree_shared_memory_size = 10; */
        if (message.tree_shared_memory_size !== 0)
            writer.tag(10, runtime_1.WireType.Varint).int32(message.tree_shared_memory_size);
        /* int32 object_shared_memory_size = 11; */
        if (message.object_shared_memory_size !== 0)
            writer.tag(11, runtime_1.WireType.Varint).int32(message.object_shared_memory_size);
        /* int32 prefetch_offset = 12; */
        if (message.prefetch_offset !== 0)
            writer.tag(12, runtime_1.WireType.Varint).int32(message.prefetch_offset);
        /* int32 prefetch_size = 13; */
        if (message.prefetch_size !== 0)
            writer.tag(13, runtime_1.WireType.Varint).int32(message.prefetch_size);
        /* string accuracy_table = 14; */
        if (message.accuracy_table !== "")
            writer.tag(14, runtime_1.WireType.LengthDelimited).string(message.accuracy_table);
        /* string search_type = 15; */
        if (message.search_type !== "")
            writer.tag(15, runtime_1.WireType.LengthDelimited).string(message.search_type);
        /* float max_magnitude = 16; */
        if (message.max_magnitude !== 0)
            writer.tag(16, runtime_1.WireType.Bit32).float(message.max_magnitude);
        /* int32 n_of_neighbors_for_insertion_order = 17; */
        if (message.n_of_neighbors_for_insertion_order !== 0)
            writer.tag(17, runtime_1.WireType.Varint).int32(message.n_of_neighbors_for_insertion_order);
        /* float epsilon_for_insertion_order = 18; */
        if (message.epsilon_for_insertion_order !== 0)
            writer.tag(18, runtime_1.WireType.Bit32).float(message.epsilon_for_insertion_order);
        /* string refinement_object_type = 19; */
        if (message.refinement_object_type !== "")
            writer.tag(19, runtime_1.WireType.LengthDelimited).string(message.refinement_object_type);
        /* int32 truncation_threshold = 20; */
        if (message.truncation_threshold !== 0)
            writer.tag(20, runtime_1.WireType.Varint).int32(message.truncation_threshold);
        /* int32 edge_size_for_creation = 21; */
        if (message.edge_size_for_creation !== 0)
            writer.tag(21, runtime_1.WireType.Varint).int32(message.edge_size_for_creation);
        /* int32 edge_size_for_search = 22; */
        if (message.edge_size_for_search !== 0)
            writer.tag(22, runtime_1.WireType.Varint).int32(message.edge_size_for_search);
        /* int32 edge_size_limit_for_creation = 23; */
        if (message.edge_size_limit_for_creation !== 0)
            writer.tag(23, runtime_1.WireType.Varint).int32(message.edge_size_limit_for_creation);
        /* double insertion_radius_coefficient = 24; */
        if (message.insertion_radius_coefficient !== 0)
            writer.tag(24, runtime_1.WireType.Bit64).double(message.insertion_radius_coefficient);
        /* int32 seed_size = 25; */
        if (message.seed_size !== 0)
            writer.tag(25, runtime_1.WireType.Varint).int32(message.seed_size);
        /* string seed_type = 26; */
        if (message.seed_type !== "")
            writer.tag(26, runtime_1.WireType.LengthDelimited).string(message.seed_type);
        /* int32 truncation_thread_pool_size = 27; */
        if (message.truncation_thread_pool_size !== 0)
            writer.tag(27, runtime_1.WireType.Varint).int32(message.truncation_thread_pool_size);
        /* int32 batch_size_for_creation = 28; */
        if (message.batch_size_for_creation !== 0)
            writer.tag(28, runtime_1.WireType.Varint).int32(message.batch_size_for_creation);
        /* string graph_type = 29; */
        if (message.graph_type !== "")
            writer.tag(29, runtime_1.WireType.LengthDelimited).string(message.graph_type);
        /* int32 dynamic_edge_size_base = 30; */
        if (message.dynamic_edge_size_base !== 0)
            writer.tag(30, runtime_1.WireType.Varint).int32(message.dynamic_edge_size_base);
        /* int32 dynamic_edge_size_rate = 31; */
        if (message.dynamic_edge_size_rate !== 0)
            writer.tag(31, runtime_1.WireType.Varint).int32(message.dynamic_edge_size_rate);
        /* float build_time_limit = 32; */
        if (message.build_time_limit !== 0)
            writer.tag(32, runtime_1.WireType.Bit32).float(message.build_time_limit);
        /* int32 outgoing_edge = 33; */
        if (message.outgoing_edge !== 0)
            writer.tag(33, runtime_1.WireType.Varint).int32(message.outgoing_edge);
        /* int32 incoming_edge = 34; */
        if (message.incoming_edge !== 0)
            writer.tag(34, runtime_1.WireType.Varint).int32(message.incoming_edge);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Index.Property
 */
exports.Info_Index_Property = new Info_Index_Property$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Index_PropertyDetail$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.Index.PropertyDetail", [
            { no: 1, name: "details", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => exports.Info_Index_Property } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.details = {};
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, payload.v1.Info.Index.Property> details */ 1:
                    this.binaryReadMap1(message.details, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    binaryReadMap1(map, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = exports.Info_Index_Property.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for payload.v1.Info.Index.PropertyDetail.details");
            }
        }
        map[key ?? ""] = val ?? exports.Info_Index_Property.create();
    }
    internalBinaryWrite(message, writer, options) {
        /* map<string, payload.v1.Info.Index.Property> details = 1; */
        for (let k of globalThis.Object.keys(message.details)) {
            writer.tag(1, runtime_1.WireType.LengthDelimited).fork().tag(1, runtime_1.WireType.LengthDelimited).string(k);
            writer.tag(2, runtime_1.WireType.LengthDelimited).fork();
            exports.Info_Index_Property.internalBinaryWrite(message.details[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Index.PropertyDetail
 */
exports.Info_Index_PropertyDetail = new Info_Index_PropertyDetail$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_ResourceStats$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.ResourceStats", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ip", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { ipv4: true } } } },
            { no: 3, name: "cgroup_stats", kind: "message", localName: "cgroup_stats", T: () => exports.Info_CgroupStats }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.name = "";
        message.ip = "";
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string ip */ 2:
                    message.ip = reader.string();
                    break;
                case /* payload.v1.Info.CgroupStats cgroup_stats */ 3:
                    message.cgroup_stats = exports.Info_CgroupStats.internalBinaryRead(reader, reader.uint32(), options, message.cgroup_stats);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string ip = 2; */
        if (message.ip !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.ip);
        /* payload.v1.Info.CgroupStats cgroup_stats = 3; */
        if (message.cgroup_stats)
            exports.Info_CgroupStats.internalBinaryWrite(message.cgroup_stats, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.ResourceStats
 */
exports.Info_ResourceStats = new Info_ResourceStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_CgroupStats$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.CgroupStats", [
            { no: 1, name: "cpu_limit_cores", kind: "scalar", localName: "cpu_limit_cores", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "cpu_usage_cores", kind: "scalar", localName: "cpu_usage_cores", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "memory_limit_bytes", kind: "scalar", localName: "memory_limit_bytes", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "memory_usage_bytes", kind: "scalar", localName: "memory_usage_bytes", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.cpu_limit_cores = 0;
        message.cpu_usage_cores = 0;
        message.memory_limit_bytes = 0n;
        message.memory_usage_bytes = 0n;
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double cpu_limit_cores */ 1:
                    message.cpu_limit_cores = reader.double();
                    break;
                case /* double cpu_usage_cores */ 2:
                    message.cpu_usage_cores = reader.double();
                    break;
                case /* uint64 memory_limit_bytes */ 3:
                    message.memory_limit_bytes = reader.uint64().toBigInt();
                    break;
                case /* uint64 memory_usage_bytes */ 4:
                    message.memory_usage_bytes = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* double cpu_limit_cores = 1; */
        if (message.cpu_limit_cores !== 0)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.cpu_limit_cores);
        /* double cpu_usage_cores = 2; */
        if (message.cpu_usage_cores !== 0)
            writer.tag(2, runtime_1.WireType.Bit64).double(message.cpu_usage_cores);
        /* uint64 memory_limit_bytes = 3; */
        if (message.memory_limit_bytes !== 0n)
            writer.tag(3, runtime_1.WireType.Varint).uint64(message.memory_limit_bytes);
        /* uint64 memory_usage_bytes = 4; */
        if (message.memory_usage_bytes !== 0n)
            writer.tag(4, runtime_1.WireType.Varint).uint64(message.memory_usage_bytes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.CgroupStats
 */
exports.Info_CgroupStats = new Info_CgroupStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Pod$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.Pod", [
            { no: 1, name: "app_name", kind: "scalar", localName: "app_name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "namespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ip", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { ipv4: true } } } },
            { no: 5, name: "cpu", kind: "message", T: () => exports.Info_CPU },
            { no: 6, name: "memory", kind: "message", T: () => exports.Info_Memory },
            { no: 7, name: "node", kind: "message", T: () => exports.Info_Node }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.app_name = "";
        message.name = "";
        message.namespace = "";
        message.ip = "";
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string app_name */ 1:
                    message.app_name = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string namespace */ 3:
                    message.namespace = reader.string();
                    break;
                case /* string ip */ 4:
                    message.ip = reader.string();
                    break;
                case /* payload.v1.Info.CPU cpu */ 5:
                    message.cpu = exports.Info_CPU.internalBinaryRead(reader, reader.uint32(), options, message.cpu);
                    break;
                case /* payload.v1.Info.Memory memory */ 6:
                    message.memory = exports.Info_Memory.internalBinaryRead(reader, reader.uint32(), options, message.memory);
                    break;
                case /* payload.v1.Info.Node node */ 7:
                    message.node = exports.Info_Node.internalBinaryRead(reader, reader.uint32(), options, message.node);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string app_name = 1; */
        if (message.app_name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.app_name);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string namespace = 3; */
        if (message.namespace !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.namespace);
        /* string ip = 4; */
        if (message.ip !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.ip);
        /* payload.v1.Info.CPU cpu = 5; */
        if (message.cpu)
            exports.Info_CPU.internalBinaryWrite(message.cpu, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Info.Memory memory = 6; */
        if (message.memory)
            exports.Info_Memory.internalBinaryWrite(message.memory, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Info.Node node = 7; */
        if (message.node)
            exports.Info_Node.internalBinaryWrite(message.node, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Pod
 */
exports.Info_Pod = new Info_Pod$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Node$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.Node", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "internal_addr", kind: "scalar", localName: "internal_addr", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "external_addr", kind: "scalar", localName: "external_addr", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "cpu", kind: "message", T: () => exports.Info_CPU },
            { no: 5, name: "memory", kind: "message", T: () => exports.Info_Memory },
            { no: 6, name: "Pods", kind: "message", localName: "Pods", jsonName: "Pods", T: () => exports.Info_Pods }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.name = "";
        message.internal_addr = "";
        message.external_addr = "";
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string internal_addr */ 2:
                    message.internal_addr = reader.string();
                    break;
                case /* string external_addr */ 3:
                    message.external_addr = reader.string();
                    break;
                case /* payload.v1.Info.CPU cpu */ 4:
                    message.cpu = exports.Info_CPU.internalBinaryRead(reader, reader.uint32(), options, message.cpu);
                    break;
                case /* payload.v1.Info.Memory memory */ 5:
                    message.memory = exports.Info_Memory.internalBinaryRead(reader, reader.uint32(), options, message.memory);
                    break;
                case /* payload.v1.Info.Pods Pods */ 6:
                    message.Pods = exports.Info_Pods.internalBinaryRead(reader, reader.uint32(), options, message.Pods);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string internal_addr = 2; */
        if (message.internal_addr !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.internal_addr);
        /* string external_addr = 3; */
        if (message.external_addr !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.external_addr);
        /* payload.v1.Info.CPU cpu = 4; */
        if (message.cpu)
            exports.Info_CPU.internalBinaryWrite(message.cpu, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Info.Memory memory = 5; */
        if (message.memory)
            exports.Info_Memory.internalBinaryWrite(message.memory, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Info.Pods Pods = 6; */
        if (message.Pods)
            exports.Info_Pods.internalBinaryWrite(message.Pods, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Node
 */
exports.Info_Node = new Info_Node$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Service$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.Service", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cluster_ip", kind: "scalar", localName: "cluster_ip", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "cluster_ips", kind: "scalar", localName: "cluster_ips", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ports", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Info_ServicePort },
            { no: 5, name: "labels", kind: "message", T: () => exports.Info_Labels },
            { no: 6, name: "annotations", kind: "message", T: () => exports.Info_Annotations }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.name = "";
        message.cluster_ip = "";
        message.cluster_ips = [];
        message.ports = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string cluster_ip */ 2:
                    message.cluster_ip = reader.string();
                    break;
                case /* repeated string cluster_ips */ 3:
                    message.cluster_ips.push(reader.string());
                    break;
                case /* repeated payload.v1.Info.ServicePort ports */ 4:
                    message.ports.push(exports.Info_ServicePort.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* payload.v1.Info.Labels labels */ 5:
                    message.labels = exports.Info_Labels.internalBinaryRead(reader, reader.uint32(), options, message.labels);
                    break;
                case /* payload.v1.Info.Annotations annotations */ 6:
                    message.annotations = exports.Info_Annotations.internalBinaryRead(reader, reader.uint32(), options, message.annotations);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string cluster_ip = 2; */
        if (message.cluster_ip !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.cluster_ip);
        /* repeated string cluster_ips = 3; */
        for (let i = 0; i < message.cluster_ips.length; i++)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.cluster_ips[i]);
        /* repeated payload.v1.Info.ServicePort ports = 4; */
        for (let i = 0; i < message.ports.length; i++)
            exports.Info_ServicePort.internalBinaryWrite(message.ports[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Info.Labels labels = 5; */
        if (message.labels)
            exports.Info_Labels.internalBinaryWrite(message.labels, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Info.Annotations annotations = 6; */
        if (message.annotations)
            exports.Info_Annotations.internalBinaryWrite(message.annotations, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Service
 */
exports.Info_Service = new Info_Service$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_ServicePort$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.ServicePort", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.name = "";
        message.port = 0;
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 port */ 2:
                    message.port = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* int32 port = 2; */
        if (message.port !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.port);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.ServicePort
 */
exports.Info_ServicePort = new Info_ServicePort$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Labels$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.Labels", [
            { no: 1, name: "labels", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.labels = {};
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> labels */ 1:
                    this.binaryReadMap1(message.labels, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    binaryReadMap1(map, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for payload.v1.Info.Labels.labels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message, writer, options) {
        /* map<string, string> labels = 1; */
        for (let k of globalThis.Object.keys(message.labels))
            writer.tag(1, runtime_1.WireType.LengthDelimited).fork().tag(1, runtime_1.WireType.LengthDelimited).string(k).tag(2, runtime_1.WireType.LengthDelimited).string(message.labels[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Labels
 */
exports.Info_Labels = new Info_Labels$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Annotations$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.Annotations", [
            { no: 1, name: "annotations", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.annotations = {};
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> annotations */ 1:
                    this.binaryReadMap1(message.annotations, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    binaryReadMap1(map, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for payload.v1.Info.Annotations.annotations");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message, writer, options) {
        /* map<string, string> annotations = 1; */
        for (let k of globalThis.Object.keys(message.annotations))
            writer.tag(1, runtime_1.WireType.LengthDelimited).fork().tag(1, runtime_1.WireType.LengthDelimited).string(k).tag(2, runtime_1.WireType.LengthDelimited).string(message.annotations[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Annotations
 */
exports.Info_Annotations = new Info_Annotations$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_CPU$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.CPU", [
            { no: 1, name: "limit", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "request", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "usage", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.limit = 0;
        message.request = 0;
        message.usage = 0;
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double limit */ 1:
                    message.limit = reader.double();
                    break;
                case /* double request */ 2:
                    message.request = reader.double();
                    break;
                case /* double usage */ 3:
                    message.usage = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* double limit = 1; */
        if (message.limit !== 0)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.limit);
        /* double request = 2; */
        if (message.request !== 0)
            writer.tag(2, runtime_1.WireType.Bit64).double(message.request);
        /* double usage = 3; */
        if (message.usage !== 0)
            writer.tag(3, runtime_1.WireType.Bit64).double(message.usage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.CPU
 */
exports.Info_CPU = new Info_CPU$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Memory$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.Memory", [
            { no: 1, name: "limit", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "request", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "usage", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.limit = 0;
        message.request = 0;
        message.usage = 0;
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double limit */ 1:
                    message.limit = reader.double();
                    break;
                case /* double request */ 2:
                    message.request = reader.double();
                    break;
                case /* double usage */ 3:
                    message.usage = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* double limit = 1; */
        if (message.limit !== 0)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.limit);
        /* double request = 2; */
        if (message.request !== 0)
            writer.tag(2, runtime_1.WireType.Bit64).double(message.request);
        /* double usage = 3; */
        if (message.usage !== 0)
            writer.tag(3, runtime_1.WireType.Bit64).double(message.usage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Memory
 */
exports.Info_Memory = new Info_Memory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Pods$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.Pods", [
            { no: 1, name: "pods", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Info_Pod, options: { "buf.validate.field": { repeated: { minItems: "1" } } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.pods = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Info.Pod pods */ 1:
                    message.pods.push(exports.Info_Pod.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated payload.v1.Info.Pod pods = 1; */
        for (let i = 0; i < message.pods.length; i++)
            exports.Info_Pod.internalBinaryWrite(message.pods[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Pods
 */
exports.Info_Pods = new Info_Pods$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Nodes$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.Nodes", [
            { no: 1, name: "nodes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Info_Node, options: { "buf.validate.field": { repeated: { minItems: "1" } } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.nodes = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Info.Node nodes */ 1:
                    message.nodes.push(exports.Info_Node.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated payload.v1.Info.Node nodes = 1; */
        for (let i = 0; i < message.nodes.length; i++)
            exports.Info_Node.internalBinaryWrite(message.nodes[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Nodes
 */
exports.Info_Nodes = new Info_Nodes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_Services$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.Services", [
            { no: 1, name: "services", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Info_Service, options: { "buf.validate.field": { repeated: { minItems: "1" } } } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.services = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Info.Service services */ 1:
                    message.services.push(exports.Info_Service.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated payload.v1.Info.Service services = 1; */
        for (let i = 0; i < message.services.length; i++)
            exports.Info_Service.internalBinaryWrite(message.services[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.Services
 */
exports.Info_Services = new Info_Services$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Info_IPs$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Info.IPs", [
            { no: 1, name: "ip", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.ip = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string ip */ 1:
                    message.ip.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated string ip = 1; */
        for (let i = 0; i < message.ip.length; i++)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.ip[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Info.IPs
 */
exports.Info_IPs = new Info_IPs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Mirror$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Mirror", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Mirror
 */
exports.Mirror = new Mirror$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Mirror_Target$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Mirror.Target", [
            { no: 1, name: "host", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.host = "";
        message.port = 0;
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string host */ 1:
                    message.host = reader.string();
                    break;
                case /* uint32 port */ 2:
                    message.port = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string host = 1; */
        if (message.host !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.host);
        /* uint32 port = 2; */
        if (message.port !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.port);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Mirror.Target
 */
exports.Mirror_Target = new Mirror_Target$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Mirror_Targets$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Mirror.Targets", [
            { no: 1, name: "targets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Mirror_Target }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.targets = [];
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated payload.v1.Mirror.Target targets */ 1:
                    message.targets.push(exports.Mirror_Target.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated payload.v1.Mirror.Target targets = 1; */
        for (let i = 0; i < message.targets.length; i++)
            exports.Mirror_Target.internalBinaryWrite(message.targets[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Mirror.Targets
 */
exports.Mirror_Targets = new Mirror_Targets$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Meta$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Meta", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Meta
 */
exports.Meta = new Meta$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Meta_Key$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Meta.Key", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.key = "";
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Meta.Key
 */
exports.Meta_Key = new Meta_Key$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Meta_Value$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Meta.Value", [
            { no: 1, name: "value", kind: "message", T: () => any_pb_1.Any }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any value */ 1:
                    message.value = any_pb_1.Any.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* google.protobuf.Any value = 1; */
        if (message.value)
            any_pb_1.Any.internalBinaryWrite(message.value, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Meta.Value
 */
exports.Meta_Value = new Meta_Value$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Meta_KeyValue$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Meta.KeyValue", [
            { no: 1, name: "key", kind: "message", T: () => exports.Meta_Key },
            { no: 2, name: "value", kind: "message", T: () => exports.Meta_Value }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* payload.v1.Meta.Key key */ 1:
                    message.key = exports.Meta_Key.internalBinaryRead(reader, reader.uint32(), options, message.key);
                    break;
                case /* payload.v1.Meta.Value value */ 2:
                    message.value = exports.Meta_Value.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* payload.v1.Meta.Key key = 1; */
        if (message.key)
            exports.Meta_Key.internalBinaryWrite(message.key, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* payload.v1.Meta.Value value = 2; */
        if (message.value)
            exports.Meta_Value.internalBinaryWrite(message.value, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Meta.KeyValue
 */
exports.Meta_KeyValue = new Meta_KeyValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Empty$Type extends runtime_4.MessageType {
    constructor() {
        super("payload.v1.Empty", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message payload.v1.Empty
 */
exports.Empty = new Empty$Type();
